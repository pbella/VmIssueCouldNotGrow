'From Cuis 5.0 of 7 November 2016 [latest update: #3192] on 11 October 2017 at 7:02:16 am'!


Object subclass: #AbstractFont
	instanceVariableNames: ''
	classVariableNames: 'AvailableFonts DefaultFont'
	poolDictionaries: ''
	category: 'Graphics-Text'!

!AbstractFont methodsFor: 'displaying' stamp: 'jmv 9/25/2017 20:24:32'!
                           on: aGrafPort displayString: aString from: firstIndex to: lastIndex at: p color: color
	"Answer last affected pixel position
	Answer nil if nothing was done"

	| char fallbackFont x y answer |
	fallbackFont _ (AbstractFont
		familyName: Preferences defaultFontFamily
		aroundPointSize: self pointSize*0.9)
			emphasized: self emphasis.
	x _ p x.
	y _ p y.
	firstIndex to: lastIndex do: [ :i |
		char _ aString at: i.
		answer _ aGrafPort displayString: char asString from: 1 to: 1 at: x@y strikeFont: fallbackFont color: color.
		x _ x + (self widthOf: char) ].
	^answer! !


AbstractFont class
	instanceVariableNames: ''!

!AbstractFont class methodsFor: 'instance accessing' stamp: 'jmv 9/25/2017 20:25:27'!
                          familyName: aString aroundPointSize: aNumber
	"
	AbstractFont familyName: Preferences defaultFontFamily aroundPointSize: 120
	"
	| familyDictionary found |
	familyDictionary _ AvailableFonts at: aString ifAbsent: [^nil].
	^familyDictionary at: aNumber ifAbsent: [
		familyDictionary do: [ :font |
			(found isNil or: [ (found pointSize - aNumber) abs > (font pointSize - aNumber) abs ])
				ifTrue: [ found _ font ]].
			found
		]! !

!AbstractFont class methodsFor: 'instance accessing' stamp: 'jmv 9/25/2017 20:25:34'!
                       familyName: aString pointSize: aNumber
	"
	AbstractFont familyName: Preferences defaultFontFamily pointSize: 12
	"
	| familyDictionary |
	familyDictionary _ AvailableFonts at: aString ifAbsent: [^nil].
	^familyDictionary at: aNumber ifAbsent: nil! !

!AbstractFont class methodsFor: 'instance accessing' stamp: 'jmv 9/25/2017 20:25:58'!
               pointSizesFor: aString
	"
	AbstractFont pointSizesFor: Preferences defaultFontFamily
	"
	| familyDictionary |
	familyDictionary _ AvailableFonts at: aString ifAbsent: [^#()].
	^familyDictionary keys sort! !

!AbstractFont class methodsFor: 'class initialization' stamp: 'jmv 9/25/2017 20:25:47'!
                        initialize
	"AvailableFonts is a dictionary whose keys are family names, such as 'DejaVu Sans' and values are family dictionaries
	family dictionaries have keys that are integers (point sizes such as 10 or 12) and values instances of the Font hierarcy
	
	Fonts with emphasis (such as bold or italic) are derivative fonts of the one found in the family dictionary"
	
	AvailableFonts _ Dictionary new! !


MorphicLocation variableWordSubclass: #AffineTransformation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

!AffineTransformation methodsFor: 'converting coordinates' stamp: 'jmv 6/19/2017 15:43:10'!
             internalizeDelta: aPoint
	"Internalize a distance vector. A distance is not a position. It is a magnitude with a direction.
	It is usually used as a delta to be added to a position to obtain some other position."

	| x y det a11 a12 a21 a22 detX detY |
	x _ aPoint x.
	y _ aPoint y.
	a11 _ self a11.
	a12 _ self a12.
	a21 _ self a21.
	a22 _ self a22.
	det _ (a11 * a22) - (a12 * a21).
	det = 0.0 ifTrue: [ ^`0@0` ].		"So we have at least a valid result"
	det _ 1.0 / det.
	detX _ (x * a22) - (a12 * y).
	detY _ (a11 * y) - (x * a21).
	^(detX * det) @ (detY * det)! !

!AffineTransformation methodsFor: 'converting coordinates' stamp: 'jmv 6/19/2017 15:43:16'!
            inverseTransform: aPoint
	"Apply the inverse transformation to aPoint, i.e. multiply our inverse by aPoint.
	Use Smalltalk code, and not Matrix2x3Plugin, because we want Float conversion."
	| x y det a11 a12 a21 a22 detX detY |

	x _ aPoint x - self a13.
	y _ aPoint y - self a23.
	a11 _ self a11.
	a12 _ self a12.
	a21 _ self a21.
	a22 _ self a22.
	det _ (a11 * a22) - (a12 * a21).
	det = 0.0 ifTrue: [ ^`0@0` ].		"So we have at least a valid result"
	det _ 1.0 / det.
	detX _ (x * a22) - (a12 * y).
	detY _ (a11 * y) - (x * a21).
	^(detX * det) @ (detY * det)! !

!AffineTransformation methodsFor: 'accessing' stamp: 'jmv 6/19/2017 15:43:25'!
                           inverseTransformation
	"Return the inverse transformation of the receiver.
	The inverse transformation is computed by first calculating
	the inverse offset and then computing transformations
	for the two identity vectors (1@0) and (0@1)"
	| r1 r2 r3 m |
	r3 _ self inverseTransform: `0@0`.
	r1 _ (self inverseTransform: `1@0`) - r3.
	r2 _ (self inverseTransform: `0@1`) - r3.
	m _ self species new.
	m
		a11: r1 x; a12: r2 x; a13: r3 x;
		a21: r1 y; a22: r2 y; a23: r3 y.
	^m! !

!AffineTransformation methodsFor: 'transforming rects' stamp: 'jmv 6/19/2017 15:43:02'!
        displayBoundsOfTransformOf: aRectangle
	"Externalize aRectangle, and find a bounding rectangle with horizontal 
		and vertical bounds and integer coordinates (i.e. adisplayBounds).
	Primitive rounds and answers integers.
	Warning: if answer from primitive is not strictly positive, it is off by one. Fix it here."

	| dstRect |
	dstRect _ Rectangle new.
	(self primDisplayBoundsOfTransformOf: aRectangle into: dstRect) ifNotNil: [
		dstRect topLeft > `0@0` ifTrue: [ ^dstRect  ]].
	^Rectangle encompassing: (aRectangle corners collect: [ :pt |
		(self transform: pt) rounded ])! !


ArrayedCollection variableSubclass: #Array
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Arrayed'!

!Array methodsFor: 'printing' stamp: 'pb 6/10/2017 01:39:04'!
    isLiteral
	"Definition from Squeak"
	^ self class == Array and: [
		self allSatisfy: [ :each |
			each isLiteral ]].! !

!Array methodsFor: 'private' stamp: 'jmv 1/13/2017 09:57:31'!
         replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !


Object subclass: #AutoCompleter
	instanceVariableNames: 'model textMorph menuMorph position entries prefix'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

!AutoCompleter methodsFor: 'keyboard' stamp: 'jmv 8/2/2017 12:47:30'!
                             handleKeystrokeBefore: kbEvent
	"I return a boolean. true when I have handled the event and no futher processing is needed by the caller."
	| currentPos currentCharIsAlphaNumeric keyValue ctrl cmd tab colon alphanum backspace esc space return keyChar  |
	currentPos _ textMorph editor startIndex-1.
	currentCharIsAlphaNumeric _ currentPos > 0 and: [ model textSize >= currentPos and: [
			(model actualContents at: currentPos) isAlphaNumeric ]].
	keyValue _ kbEvent keyValue.
	keyChar _ kbEvent keyCharacter.
	ctrl _ kbEvent controlKeyPressed.
	cmd _ kbEvent commandAltKeyPressed.
	tab _ keyChar = Character tab.
	colon _ keyChar = $:.
	alphanum _ kbEvent keyCharacter isAlphaNumeric.
	backspace _ keyValue = 8.
	esc _ keyValue = 27.
	space _ #(0 32 160) includes: keyValue.
	return _ kbEvent isReturnKey.

	"Stuff to do if the menu is not open"
	menuMorph ifNil: [
		"Ctrl-Space or Tab for open"
		"Mac specific note: Using option-space (actually option+160) effectively disables the non-breaking space character 160"
		(space & (ctrl | kbEvent rawMacOptionKeyPressed) or: [
			(self opensWithTab and: [tab]) and: [ currentCharIsAlphaNumeric ]])
				ifTrue: [ self openCompletionMenu. ^ true].
		"Auto-open - currently deactivated"
"		(ctrl not & cmd not & alphanum) 
			ifTrue: [ self openCompletionMenu ]."
		^ false].

	"Starting here, stuff to do if the menu is open"
	menuMorph stillActive.
	"Escape"
	esc ifTrue: [ self closeMenu. ^ true].
	"Backspace"
	backspace ifTrue: [
		currentCharIsAlphaNumeric ifFalse: [ self closeMenu ].
		^ false].
	"Home"
	keyValue = 1 ifTrue: [ menuMorph goHome. ^ true ].
	"End"
	keyValue = 4 ifTrue: [ menuMorph goToEnd. ^ true].
	"?"
	keyChar = $? ifTrue: [ menuMorph help. ^true].
	"Arrow up"
	keyValue = 30 ifTrue: [ menuMorph goUp. ^ true].
	"Arrow down"
	keyValue = 31 ifTrue: [ menuMorph goDown. ^ true].
	"Page up"
	keyValue = 11 ifTrue: [ menuMorph goPageUp. ^ true].
	"Page down"
	keyValue = 12 ifTrue: [ menuMorph goPageDown. ^ true].
	"Return, Tab or Ctrl-Space"
	(return or: [ space & (ctrl | kbEvent rawMacOptionKeyPressed) or: [ tab]]) ifTrue: [
		self insertSelected
			ifTrue: [^ true]].
	"All keys but the alphanumeric chars (without command and control ) 
	and the backspace key do close the menu"
	(ctrl not & cmd not and: [ alphanum | colon])
		ifFalse: [ self closeMenu ].
	^false! !


BorderedRectMorph subclass: #AutoCompleterMorph
	instanceVariableNames: 'completer selected firstVisible itemHeight lastActivity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 8/25/2017 13:00:40'!
                       goDown
	self selected = completer entryCount ifTrue: [
		"Wrap around"
		^ self goHome ].
	self selected: self selected + 1.
	(self selected > self lastVisible
			and: [self selected <= completer entryCount])
		ifTrue: [firstVisible := firstVisible + 1].
	self redrawNeeded! !

!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 8/2/2017 12:45:38'!
goHome
	firstVisible := 1.
	self selected: firstVisible. 
	self redrawNeeded! !

!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 8/2/2017 12:47:05'!
     goPageDown
	(self gotoPage: self currentPage + 1)
		ifFalse: [ self goToEnd ].
	self redrawNeeded! !

!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 8/2/2017 12:45:54'!
                goPageUp
	self gotoPage: self currentPage - 1.
	self redrawNeeded! !

!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 8/2/2017 12:45:32'!
                goToEnd
	self selected: completer entryCount.
	firstVisible := selected - self class itemsPerPage + 1 max: 1.
	self redrawNeeded! !

!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 8/25/2017 13:00:48'!
                goUp
	(self selected = 0
			and: [self firstVisible = 1])
		ifTrue: [^ self].
	self selected = 1 ifTrue: [
		"Wrap around"
		^self goToEnd ].
	self selected: self selected - 1.
	self selected < self firstVisible
		ifTrue: [firstVisible := firstVisible - 1].
	self redrawNeeded! !

!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:43:48'!
                            downButtonPosition
	^`0@0` + (extent - ScrollBar scrollbarThickness)! !

!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:43:54'!
            drawOn: aCanvas
	| rectangle w y0 h y1 y2 scrollbarThickness |
	aCanvas frameAndFillRectangle: (`0@0` extent: extent) fillColor: self color borderWidth: borderWidth borderColor: borderColor.
	y0 _ 1.
	w _ extent x-2.
	scrollbarThickness _ ScrollBar scrollbarThickness.
	completer entryCount > self class itemsPerPage  ifTrue: [
		w _ w - scrollbarThickness.
		aCanvas
			frameRectangle: (extent x - scrollbarThickness@0
				extent: scrollbarThickness @ extent y)
			borderWidth: 1
			color: borderColor.
		aCanvas
			image: (BitBltCanvas arrowOfDirection: #up size: scrollbarThickness)
			at: self upButtonPosition.
		aCanvas
			image: (BitBltCanvas arrowOfDirection: #down size: scrollbarThickness)
			at: self downButtonPosition.
		h _ extent y - (2 * scrollbarThickness).
		y1 _ (1.0 * self firstVisible-1 / completer entryCount * h) ceiling + y0 + scrollbarThickness-1.
		y2 _ (1.0 * self lastVisible / completer entryCount * h) floor + y0 + scrollbarThickness -1.
		aCanvas
			fillRectangle: (extent x - scrollbarThickness+2@y1 corner:  extent x-2 @ y2)
			color: Color veryLightGray ].
	self firstVisible
		to: self lastVisible
		do: [ :index |
			rectangle _ 1@y0 extent: w@self class itemHeight.
			index = self selected
				ifTrue: [
					aCanvas fillRectangle: rectangle color: (Theme current listHighlightFocused: true) ].
			aCanvas
				drawString: (completer entries at: index) asString
				at: rectangle topLeft
				font: self class listFont
				color: Theme current text.
			y0 _ y0 + self itemHeight ]! !

!AutoCompleterMorph methodsFor: 'events' stamp: 'jmv 8/2/2017 12:46:45'!
     mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	(self morphContainsPoint: localEventPosition)
		ifTrue: [
			((self upButtonPosition extent: ScrollBar scrollbarThickness) containsPoint: localEventPosition)
				ifTrue: [ ^self stillActive; goUp ].
			((self downButtonPosition extent: ScrollBar scrollbarThickness) containsPoint: localEventPosition)
				ifTrue: [ ^self stillActive; goDown ].
			self selected: (localEventPosition y // self class itemHeight) +  self firstVisible.
			completer insertSelected ]
		ifFalse: [ self delete. completer menuClosed ]! !

!AutoCompleterMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2011 10:09'!
         defaultBorderColor
	^ Color gray! !

!AutoCompleterMorph methodsFor: 'paging' stamp: 'jmv 8/2/2017 12:38:44'!
                  gotoPage: anInteger
	| item |
	item := ((anInteger - 1) * self class itemsPerPage) + 1. 
	item >= completer entryCount ifTrue: [^false].
	item < 1 ifTrue: [item := 1].
	firstVisible := item.
	self selected: firstVisible. 
	^ true! !


AutoCompleterMorph class
	instanceVariableNames: ''!

!AutoCompleterMorph class methodsFor: 'instance creation' stamp: 'jmv 6/19/2017 16:00:57'!
    initializedInstance
	| completer m |
	completer _ SmalltalkCompleter withModel: (TextModel withText: 'Small').
	completer
		instVarNamed: 'position'
		put: 5.
	completer computeEntries.
	m _ AutoCompleterMorph
		completer: completer
		position: `200 @ 200`.
	completer instVarNamed: 'menuMorph' put: m.
	^m! !


ImageReadWriter subclass: #BMPReadWriter
	instanceVariableNames: 'bfType bfSize bfOffBits biSize biWidth biHeight biPlanes biBitCount biCompression biSizeImage biXPelsPerMeter biYPelsPerMeter biClrUsed biClrImportant'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Files'!

!BMPReadWriter methodsFor: 'reading' stamp: 'ar 10/24/2005 20:57'!
                               readColorMap
	"Read colorCount BMP color map entries from the given binary stream. Answer an array of Colors."
	| colorCount colors maxLevel b g r ccStream |
	colorCount := (bfOffBits - 54) // 4.
	"Note: some programs (e.g. Photoshop 4.0) apparently do not set colorCount; assume that any data between the end of the header and the start of the pixel data is the color map"
	biBitCount >= 16 ifTrue:[^nil].
	colorCount = 0 ifTrue: [ "this BMP file does not have a color map"
		"default monochrome color map"
		biBitCount = 1 ifTrue: [^ Array with: Color white with: Color black].
		"default gray-scale color map"
		maxLevel := (2 raisedTo: biBitCount) - 1.
		^ (0 to: maxLevel) collect: [:level | Color gray: (level asFloat / maxLevel)]].
	ccStream := ReadStream on: (stream next: colorCount*4).
	colors := Array new: colorCount.
	1 to: colorCount do: [:i |
		b := ccStream next.
		g := ccStream next.
		r := ccStream next.
		ccStream next. "skip reserved"
		colors at: i put: (Color r: r g: g b: b range: 255)].
	^ colors
! !


Categorizer subclass: #BasicClassOrganizer
	instanceVariableNames: 'subject classComment commentStamp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Classes'!

!BasicClassOrganizer methodsFor: 'accessing' stamp: 'HAW 3/25/2017 10:48:00'!
                          classComment: aString 
	"Store the comment, aString, associated with the object that refers to the 
	receiver."

	aString ifNil: [ ^classComment _ nil ].
	
	aString isRemote
		ifTrue: [classComment _ aString]
		ifFalse: [aString size = 0
			ifTrue: [classComment _ nil]
			ifFalse: [
				self error: 'use aClass classComment:'.
				classComment _ RemoteString newString: aString onFileNumber: 2]]
				"Later add priorSource and date and initials?"! !


Object subclass: #Behavior
	instanceVariableNames: 'superclass methodDict format'
	classVariableNames: 'ObsoleteSubclasses'
	poolDictionaries: ''
	category: 'Kernel-Classes'!

!Behavior methodsFor: 'accessing class hierarchy' stamp: 'HAW 1/12/2017 18:29:00'!
                        allSuperclassesUpTo: aSuperclass
	
	| superclasses |
	
	^ superclass = aSuperclass
		ifTrue: [ OrderedCollection with: aSuperclass]
		ifFalse: [superclasses _ superclass allSuperclassesUpTo: aSuperclass.
			superclasses addFirst: superclass.
			superclasses]! !

!Behavior methodsFor: 'accessing class hierarchy' stamp: 'HAW 1/12/2017 18:30:53'!
      withAllSuperclassesUpTo: aSuperclass

	| classes |
	
	classes _ self allSuperclassesUpTo: aSuperclass.
	classes addFirst: self.
	
	^ classes! !

!Behavior methodsFor: 'user interface' stamp: 'HAW 6/2/2017 16:05:24'!
        addTo: aSet referencesTo: aSymbol special: special byte: byte.
	
	self withAllSuperAndSubclassesDoGently: [ :class |
		(class whichSelectorsReferTo: aSymbol special: special byte: byte)
			do: [ :sel | aSet add: (MethodReference class: class selector: sel) ]].
	! !

!Behavior methodsFor: 'user interface' stamp: 'HAW 6/2/2017 16:05:35'!
              allLocalCallsOn: aSymbol
	"Answer a SortedCollection of all the methods that call on aSymbol, anywhere in my class hierarchy."

	| aSet special byte cls |
	
	aSet _ Set new.
	cls _ self theNonMetaClass.
	special _ Smalltalk 
		hasSpecialSelector: aSymbol
		ifTrueSetByte: [ :b | byte _ b ].
	
	cls addTo: aSet referencesTo: aSymbol special: special byte: byte.
	cls class addTo: aSet referencesTo: aSymbol special: special byte: byte.
	
	^aSet! !

!Behavior methodsFor: 'system startup' stamp: 'jmv 1/6/2017 09:52:14'!
                         startUp
	"This message is sent to registered classes when the system is coming up, or after an image save."! !

!Behavior methodsFor: 'system startup' stamp: 'jmv 1/6/2017 09:53:18'!
         startUp: isARealStartup
	"This message is sent to registered classes, with isARealStartup = true when the system is coming up,
	and with isARealStartup = false after a snapshot (image save, no quit).
	Classes caring about the difference should reimplement this method."

	^ self startUp! !

!Behavior methodsFor: 'system-support' stamp: 'HAW 2/4/2017 20:51:10'!
                      allCallsOn
	"Answer a SortedCollection of all the methods that refer to me by name or 
	as part of an association in a global dict."
	"
	^ (Smalltalk
		allCallsOn: (Smalltalk associationAt: self theNonMetaClass name))
		, (Smalltalk allCallsOn: self theNonMetaClass name)
	"

	^ Smalltalk allCallsOn: self theNonMetaClass name! !

!Behavior methodsFor: 'tdd' stamp: 'HAW 2/7/2017 11:55:50'!
                         testCaseClass

	self subclassResponsibility ! !

!Behavior methodsFor: 'tdd' stamp: 'HAW 2/7/2017 11:55:40'!
                   withTestCaseClassDo: aFoundTestCaseClassBlock ifNone: aNoneBlock 
		
	| potentialTestCaseClass |
	
	potentialTestCaseClass _ self testCaseClass.
	
	^potentialTestCaseClass ifNil: aNoneBlock ifNotNil: aFoundTestCaseClassBlock 
	! !


Object subclass: #BitBlt
	instanceVariableNames: 'destForm sourceForm halftoneForm combinationRule destX destY width height sourceX sourceY clipX clipY clipWidth clipHeight colorMap'
	classVariableNames: 'CachedFontColorMaps ColorConvertingMaps'
	poolDictionaries: ''
	category: 'Graphics-Primitives'!

!BitBlt methodsFor: 'accessing' stamp: 'jmv 9/6/2017 20:40:02'!
        destX: x destY: y width: w height: h
	destX _ x.
	destY _ y.
	width _ w.
	height _ h.! !

!BitBlt methodsFor: 'accessing' stamp: 'jmv 3/20/2013 00:50'!
        fillColor
	"Return the current fill color as a Color.  
	 Gives the wrong answer if the halftoneForm is a complex pattern of more than one word."

	halftoneForm ifNil: [^ Color black].
	^ Color colorFromPixelValue: halftoneForm first depth: destForm depth! !


BitBlt class
	instanceVariableNames: ''!

!BitBlt class methodsFor: 'instance creation' stamp: 'jmv 6/19/2017 15:45:22'!
  bitPeekerFromForm: sourceForm
	"Answer an instance to be used extract individual pixels from the given Form. The destination for a 1x1 copyBits will be the low order bits of (bits at: 1)."
	| pixPerWord answer |
	pixPerWord _ sourceForm pixelsPerWord.
	answer _ self destForm: (Form extent: pixPerWord@1 depth: sourceForm depth)
	 	sourceForm: nil 			"To ensure no colormap set"
		combinationRule: Form over
		destOrigin: (pixPerWord - 1)@0
		sourceOrigin: `0@0`
		extent: `1@1`
		clipRect: (`0@0` extent: pixPerWord@1).
	"To ensure no colormap set"
	answer sourceForm: sourceForm.
	^ answer! !

!BitBlt class methodsFor: 'instance creation' stamp: 'jmv 6/19/2017 15:45:33'!
                             bitPokerToForm: destForm
	"Answer an instance to be used for valueAt: aPoint put: pixValue.
	The source for a 1x1 copyBits will be the low order of (bits at: 1)"
	| pixPerWord answer |
	pixPerWord _ 32//destForm depth.
	answer _ self destForm: destForm
	 	sourceForm: nil 		"To ensure no colormap set"
		combinationRule: Form over
		destOrigin: `0@0`
		sourceOrigin: (pixPerWord-1)@0
		extent: `1@1`
		clipRect: (`0@0` extent: destForm extent).
	"To ensure no colormap set"
	answer sourceForm: (Form extent: pixPerWord@1 depth: destForm depth).
	^ answer! !

!BitBlt class methodsFor: 'examples' stamp: 'jmv 7/27/2015 17:07'!
              alphaBlendDemo
	"To run this demo, use...
		Display restoreAfter: [BitBlt alphaBlendDemo]	
	Displays 10 alphas, then lets you paint.  Option-Click to stop painting."

	"This code exhibits alpha blending in any display depth by performing
	the blend in an off-screen buffer with 32-bit pixels, and then copying
	the result back onto the screen with an appropriate color map. - tk 3/10/97"
	
	"This version uses a sliding buffer for painting that keeps pixels in 32 bits
	as long as they are in the buffer, so as not to lose info by converting down
	to display resolution and back up to 32 bits at each operation. - di 3/15/97"

	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect updateRect |  

	"compute color maps if needed"
	Display depth <= 8 ifTrue: [
		mapDto32 _ Color cachedColormapFrom: Display depth to: 32.
		map32toD _ Color cachedColormapFrom: 32 to: Display depth].

	"display 10 different alphas, across top of screen"
	buff _ Form extent: 500@50 depth: 32.
	dispToBuff _ BitBlt toForm: buff.
	dispToBuff colorMap: mapDto32.
	dispToBuff copyFrom: (50@10 extent: 500@50) in: Display to: 0@0.
	1 to: 10 do: [:i | dispToBuff fill: (50*(i-1)@0 extent: 50@50)
						fillColor: (Color red alpha: i/10)
						rule: Form blend].
	buffToDisplay _ BitBlt toForm: Display.
	buffToDisplay colorMap: map32toD.
	buffToDisplay copyFrom: buff boundingBox in: buff to: 50@10.
	DisplayScreen screenUpdateRequired: nil.

	"Create a brush with radially varying alpha"
	brush _ Form extent: 30@30 depth: 32.
	1 to: 5 do: 
		[:i | brush fillShape: (Form dotOfSize: brush width*(6-i)//5)
				fillColor: (Color red alpha: 0.02 * i - 0.01)
				at: brush extent // 2].

	"Now paint with the brush using alpha blending."
	buffSize _ 100.
	buff _ Form extent: brush extent + buffSize depth: 32.  "Travelling 32-bit buffer"
	dispToBuff _ BitBlt toForm: buff.  "This is from Display to buff"
	dispToBuff colorMap: mapDto32.
	brushToBuff _ BitBlt toForm: buff.  "This is from brush to buff"
	brushToBuff sourceForm: brush; sourceOrigin: 0@0.
	brushToBuff combinationRule: Form blend.
	buffToBuff _ BitBlt toForm: buff.  "This is for slewing the buffer"

	[Sensor isMouseButton2Pressed] whileFalse:
		[prevP _ nil.
		buffRect _ Sensor mousePoint - (buffSize // 2) extent: buff extent.
		dispToBuff copyFrom: buffRect in: Display to: 0@0.
		[Sensor isMouseButton1Pressed] whileTrue:
			["Here is the painting loop"
			p _ Sensor mousePoint - (brush extent // 2).
			(prevP == nil or: [prevP ~= p]) ifTrue:
				[prevP == nil ifTrue: [prevP _ p].
				(p dist: prevP) > buffSize ifTrue:
					["Stroke too long to fit in buffer -- clip to buffer,
						and next time through will do more of it"
					theta _ (p-prevP) theta.
					p _ ((theta cos@theta sin) * buffSize asFloat + prevP) truncated].
				brushRect _ p extent: brush extent.
				(buffRect containsRect: brushRect) ifFalse:
					["Brush is out of buffer region.  Scroll the buffer,
						and fill vacated regions from the display"
					delta _ brushRect amountToTranslateWithin: buffRect.
					buffToBuff copyFrom: buff boundingBox in: buff to: delta.
					newBuffRect _ buffRect translatedBy: delta negated.
					newBuffRect
						areasOutside: buffRect
						do: [ :r | dispToBuff copyFrom: r in: Display to: r origin - newBuffRect origin ].
					buffRect _ newBuffRect].

				"Interpolate from prevP to p..."
				brushToBuff drawFrom: prevP - buffRect origin
									to: p - buffRect origin
									withFirstPoint: false.

				"Update (only) the altered pixels of the destination"
				updateRect _ (p min: prevP) corner: (p max: prevP) + brush extent.
				buffToDisplay copy: updateRect from: updateRect origin - buffRect origin in: buff.
				DisplayScreen screenUpdateRequired: updateRect.
				prevP _ p]]]! !


MorphicCanvas subclass: #BitBltCanvas
	instanceVariableNames: 'port'
	classVariableNames: 'AccessProtect AuxBlitter AuxForm CachedForms'
	poolDictionaries: ''
	category: 'Morphic-Support'!

!BitBltCanvas methodsFor: 'drawing-images' stamp: 'jmv 8/9/2017 11:37:34'!
                  image: aForm at: aPoint sourceRect: sourceRect
	"Draw a translucent image using the best available way of representing translucency.
	Note: This will be fixed in the future."
	| r p |
	p _ (currentTransformation transform: aPoint) rounded.
	r _ (self depth < 32 or: [ aForm mightBeTranslucent not ]) 
		ifTrue: [
			"Rule Form paint treats pixels with a value of zero as transparent"
			Form paint ]
		ifFalse: [ Form blend ].
	port colorMap: (aForm colormapIfNeededFor: form); fillColor: nil.
	port image: aForm at: p sourceRect: sourceRect rule: r.
	(self depth = 32 and: [ aForm depth < 32 ]) ifTrue: [
		"If we blit to 32bpp from one of smaller depth,
		it will have zero in the alpha channel (until BitBlt is fixed!!)
		This is the same workaround as in #asFormOfDepth:"
		port sourceForm: nil.
		port combinationRule: 40. "fixAlpha:with:"
		port copyBits ]! !

!BitBltCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 11/29/2015 18:01'!
               fillRectangle: aRectangle color: aColor
	"Fill the given rectangle."

	aColor isTransparent ifFalse: [
		self 
			frameAndFillRectangle: aRectangle
			fillColor: aColor
			borderWidth: 0
			borderColor: Color transparent ]! !

!BitBltCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 11/29/2015 18:14'!
               reverseRectangleBorder: r borderWidth: borderWidth
	"
	Display getCanvas
		reverseRectangleBorder: (10@10 extent: 300@200)
		borderWidth: 20.
	Display forceToScreen
	"
	| rect |
	rect _ currentTransformation displayBoundsOfTransformOf: r.
	port
		sourceForm: nil;
		fillColor: Color gray;
		combinationRule: Form reverse;
		frameRect: rect borderWidth: borderWidth! !

!BitBltCanvas methodsFor: 'private' stamp: 'jmv 6/19/2017 15:45:38'!
          fillRectangle: aRectangle tilingWith: aForm sourceRect: patternBox rule: aCombinationRule
	"aRectangle is in form coordinates, no transformation is done."
	| displayRectangle  additionalOffset clippedPort targetTopLeft clipOffset ex 
	targetBox savedMap top left |
	
	ex _ patternBox extent.
	ex x = 0 ifTrue: [ ^self ].
	ex y = 0 ifTrue: [ ^self ].
	displayRectangle _ currentTransformation displayBoundsOfTransformOf: aRectangle.

	"this is a bit of a kludge to get the form to be aligned where I *think* it should be.
	something better is needed, but not now"

	additionalOffset _ `0@0`.
	clippedPort _ port clippedBy: displayRectangle.
	targetTopLeft _ clippedPort clipRect topLeft truncateTo: ex.
	clipOffset _ displayRectangle topLeft - targetTopLeft.
	additionalOffset _ (clipOffset \\ ex) - ex.

	"do it iteratively"
	targetBox _ clippedPort clipRect.
	savedMap _ clippedPort colorMap.
	clippedPort sourceForm: aForm;
		fillColor: nil;
		combinationRule: aCombinationRule;
		sourceRect: patternBox;
		colorMap: (aForm colormapIfNeededFor: clippedPort destForm).
	top _ (targetBox top truncateTo: patternBox height) + additionalOffset y.
	left _  (targetBox left truncateTo: patternBox width) + additionalOffset x.

	left to: (targetBox right - 1) by: patternBox width do: [:x |
		top to: (targetBox bottom - 1) by: patternBox height do: [:y |
			clippedPort destOrigin: x@y; copyBits]].
	clippedPort colorMap: savedMap! !

!BitBltCanvas methodsFor: 'private' stamp: 'jmv 4/9/2015 09:46'!
        setPaintColor: aColor
	"Install a new color used for filling."
	| paintColor |
	paintColor _ aColor ifNil: [ Color transparent ].
	(paintColor is: #Color) ifFalse: [
		^self error: 'Cannot install color' ].

	"Okay, so paintColor really *is* a color"
	port sourceForm: nil.
	(paintColor isOpaque or: [ self depth < 32]) ifTrue: [
		port fillColor: paintColor.
		port combinationRule: Form paint.
		^self ].

	"BitBlt setup for alpha mapped transfer"
	port fillColor: paintColor.
	port combinationRule: Form blend! !


BitBltCanvas class
	instanceVariableNames: ''!

!BitBltCanvas class methodsFor: 'cached forms' stamp: 'jmv 6/19/2017 15:45:51'!
                          steButtonForm: extent
	^self cachedForms
		at: { #steButton . extent }
		ifAbsentPut: [
			| form canvas |
			form _ Form extent: extent depth: 32.
			canvas _ form getCanvas.
			canvas
				roundRect: (`0@0` extent: extent)
				color: (Color gray: 0.4)
				radius: 4.
			canvas
				roundRect: (`1@1` extent: extent-2)
				color: Color white
				radius: 4
				gradientTop: 1.0
				gradientCenter: 0.73
				gradientBottom: 0.94
				gradient1Height: (extent y-8+1 max: extent y//2).
			form]! !

!BitBltCanvas class methodsFor: 'cached forms' stamp: 'jmv 4/17/2015 12:16'!
      verticalGrayGradient: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	^self cachedForms
		at: { #vertical. height. gradientTopFactor . gradientBottomFactor }
		ifAbsentPut: [
			Form
				verticalGradient: height
				topColor: (Color gray: gradientTopFactor)
				bottomColor: (Color gray: gradientBottomFactor) ]! !

!BitBltCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 1/7/2015 08:12'!
                      buildArrowOfDirection: aSymbolDirection size: finalSizeInteger
	"PRIVATE - create an arrow with aSymbolDirectionDirection,  
	finalSizeInteger and aColor  
	 
	aSymbolDirectionDirection = #up, #down. #left or #right
	 (self buildArrowOfDirection: #down size: 120) display
	 (self buildArrowOfDirection: #up size: 120) display
	"

	| resizeFactor resizedForm f e c bottomMargin topMargin |
	resizeFactor _ 4.
	e _ finalSizeInteger@finalSizeInteger*resizeFactor.
	f _ Form extent: e depth: 32.
	c _ Color gray: 0.5.
	topMargin _ finalSizeInteger * 3//4.
	bottomMargin _ finalSizeInteger * 4//4.
	0 to: e y-1-bottomMargin do: [ :y |
		0 to: e x -1 do: [ :x |
			(e x / 2 - 1 - x) abs * 2 + topMargin < y ifTrue: [
				f colorAt: x@y put: c
			]
		]
	].
	resizedForm _ f
		magnify: f boundingBox
		by: 1 / resizeFactor
		smoothing: 4.

	aSymbolDirection == #right ifTrue: [
		resizedForm _ resizedForm rotatedByDegrees: 90 ].
	aSymbolDirection == #down ifTrue: [
		resizedForm _ resizedForm rotatedByDegrees: 180 ].
	aSymbolDirection == #left ifTrue: [
		resizedForm _ resizedForm rotatedByDegrees:  270 ].
		
	aSymbolDirection == #up ifFalse: [
		resizedForm _ resizedForm
			copy: (resizedForm boundingBox insetBy: (resizedForm width - finalSizeInteger/ 2.0) rounded) ].
		
	^resizedForm! !

!BitBltCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 6/19/2017 16:01:13'!
buildArrowWith: insideForm borderForm: borderForm
	| extent translucentForm color insideSpec borderSpec border background alpha|
	"
	Display getCanvas
		image: (BitBltCanvas buildArrowWith: BitBltCanvas downInsideForm borderForm: BitBltCanvas downBorderForm)
		at: 20@20
	Display getCanvas
		image: (BitBltCanvas buildArrowWith:BitBltCanvas upInsideForm borderForm: BitBltCanvas upBorderForm)
		at: 40@20
	"
	extent _ insideForm extent - `1@2`.
	translucentForm _ Form extent: insideForm extent depth: 32.
	0 to: extent x-1 do: [ :x |
		0 to: extent y-1 do: [ :y |
			insideSpec _ insideForm colorAt: x@(y+1).
			borderSpec _ borderForm colorAt: x@(y+1).
			insideSpec = (Color r: 0.0 g: 0.0 b: 1.0)
				ifTrue: [ color _ Color transparent ]
				ifFalse: [
					borderSpec = (Color r: 1.0 g: 0.0 b: 0.0)
						ifTrue: [ color _ insideSpec ]
						ifFalse: [
							border _ x < (extent x//2)
								ifTrue: [Color white]
								ifFalse: [Color black].
							background _ borderForm colorAt: extent x@(y+1).
							alpha _ borderSpec red asFloat - background red / (border red - background red).
							color _ border alpha: (alpha min: 1 max: 0) ]].
			translucentForm colorAt: x@y put: color ]].
	^translucentForm! !


ArrayedCollection variableWordSubclass: #Bitmap
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Primitives'!

!Bitmap methodsFor: 'accessing' stamp: 'jmv 5/31/2017 10:16:34'!
                            bytesAt: index
	"Answer a ByteArray of 4 elements.
	The 32-bit word is split in 4 bytes, in little endian format
	WordArray with: 16rFF32791B :: bytesAt: 1 :: hex
	"

	| bytes word |
	bytes _ ByteArray new: 4.
	word _ self at: index. "Usually a SmallInteger, but may be a Large Integer in 32-bit images"
	1 to: 4 do: [ :i | bytes at: i put: (word digitAt: i) ].
	^ bytes! !

!Bitmap methodsFor: 'accessing' stamp: 'jmv 5/31/2017 10:16:38'!
        bytesAt: index put: aByteArray
	"Takes a ByteArray of 4 elements.
	Store the 32-bit word made with those byes, in little endian format
	WordArray new: 1 :: bytesAt: 1 put: #[16r1B 16r79 16r32 16rFF] :: first hex
	"

	| word |
	word _ 0.
	4 to: 1 by: -1 do: [ :i | word _ word * 256 + (aByteArray at: i) ].
	self at: index put: word! !

!Bitmap methodsFor: 'accessing' stamp: 'jmv 1/13/2017 09:57:27'!
               replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !

!Bitmap methodsFor: 'as yet unclassified' stamp: 'jmv 6/19/2017 15:45:57'!
                       asByteArray
	"Faster way to make a byte array from me.
	copyFromByteArray:, if receiver is BigEndian makes equal Bitmap.
	Assume receiver bytes-in-word mapping is BigEndian:
		Most significant bye of first word in self goes to first position in result.
	This means that for a BigEndian 8bpp Form, pixels are in the right order in the ByteArray
	
	Form lena asGrayForm bits asByteArray copyFrom: 1 to: 4.
	(Form lena asGrayForm asFormOfDepth: 8) bits asByteArray copyFrom: 1 to: 4.
	(0 to: 3) collect: [ :x | ((Form lena asGrayForm colorAt: x@0) luminance * 255) rounded ].
	"
	| f bytes hack |
	f _ Form extent: 4@self size depth: 8 bits: self.
	bytes _ ByteArray new: self size * 4.
	hack _ Form new hackBits: bytes.
	Smalltalk isLittleEndian ifTrue: [hack swapEndianness].
	hack copyBits: f boundingBox
		from: f
		at: `0@0`
		clippingBox: hack boundingBox
		rule: Form over.

	"f displayOn: hack."
	^ bytes! !


Object variableSubclass: #BlockClosure
	instanceVariableNames: 'outerContext startpc numArgs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Methods'!

!BlockClosure methodsFor: 'evaluating' stamp: 'jmv 9/19/2017 22:16:51'!
                           bench
	"See how many times I can value in 5 seconds.  I'll answer a meaningful description.
	[ Float pi printString ] bench print.
	[ 80000 factorial printString ] bench print.
	"

	| startTime endTime count run |
	count _ 0.
	run _ true.
	[ (Delay forSeconds: 5) wait. run _ false ] forkAt: Processor timingPriority - 1.
	startTime _ Time localMillisecondClock.
	[ run ] whileTrue: [ self value. count _ count + 1 ].
	endTime _ Time localMillisecondClock.
	count = 1
		ifTrue: [
			(endTime - startTime) / 1000 withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
				^String streamContents: [ :strm |
					value printOn: strm fractionDigits: 2.
					strm
						space;
						nextPutAll: unitPrefixSymbol;
						nextPutAll: ' seconds per run']]
			]
		ifFalse: [
			(count * 1000) / (endTime - startTime) withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
				^String streamContents: [ :strm |
					value printOn: strm fractionDigits: 2.
					strm
						space;
						nextPutAll: unitPrefixSymbol;
						nextPutAll: ' runs per second' ]]
			]! !

!BlockClosure methodsFor: 'error handing' stamp: 'HAW 3/29/2017 15:16:01'!
             handles: anException

	"This allows a block to be the handling condition of an exception handling.
	See Exception class>>handles:"
	
	^self value: anException ! !


RectangleLikeMorph subclass: #BorderedRectMorph
	instanceVariableNames: 'borderWidth borderColor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

!BorderedRectMorph methodsFor: 'initialization' stamp: 'jmv 8/17/2014 21:28'!
                               defaultBorderColor
	"answer the default border color/fill style for the receiver"
	^ Color gray! !


ParseNode subclass: #BraceNode
	instanceVariableNames: 'elements sourceLocations emitNode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-ParseNodes'!

!BraceNode methodsFor: 'printing' stamp: 'pb 9/9/2017 03:05:21'!
              printOn: aStream indent: level
	| isComplex useLevel |
	useLevel := level.
	isComplex := elements anySatisfy: [ :ea |
		ea isComplex ].
	isComplex ifTrue: [ useLevel := useLevel + 1 ].
	aStream nextPut: ${.
	1
		to: elements size
		do: [ :i |
			isComplex ifTrue: [ aStream newLineTab: (1 max: useLevel) ].
			(elements at: i)
				printOn: aStream
				indent: useLevel.
			i < elements size ifTrue: [ aStream nextPutAll: '. ' ]].
	isComplex ifTrue: [ aStream newLineTab: (1 max: level) ].
	aStream nextPut: $}.! !

!BraceNode methodsFor: 'as yet unclassified' stamp: 'pb 9/9/2017 03:05:08'!
                 isComplex
	^ true.! !


CodeProvider subclass: #Browser
	instanceVariableNames: 'systemOrganizer classOrganizer metaClassOrganizer selectedSystemCategory selectedClassName selectedMessageCategory selectedMessage editSelection metaClassIndicated'
	classVariableNames: 'RecentClasses'
	poolDictionaries: ''
	category: 'Tools-Browser'!

!Browser methodsFor: 'class comment pane' stamp: 'pb 6/18/2017 05:34:23'!
        newClassComment: aText
	"The user has just entered aText.
	It may be all red (a side-effect of replacing the default comment), so remove the color if it is."
	| theClass |
	theClass _ self selectedClassOrMetaClass theNonMetaClass.
	theClass ifNotNil: [
		theClass classComment: aText asString ].
	self changed: #classCommentText.
	^ true! !

!Browser methodsFor: 'shout styling' stamp: 'jmv 8/26/2017 19:21:20'!
    shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Set the classOrMetaClass in anSHTextStyler, so that identifiers
	will be resolved correctly.
	Answer true to allow styling to proceed, or false to veto the styling"
	| type |
	
	self isModeStyleable ifFalse: [^false].
	type _ self editSelection.
	(#(newMessage editMessage editClass newClass) includes: type) ifFalse:[^false].
	anSHTextStyler classOrMetaClass: (type = #editClass ifFalse:[self selectedClassOrMetaClass]).
	^true! !

!Browser methodsFor: 'tdd' stamp: 'HAW 3/3/2017 19:12:25'!
debugMethodTest
	
	currentCompiledMethod isTestMethod ifTrue: [
		currentCompiledMethod methodClass debugAsFailure: currentCompiledMethod selector ifCanNot: [ PopUpMenu inform: TestCase canNotDebugMethodErrorDescription ]]
! !

!Browser methodsFor: 'tdd' stamp: 'HAW 2/4/2017 20:33:00'!
 runClassTests
	
	self selectedClassName ifNotNil: [ :aClassName | | selectedClass |
		selectedClass _ Smalltalk classNamed: aClassName.
		(ProgessiveTestRunner for: (TestSuite forClass: selectedClass)) value ]! !

!Browser methodsFor: 'tdd' stamp: 'HAW 2/7/2017 10:47:50'!
               runMessageCategoryTests
	
	selectedMessageCategory ifNotNil: [ | selectedClass suite |
		selectedClass _ Smalltalk classNamed: selectedClassName.
		suite _ TestSuite forMessageCategoryNamed: selectedMessageCategory of: selectedClass categorizedWith: classOrganizer.
		(ProgessiveTestRunner for: suite) value ]
	
	! !

!Browser methodsFor: 'tdd' stamp: 'HAW 2/4/2017 21:51:50'!
       runMethodTest
	
	| suite |
	
	suite _ TestSuite forCompiledMethod: currentCompiledMethod.
	(ProgessiveTestRunner for: suite) value 
	! !

!Browser methodsFor: 'tdd' stamp: 'HAW 2/1/2017 19:23:54'!
                           runSystemCategoryTests
	
	selectedSystemCategory ifNotNil: [ | suite |
		suite _ TestSuite forSystemCategoryNamed: selectedSystemCategory using: systemOrganizer.
		(ProgessiveTestRunner for: suite) value ]
	
	! !


CodeWindow subclass: #BrowserWindow
	instanceVariableNames: 'codePane'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!

!BrowserWindow methodsFor: 'GUI building' stamp: 'HAW 8/28/2017 13:39:41'!
            buildMorphicCodePane
	"Construct the pane that shows the code.
	Respect the Preference for standardCodeFont."

	codePane _ super buildMorphicCodePane.
	^codePane! !

!BrowserWindow methodsFor: 'menu building' stamp: 'HAW 1/31/2017 11:32:21'!
              classListMenu
	"Set up the menu to apply to the receiver's class list, honoring the #shifted boolean"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addList: #(
		('browse full (b)'			browseMethodFull)
		('browse hierarchy (h)'		browseHierarchy)
		('browse protocol (p)'		browseFullProtocol)
		-
		('fileOut'					fileOutClass				''		model)
		-
		('show hierarchy'			hierarchy					''		model)
		('show definition'			editClass					''		model)
		('show comment'			editComment			''		model)
		-
		('inst var refs...'				browseInstVarRefs)
		('inst var defs...'			browseInstVarDefs)
		-
		('class var refs...'			browseClassVarRefs)
		('class vars'					browseClassVariables)
		('class refs (N)'				browseClassRefs)
		-
		('rename class ...'			renameClass				''		model)
		('copy class...'				copyClass				''		model)
		('remove class (x)'			removeClass				''		model)
		-
		('Run tests (t)'		runClassTests 	''	model)
		('more...'					offerShiftedClassListMenu)).
	^ aMenu! !

!BrowserWindow methodsFor: 'menu building' stamp: 'HAW 1/31/2017 19:57:02'!
messageCategoryMenu

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: model.			"All the options are for the model."
	aMenu addList: #(
		('fileOut'							fileOutMessageCategories)
		-
		('reorganize'						editMessageCategories)
		('alphabetize'						alphabetizeMessageCategories)
		('remove empty categories'		removeEmptyCategories)
		('categorize all uncategorized'		categorizeAllUncategorizedMethods)
		('new category...'					addCategory)
		-
		('rename...'							renameCategory)
		('remove'							removeMessageCategory)
		-
		('Run tests'	runMessageCategoryTests)).
	^aMenu! !

!BrowserWindow methodsFor: 'menu building' stamp: 'jmv 6/5/2017 11:46:27'!
                messageListMenu
	"Answer the message-list menu"
	"Changed by emm to include menu-item for breakpoints"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addList:#(
			('what to show...'					offerWhatToShowMenu)
                	('toggle break on entry'		toggleBreakOnEntry						''		model)
            	-
			('browse full (b)' 					browseMethodFull)
			('browse hierarchy (h)'			browseHierarchy)
			('browse method (O)'			openSingleMessageBrowser)
			('browse protocol (p)'			browseFullProtocol)
			-
			('fileOut'							fileOutMessage							''		model)
			('explore CompiledMethod'		exploreCompiledMethod				''		model)
			-
			('senders of... (n)'				browseSendersOfMessages)
			('implementors of... (m)'		browseMessages)
			('inheritance (i)'					methodHierarchy)
			('versions (v)'						browseVersions)
			-
			('inst var refs...'					browseInstVarRefs)
			('inst var defs...'					browseInstVarDefs)
			('class var refs...'				browseClassVarRefs)
			('class variables'					browseClassVariables)
			('class refs (N)'					browseClassRefs)
			-
			('remove method (x)'			removeMessage							''		model)
			('Run test (t)'						runMethodTest 							'' 	model)
			('Debug test (r)'					debugMethodTest 						'' 	model)
			-
			('more...'							openShiftedMessageListMenu)).
	^ aMenu
! !

!BrowserWindow methodsFor: 'menu building' stamp: 'HAW 1/31/2017 11:52:17'!
    systemCategoryMenu

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	self flag: #renameSystemCategory.	"temporarily disabled"
	aMenu addList: #(
		('find class... (f)'				findClass)
		('recent classes... (r)'		recent									''		model)
		-
		('browse all'				browseAllClasses)
		('browse'					openSystemCategoryBrowser)
		-
		('fileOut'					fileOutSystemCategory				''		model)
		-
		('reorganize'				editSystemCategories					''		model)
		('alphabetize'				alphabetizeSystemCategories		''		model)
		-
		('update'					updateSystemCategories				''		model)
		('add item...'				addSystemCategory					''		model)
"		('rename...'					renameSystemCategory				''		model)"
		('remove'					removeSystemCategory				''		model)
		-
		('move to top'				moveSystemCategoryTop				''		model)
		('move up'					moveSystemCategoryUp				''		model)
		('move down'				moveSystemCategoryDown			''		model)
		('move to bottom' 			moveSystemCategoryBottom			''		model)
		-
		('Run tests (t)'				runSystemCategoryTests  	''	model)).
	^aMenu! !

!BrowserWindow methodsFor: 'updating' stamp: 'jmv 9/6/2017 10:04:36'!
                            disableCodePaneEditing

	codePane ifNotNil: [ codePane disableEditing ]! !

!BrowserWindow methodsFor: 'updating' stamp: 'jmv 9/6/2017 10:04:55'!
              editSelectionChanged
	
	self isEditSelectionNone
		ifTrue: [ self disableCodePaneEditing ]
		ifFalse: [ self enableCodePaneEditing]! !

!BrowserWindow methodsFor: 'updating' stamp: 'jmv 9/6/2017 10:04:48'!
                  enableCodePaneEditing

	codePane ifNotNil: [ codePane enableEditing ]! !

!BrowserWindow methodsFor: 'updating' stamp: 'HAW 8/28/2017 13:43:44'!
               isEditSelectionNone
		
	^ model editSelection = #none! !

!BrowserWindow methodsFor: 'updating' stamp: 'HAW 8/28/2017 13:41:51'!
                               update: anEvent
	super update: anEvent.
	anEvent = #editSelection ifTrue: [self editSelectionChanged ] ! !


ArrayedCollection variableByteSubclass: #ByteArray
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Arrayed'!

!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/27/2015 23:01'!
  long64At: index bigEndian: bigEndian
	"Return a 64-bit signed integer quantity starting from the given byte index."

	| value |
	value := self unsignedLong64At: index bigEndian: bigEndian.
	value digitLength < 8 ifTrue: [ ^value ].
	(value digitAt: 8) < 16r80 ifTrue: [ ^value ].
	^value - 16r10000000000000000! !

!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/27/2015 22:57'!
                   long64At: index put: value bigEndian: bigEndian
	"Store a 64-bit signed integer quantity starting from the given byte index."
	
	^self
		unsignedLong64At: index
		put: (value negative
			ifFalse: [ value ]
			ifTrue: [ value + 16r10000000000000000 ])
		bigEndian: bigEndian! !

!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/9/2015 20:28'!
                         longAt: index bigEndian: bigEndian
	"Return a 32-bit integer quantity starting from the given byte index. Use #normalize where necessary to ensure compatibility with non-30-bit SmallIntegers."
	
	| byte result |
	bigEndian ifFalse: [
		(byte := self at: index + 3) <= 16r7F ifTrue: [ "Is the result non-negative?"
			byte <= 16r3F ifTrue: [
				^(((byte bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index) ].
			^(LargePositiveInteger new: 4)
				replaceFrom: 1
					to: 4
					with: self
					startingAt: index;
				normalize ].
		"Negative"
		byte >= 16rC0 ifTrue: [
			^-1 - (((((byte bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 1) bitXor: 16rFFFFFF) bitShift: 8) + ((self at: index) bitXor: 16rFF)) ].
		(result := LargeNegativeInteger new: 4)
			digitAt: 4 put: ((self at: index + 3) bitXor: 16rFF);
			digitAt: 3 put: ((self at: index + 2) bitXor: 16rFF);
			digitAt: 2 put: ((self at: index + 1) bitXor: 16rFF).
		(byte := ((self at: index) bitXor: 16rFF) + 1) <= 16rFF ifTrue: [
			^result
				digitAt: 1 put: byte;
				normalize ].
		^result
			digitAt: 1 put: 16rFF;
			- 1 "It's tempting to do the subtraction in a loop to avoid the LargeInteger creation, but it's actually slower than this." ].
	(byte := self at: index) <= 16r7F ifTrue: [ "Is the result non-negative?"
		byte <= 16r3F ifTrue: [
			^(((byte bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 3) ].
		^(LargePositiveInteger new: 4)
			digitAt: 1 put: (self at: index + 3);
			digitAt: 2 put: (self at: index + 2);
			digitAt: 3 put: (self at: index + 1);
			digitAt: 4 put: byte;
			normalize ].
	"Negative"
	16rC0 <= byte ifTrue: [
		^-1 - (((((byte bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index + 2) bitXor: 16rFFFFFF) bitShift: 8) + ((self at: index + 3) bitXor: 16rFF)) ].
	(result := LargeNegativeInteger new: 4)
		digitAt: 4 put: (byte bitXor: 16rFF);
		digitAt: 3 put: ((self at: index + 1) bitXor: 16rFF);
		digitAt: 2 put: ((self at: index + 2) bitXor: 16rFF).
	(byte := ((self at: index + 3) bitXor: 16rFF) + 1) <= 16rFF ifTrue: [
		^result
			digitAt: 1 put: byte;
			normalize ].
	^result 
		digitAt: 1 put: 16rFF;
		- 1 "It's tempting to do the subtraction in a loop to avoid the LargeInteger creation, but it's actually slower than this."! !

!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/6/2015 17:13'!
                            longAt: index put: value bigEndian: bigEndian
	"Store a 32-bit signed integer quantity starting from the given byte index"
	
	| v v2 |
	value isLarge ifTrue: [
		bigEndian ifFalse: [
			value positive ifTrue: [
				self 
					replaceFrom: index
					to: index + 3
					with: value
					startingAt: 1.
				^value ].
			v := 0.
			[ v <= 3 and: [ (v2 := ((value digitAt: v + 1) bitXor: 16rFF) + 1) = 16r100 ] ] whileTrue: [
				self at: index + v put: 0.
				v := v + 1 ].
			self at: index + v put: v2.
			v := v + 1.
			[ v <= 3 ] whileTrue: [
				self at: index + v put: ((value digitAt: (v := v + 1)) bitXor: 16rFF) ].
			^value ].
		value positive ifTrue: [
			self
				at: index put: (value digitAt: 4);
				at: index + 1 put: (value digitAt: 3);
				at: index + 2 put: (value digitAt: 2);
				at: index + 3 put: (value digitAt: 1).
			^value ].
		v := 3.
		[ 0 <= v and: [ (v2 := ((value digitAt: 4 - v) bitXor: 16rFF) + 1) = 16r100 ] ] whileTrue: [
			self at: index + v put: 0.
			v := v - 1 ].
		self at: index + v put: v2.
		[ 0 <= (v := v - 1) ] whileTrue: [
			self at: index + v put: ((value digitAt: 4 - v) bitXor: 16rFF) ].
		^value ].
	v := value bitShift: -24.
	0 <= (v := (v bitAnd: 16r7F) - (v bitAnd: 16r80)) ifFalse: [
		v := v + 16r100 ].
	bigEndian ifFalse: [
		self 
			at: index put: (value bitAnd: 16rFF);
			at: index + 1 put: ((value bitShift: -8) bitAnd: 16rFF);
			at: index + 2 put: ((value bitShift: -16) bitAnd: 16rFF);
			at: index + 3 put: v.
		^value ].
	self
		at: index put: v;
		at: index + 1 put: ((value bitShift: -16) bitAnd: 16rFF);
		at: index + 2 put: ((value bitShift: -8) bitAnd: 16rFF);
		at: index + 3 put: (value bitAnd: 16rFF).
	^value! !

!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/6/2015 23:16'!
                     shortAt: index bigEndian: bigEndian
	"Return a 16-bit signed integer quantity starting from the given byte index"

	| result |
	result := bigEndian
		ifFalse: [ ((self at: index + 1) bitShift: 8) + (self at: index) ]
		ifTrue: [ ((self at: index) bitShift: 8) + (self at: index + 1) ].
	result < 16r8000 ifTrue: [ ^result ].
	^result - 16r10000! !

!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/6/2015 23:16'!
                  shortAt: index put: value bigEndian: bigEndian
	"Store a 16-bit signed integer quantity starting from the given byte index"
	
	| unsignedValue |
	(unsignedValue := value) < 0 ifTrue: [
		unsignedValue := unsignedValue + 16r10000 ].
	bigEndian ifFalse: [
		self 
			at: index + 1 put: (unsignedValue bitShift: -8);
			at: index put: (unsignedValue bitAnd: 16rFF).
		^value ].
	self
		at: index put: (unsignedValue bitShift: -8);
		at: index + 1 put: (unsignedValue bitAnd: 16rFF).
	^value! !

!ByteArray methodsFor: 'platform independent access' stamp: 'eem 2/22/2016 09:36'!
 unsignedLong64At: index bigEndian: bigEndian
	"Return a 64-bit unsigned integer quantity starting from the given byte index. Use #normalize where necessary to ensure compatibility with non-30-bit SmallIntegers."

	| byte |
	SmallInteger maxVal >  1073741823 ifTrue:
		[bigEndian
			ifTrue: "64-bit SmallIntegers have a 3 bit tag and a sign bit, so the most positive value has 16rF as its top byte."
				[(byte := self at: index) <= 16rF ifTrue:
					[^((((((((byte bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 3)) bitShift: 8)
						+ (self at: index + 4) bitShift: 8) + (self at: index + 5) bitShift: 8) + (self at: index + 6) bitShift: 8) + (self at: index + 7)]]
			ifFalse:
				[(byte := self at: index + 7) <= 16rF ifTrue:
					[^((((((((byte bitShift: 8) + (self at: index + 6) bitShift: 8) + (self at: index + 5) bitShift: 8) + (self at: index + 4)) bitShift: 8)
						+ (self at: index + 3) bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index)]]].
	bigEndian ifFalse: [
		(byte := self at: index + 7) = 0 ifFalse: [
			^(LargePositiveInteger new: 8)
				replaceFrom: 1 to: 8 with: self startingAt: index;
				normalize ].
		(byte := self at: index + 6) = 0 ifFalse: [
			^(LargePositiveInteger new: 7)
				replaceFrom: 1 to: 7 with: self startingAt: index;
				normalize ].
		(byte := self at: index + 5) = 0 ifFalse: [
			^(LargePositiveInteger new: 6)
				replaceFrom: 1 to: 6 with: self startingAt: index;
				normalize ].
		(byte := self at: index + 4) = 0 ifFalse: [
			^(LargePositiveInteger new: 5)
				replaceFrom: 1 to: 5 with: self startingAt: index;
				normalize ].
		(byte := self at: index + 3) <= 16r3F ifFalse: [
			^(LargePositiveInteger new: 4)
				replaceFrom: 1 to: 4 with: self startingAt: index;
				normalize ].
		^(((byte bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index) ].
	(byte := self at: index) = 0 ifFalse: [
		^(LargePositiveInteger new: 8)
			digitAt: 1 put: (self at: index + 7);
			digitAt: 2 put: (self at: index + 6);
			digitAt: 3 put: (self at: index + 5);
			digitAt: 4 put: (self at: index + 4);
			digitAt: 5 put: (self at: index + 3);
			digitAt: 6 put: (self at: index + 2);
			digitAt: 7 put: (self at: index + 1);
			digitAt: 8 put: byte;
			normalize ].
	(byte := self at: index + 1) = 0 ifFalse: [	
		^(LargePositiveInteger new: 7)
			digitAt: 1 put: (self at: index + 7);
			digitAt: 2 put: (self at: index + 6);
			digitAt: 3 put: (self at: index + 5);
			digitAt: 4 put: (self at: index + 4);
			digitAt: 5 put: (self at: index + 3);
			digitAt: 6 put: (self at: index + 2);
			digitAt: 7 put: byte;
			normalize ].
	(byte := self at: index + 2) = 0 ifFalse: [	
		^(LargePositiveInteger new: 6)
			digitAt: 1 put: (self at: index + 7);
			digitAt: 2 put: (self at: index + 6);
			digitAt: 3 put: (self at: index + 5);
			digitAt: 4 put: (self at: index + 4);
			digitAt: 5 put: (self at: index + 3);
			digitAt: 6 put: byte;
			normalize ].
	(byte := self at: index + 3) = 0 ifFalse: [	
		^(LargePositiveInteger new: 5)
			digitAt: 1 put: (self at: index + 7);
			digitAt: 2 put: (self at: index + 6);
			digitAt: 3 put: (self at: index + 5);
			digitAt: 4 put: (self at: index + 4);
			digitAt: 5 put: byte;
			normalize ].		
	(byte := self at: index + 4) <= 16r3F ifFalse: [
		^(LargePositiveInteger new: 4)
			digitAt: 1 put: (self at: index + 7);
			digitAt: 2 put: (self at: index + 6);
			digitAt: 3 put: (self at: index + 5);
			digitAt: 4 put: byte;
			normalize ].
	^(((byte bitShift: 8) + (self at: index + 5) bitShift: 8) + (self at: index + 6) bitShift: 8) + (self at: index + 7)! !

!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/9/2015 20:18'!
       unsignedLong64At: index put: value bigEndian: bigEndian
	"Store a 64-bit unsigned integer quantity starting from the given byte index"
	
	| i j |
	value isLarge ifTrue: [
		i := value digitLength.
		bigEndian ifFalse: [
			self
				replaceFrom: index
					to: index + i - 1
					with: value 
					startingAt: 1;
				replaceFrom: index + i
					to: index + 7
					with: #[0 0 0 0 0 0 0 0]
					startingAt: 1.
			^value ].
		j := index + 8.
		i <= 7 ifTrue: [
			self
				replaceFrom: index
				to: j - i - 1
				with: #[0 0 0 0 0 0 0 0]
				startingAt: 1 ].
		[ 1 <= i ] whileTrue: [
			self at: j - i put: (value digitAt: i).
			i := i - 1 ].
		^value ].
	bigEndian ifFalse: [
		j := index - 1.
		i := value.
		[ 1 <= i ] whileTrue: [
			self at: (j := j + 1) put: (i bitAnd: 16rFF).
			i := i bitShift: -8 ].
		self replaceFrom: j + 1
			to: index + 7
			with: #[0 0 0 0 0 0 0 0]
			startingAt: 1.
		^value ].
	j := index + 8.
	i := value.
	[ 1 <= i ] whileTrue: [
		self at: (j := j - 1) put: (i bitAnd: 16rFF).
		i := i bitShift: -8 ].
	self replaceFrom: index
		to: j - 1
		with: #[0 0 0 0 0 0 0 0]
		startingAt: 1.
	^value! !

!ByteArray methodsFor: 'platform independent access' stamp: 'eem 2/22/2016 09:20'!
 unsignedLongAt: index bigEndian: bigEndian
	"Return a 32-bit unsigned integer quantity starting from the given byte index. Use #normalize where necessary to ensure compatibility with non-30-bit SmallIntegers."
	| byte |
	bigEndian ifTrue:
		[((byte := self at: index) <= 16r3F
		 or: [SmallInteger maxVal >  1073741823]) ifTrue:
			[^(((byte bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 3)].
		^(LargePositiveInteger new: 4)
			digitAt: 1 put: (self at: index + 3);
			digitAt: 2 put: (self at: index + 2);
			digitAt: 3 put: (self at: index + 1);
			digitAt: 4 put: byte;
			normalize].
	((byte := self at: index + 3) <= 16r3F
	 or: [SmallInteger maxVal >  1073741823]) ifTrue:
		[^(((byte bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index)].
	^(LargePositiveInteger new: 4)
		replaceFrom: 1 to: 4 with: self startingAt: index;
		normalize! !

!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/3/2015 01:33'!
                 unsignedLongAt: index put: value bigEndian: bigEndian
	"Store a 32-bit unsigned integer quantity starting from the given byte index"
	
	value isLarge
		ifTrue: [
			bigEndian ifFalse: [
				self
					replaceFrom: index
					to: index + 3
					with: value
					startingAt: 1.
				^value ].
			self
				at: index put: (value digitAt: 4);
				at: index + 1 put: (value digitAt: 3);
				at: index + 2 put: (value digitAt: 2);
				at: index +3 put: (value digitAt: 1) ]
		ifFalse: [
			bigEndian ifFalse: [
				self 
					at: index put: (value bitAnd: 16rFF);
					at: index + 1 put: ((value bitShift: -8) bitAnd: 16rFF);
					at: index + 2 put: ((value bitShift: -16) bitAnd: 16rFF);
					at: index + 3 put: (value bitShift: -24).
				^value ].
			self 
				at: index put: (value bitShift: -24);
				at: index + 1 put: ((value bitShift: -16) bitAnd: 16rFF);
				at: index + 2 put: ((value bitShift: -8) bitAnd: 16rFF);
				at: index + 3 put: (value bitAnd: 16rFF) ].
	^value! !

!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/3/2015 01:33'!
unsignedShortAt: index bigEndian: bigEndian
	"Return a 16-bit unsigned integer quantity starting from the given byte index"

	bigEndian ifFalse: [ ^((self at: index + 1) bitShift: 8) + (self at: index) ].
	^((self at: index) bitShift: 8) + (self at: index + 1)
	! !

!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/3/2015 15:29'!
    unsignedShortAt: index put: value bigEndian: bigEndian
	"Store a 16-bit unsigned integer quantity starting from the given byte index"
	
	bigEndian ifFalse: [
		self 
			at: index + 1 put: (value bitShift: -8);
			at: index put: (value bitAnd: 16rFF).
		^value ].
	self
		at: index put: (value bitShift: -8);
		at: index+1 put: (value bitAnd: 16rFF).
	^value! !

!ByteArray methodsFor: 'private' stamp: 'jmv 1/13/2017 09:57:38'!
                    replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !

!ByteArray methodsFor: 'printing' stamp: 'jmv 7/11/2017 14:09:10'!
                               printOn: aStream
	self storeOn: aStream! !


CNGKillVm class
	instanceVariableNames: ''!

!CNGKillVm class methodsFor: 'as yet unclassified' stamp: 'pb 10/11/2017 01:02:32'!
                  boom
	| generateLotsOfGarbage max end start |
	start := DateAndTime now.
	max _ 60000.
	generateLotsOfGarbage _ (1 to: max) collect: [ :ea |
		CNGResourceGobblingParser
			debugMatchAll: '1,2,3
4,5,6
7,8,9,10,
it was the best of times,it was the worst of times
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
something,something else,yet again another thing
aaa,bbb,ccc
if,we,just,put,enough,pressure,on,it,the,end,should,come,soon
'
			with: #parser
			withArgs:
				{} ].
		end := DateAndTime now.
		StdIOWriteStream stderr
		nextPutAll: (end-start) displayStringOrText ;
		nextPut: Character lf.
^ generateLotsOfGarbage ! !


OMeta2Debug subclass: #CNGResourceGobblingParser
	instanceVariableNames: 'curRow rows delimRow delimCol'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CouldNotGrow'!

!CNGResourceGobblingParser methodsFor: 'as yet unclassified' stamp: 'pb 10/10/2017 19:21:17'!
       doSomethingWasteful
	rows := rows veryDeepCopy veryDeepCopy veryDeepCopy veryDeepCopy ! !

!CNGResourceGobblingParser methodsFor: 'as yet unclassified' stamp: 'pb 10/11/2017 00:37:27'!
       field =
	<(~(exactly(delimCol) | exactly(delimRow)) anything)*>:field -> [curRow add: field]! !

!CNGResourceGobblingParser methodsFor: 'as yet unclassified' stamp: 'pb 10/10/2017 18:38:48'!
 initialize
	super initialize.
	curRow := OrderedCollection new.
	rows := OrderedCollection new.
	delimRow := Character lf.
	delimCol := $,.
! !

!CNGResourceGobblingParser methodsFor: 'as yet unclassified' stamp: 'pb 10/10/2017 18:26:26'!
                 line = ~end field (exactly(delimCol) field)* (exactly(delimRow) | end) -> [[rows add: curRow. curRow := OrderedCollection new.] value]! !

!CNGResourceGobblingParser methodsFor: 'as yet unclassified' stamp: 'pb 10/10/2017 19:21:25'!
                       parser = line+ -> [self doSomethingWasteful]! !

!CNGResourceGobblingParser methodsFor: 'as yet unclassified' stamp: 'pb 10/11/2017 00:09:35'!
                 rows
	^ rows! !


Object subclass: #Categorizer
	instanceVariableNames: 'categoryArray categoryStops elementArray'
	classVariableNames: 'Default NullCategory'
	poolDictionaries: ''
	category: 'Kernel-Classes'!

!Categorizer methodsFor: 'tdd' stamp: 'HAW 2/7/2017 09:06:13'!
              classesAt: aCategoryName

	^(self listAtCategoryNamed: aCategoryName) collect: [:aClassName | Smalltalk classNamed: aClassName ]
		! !

!Categorizer methodsFor: 'tdd' stamp: 'HAW 2/7/2017 09:06:34'!
                         testCaseClassesAt: aCategoryName

	^(self classesAt: aCategoryName) select: [ :aClass | aClass is: #TestCaseClass ]! !


CodeProvider subclass: #ChangeList
	instanceVariableNames: 'changeList list listIndex listSelections file'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!

!ChangeList methodsFor: 'scanning' stamp: 'jmv 7/17/2017 15:44:04'!
             scanFile: aFile from: startPosition to: stopPosition

	file _ aFile.
	changeList _ OrderedCollection new.
	list _ OrderedCollection new.
	listIndex _ 0.
	file position: startPosition.
	'Scanning ', aFile localName, '...'
		displayProgressAt: Sensor mousePoint
		from: startPosition to: stopPosition
		during: [ :barBlock |
			[file position < stopPosition] whileTrue: [ | prevChar |
				barBlock value: file position.
				[file atEnd not and: [file peek isSeparator]]
					whileTrue: [prevChar _ file next].
				(file peekFor: $!!)
					ifTrue: [
						"A line starting with $!! means a specific ChangeRecord type"
						(prevChar notNil and: [ prevChar isLineSeparator ])
							ifTrue: [self scanSpecificChangeRecordType]]
					ifFalse: [
						"Otherwise, interpret it with #doIt:"
						| itemPosition item |
						itemPosition _ file position.
						item _ file nextChunk.
						item size > 0 ifTrue: [
							self
								addItem: (ChangeRecord new file: file position: itemPosition type: #doIt)
								text: 'do it: ' , (item contractTo: 160)]]]].
	self clearSelections! !

!ChangeList methodsFor: 'menu actions' stamp: 'jmv 6/19/2017 11:45:52'!
                              fileOutCurrentVersionsOfSelections
	
	(FillInTheBlankMorph
		request: 'Enter file name'
		initialAnswer: 'Filename.st'
		onCancel: [^nil])

			asFileEntry writeStreamDo: [ :stream |
				stream timeStamp.
				self currentVersionsOfSelections do: [ :methodRef |
					methodRef actualClass
						printMethodChunk: methodRef methodSymbol
						withPreamble: true
						on: stream
						moveSource: false
						toFile: 0 ]]! !

!ChangeList methodsFor: 'menu actions' stamp: 'HAW 9/4/2017 10:26:32'!
                  removeDoIts
	"Remove doits from the receiver, other than initializes. 1/26/96 sw"

	| newChangeList newList |
	newChangeList _ OrderedCollection new.
	newList _ OrderedCollection new.

	changeList with: list do: [ :chRec :str |
		(chRec isDoIt not or: [str endsWith: 'initialize'])
			ifTrue: [
				newChangeList add: chRec.
				newList add: str]].
	newChangeList size < changeList size
		ifTrue: [
			changeList _ newChangeList.
			list _ newList.
			listIndex _ 0.
			self clearSelections ].
	self changed: #list.

	! !

!ChangeList methodsFor: 'menu actions' stamp: 'HAW 9/4/2017 10:26:50'!
              selectRemovalsOfSent
	"Selects all method removal for sent methods"

	1 to: changeList size do: [ :i | | change |
		change _ changeList at: i.
		listSelections at: i put:
			(change isDoIt and: [
				change string includesSubString: 'removeSelector: #' ] and: [
					Smalltalk isThereAReferenceTo: (change string copyAfterLast: $#) asSymbol ]) ].
	self changed: #allSelections.
	self changed: #annotation! !

!ChangeList methodsFor: 'shout styling' stamp: 'jmv 8/26/2017 19:21:23'!
                              shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Set the classOrMetaClass in anSHTextStyler, so that identifiers
	will be resolved correctly.
	Answer true to allow styling to proceed, or false to veto the styling"
	
	self isModeStyleable ifFalse: [^false].
	listIndex = 0 ifFalse: [
		(changeList at: listIndex) changeType = #method ifTrue: [
			self selectedClassOrMetaClass ifNotNil: [ :cl |
				anSHTextStyler classOrMetaClass: cl.
				^true ]]].
	^false! !


ChangeList class
	instanceVariableNames: ''!

!ChangeList class methodsFor: 'public access' stamp: 'HAW 9/6/2017 19:58:01'!
                  browseFrom: startPosition on: aChangesFileName labeled: aLabel
	
	"
	ChangeList browseFrom: Smalltalk lastQuitLogPosition on: Smalltalk currentChangesName labeled: 'Lost changes'
	"
	
	| changeList end |

	aChangesFileName asFileEntry readStreamDo: [ :changesFile |
		end _ changesFile size.
		changeList _ self new
			scanFile: changesFile
			from: startPosition 
			to: end.
	].

	ChangeListWindow open: changeList label: aLabel! !

!ChangeList class methodsFor: 'public access' stamp: 'HAW 9/4/2017 10:32:00'!
                               browseRecentLogOn: origChangesFileName 
	"figure out where the last snapshot or quit was, then browse the recent entries."

	| end done block positions prevBlock |
	origChangesFileName asFileEntry readStreamDo: [ :changesFile |
		positions _ SortedCollection new.
		end _ changesFile size.
		prevBlock _ end.
		block _ end - 1024 max: 0.
		done _ false.
		[ done or: [ positions size > 0 ]]
			whileFalse: [
				changesFile position: block.
				"ignore first fragment"
				changesFile nextChunk.
				[ changesFile position < prevBlock ]
					whileTrue: [
						| pos chunk |
						pos _ changesFile position.
						chunk _ changesFile nextChunk.
						((Smalltalk isQuitRecord: chunk) or: [ Smalltalk isSnapshotRecord: chunk ])
							ifTrue: [ positions add: pos ]].
				block = 0
					ifTrue: [done _ true]
					ifFalse: [
						prevBlock _ block.
						block _ block - 1024 max: 0]].
	].
	positions isEmpty
		ifTrue: [self inform: 'File ' , origChangesFileName , ' does not appear to be a changes file']
		ifFalse: [self browseRecentLogOn: origChangesFileName startingFrom: positions last]! !

!ChangeList class methodsFor: 'fileIn/Out' stamp: 'jmv 8/28/2017 21:39:59'!
           serviceContents
	"Answer a service for opening a changelist browser on a file"

	^ (SimpleServiceEntry 
		provider: self 
		label: 'code file contents'
		selector: #browseContents:
		description: 'open a code file contents tool on this file'
		buttonLabel: 'contents')
			sortOrder: 20;
			argumentGetter: [ :fileList | fileList selectedFileEntry ]! !

!ChangeList class methodsFor: 'fileIn/Out' stamp: 'jmv 8/28/2017 21:39:55'!
                   servicePackageContents
	"Answer a service for opening a changelist browser on a file"

	^ (SimpleServiceEntry 
		provider: self 
		label: 'package file contents'
		selector: #browsePackageContents:
		description: 'open a code file contents tool on this package file'
		buttonLabel: 'pck contents')
			sortOrder: 20;
			argumentGetter: [ :fileList | fileList selectedFileEntry ]! !


CodeWindow subclass: #ChangeListWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!

!ChangeListWindow methodsFor: 'menu building' stamp: 'jmv 6/19/2017 11:39:03'!
     listMenu
	"Fill aMenu up so that it comprises the primary changelist-browser menu"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addTitle: 'change list'.
	aMenu addStayUpIcons.
	aMenu addList: #(
	('fileIn selections'							fileInSelections
			'import the selected items into the image'																			model)
	('fileOut selections...	'					fileOutSelections
			'create a new file containing the selected items'																	model)
	('fileOut current version of selections...'	fileOutCurrentVersionsOfSelections
			'create a new file containing the current (in-image) counterparts of the selected methods'					model)
	-
	('compare to current'						compareToCurrentVersion
			'open a separate window which shows the text differences between the on-file version and the in-image version.' model)
	('toggle diffing (D)'							toggleDiffing							
			'start or stop showing diffs in the code pane.'																		model)
	-
	('select new methods'						selectNewMethods
			'select methods in the file that do not currently exist in the image'												model)
	('select changes for absent classes'		selectAllForAbsentClasses
			'select methods in the file for classes that are not defined in the image'										model)
	('select all changes for this class'			selectAllForThisClass
			'select all methods in the file that belong to the currently-selected class'										model)
	('select unchanged methods'				selectUnchangedMethods	
			'select methods in the file whose in-image versions are the same as their in-file counterparts'				model)
	('select methods equivalent to current'	selectEquivalentMethods
			'select methods in the file whose in-image versions have the same behavior as their in-file counterparts'	model)
	('select methods older than current'		selectMethodsOlderThanCurrent
			'select methods in the file that are older than the one currently in the image'									model)
	('select removals of sent methods'		selectRemovalsOfSent
			'select all method removals of methods that have some sender in the image'									model)
	-
	('select all (a)'								selectAll
			'select all the items in the list'																							model)
	('deselect all'									deselectAll
			'deselect all the items in the list'																						model)
	('invert selections'							invertSelections
			'select every item that is not currently selected, and deselect every item that *is* currently selected'		model)
	-
	('browse class and method'				browseMethodFull
			'open a full browser showing the selected method')
	('browse all versions of single selection'	browseVersions
			'open a version browser showing the versions of the currently selected method')
	('browse current versions of selections'	browseCurrentVersionsOfSelections
			'open a message-list browser showing the current (in-image) counterparts of the selected methods')
	('destroy current methods of selections'	destroyCurrentCodeOfSelections
			'remove (*destroy*) the in-image counterparts of all selected methods'										model)
	-
	('remove doIts'								removeDoIts
			'remove all items that are doIts rather than definitions'																model)
	('remove older versions'					removeOlderMethodVersions
			'remove all but the most recent versions of methods in the list'													model)
	('remove up-to-date versions'				removeUpToDate
			'remove all items whose code is the same as the counterpart in-image code'									model)
	('remove empty class comments'			removeEmptyClassComments
			'remove all empty class comments'																					model)
	('remove selected items'					removeSelections
			'remove the selected items from the change-list'																	model)
	('remove unselected items'					removeNonSelections
			'remove all the items not currently selected from the change-list'												model)).
	^ aMenu! !


ChangeList subclass: #ChangeListWithFileInErrors
	instanceVariableNames: 'errors'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!

!ChangeListWithFileInErrors methodsFor: 'filing in' stamp: 'HAW 9/4/2017 09:34:35'!
                          fileInAllKeepingErrors

	errors := Dictionary new.
	changeList do: [ :change | self fileInKeepingError: change ].
! !

!ChangeListWithFileInErrors methodsFor: 'filing in' stamp: 'HAW 9/4/2017 16:36:13'!
                     fileInKeepingError: change
	
	[ change fileIn ]
		on: Error 
		do: [ :anError | (self hasToKeep: anError for: change) ifTrue: [ errors at: change put: anError ]]! !

!ChangeListWithFileInErrors methodsFor: 'initialization-release' stamp: 'HAW 9/4/2017 09:34:20'!
                         initialize

	super initialize.
	errors := Dictionary new.! !

!ChangeListWithFileInErrors methodsFor: 'testing' stamp: 'HAW 9/4/2017 09:37:00'!
                hasFileInErrors

	^errors notEmpty! !

!ChangeListWithFileInErrors methodsFor: 'testing' stamp: 'HAW 9/4/2017 16:37:07'!
       hasToKeep: anError for: change

	^(change isDoIt and: [ anError isKindOf: MessageNotUnderstood ]) not! !

!ChangeListWithFileInErrors methodsFor: 'showing filein errors' stamp: 'HAW 9/4/2017 10:01:06'!
                      failedFileInChangesLabel

	^'Changes that failed to file in'! !

!ChangeListWithFileInErrors methodsFor: 'showing filein errors' stamp: 'HAW 9/4/2017 10:45:43'!
                               ifFiledInWithErrorAdd: aChange at: anIndex to: newChangeList and: newList 
	
	(self wasFiledInWithError: aChange) ifTrue: [ 
		newChangeList add: aChange.
		newList add: ((list at: anIndex) contractTo: 40), ' | ', (errors at: aChange) printString ]! !

!ChangeListWithFileInErrors methodsFor: 'showing filein errors' stamp: 'HAW 9/4/2017 10:04:47'!
   removeSucessfullyFiledInChanges

	| newChangeList newList |

	newChangeList := OrderedCollection new.
	newList := OrderedCollection new.

	changeList withIndexDo: [ :aChange :anIndex | self ifFiledInWithErrorAdd: aChange at: anIndex to: newChangeList and: newList ].
			
	changeList _ newChangeList.
	list _ newList.
	listIndex _ 0.
	self clearSelections.
	self changed: #list.! !

!ChangeListWithFileInErrors methodsFor: 'showing filein errors' stamp: 'HAW 9/4/2017 10:02:20'!
  showChangesWithFileInErrors

	self removeSucessfullyFiledInChanges.
	ChangeListWindow open: self label: self failedFileInChangesLabel

! !

!ChangeListWithFileInErrors methodsFor: 'showing filein errors' stamp: 'HAW 9/4/2017 10:46:01'!
                    wasFiledInWithError: aChange
	
	^errors includesKey: aChange! !

!ChangeListWithFileInErrors commentStamp: 'HAW 9/4/2017 10:23:05' prior: 0!
                   This class is used to keep errors when filing in changes.
I could have use ChangeList directly, selecting changes with errors, then removing them, etc., but it had some problems and that solution is more a hack.
So, instances of this class will keep errors when filing in a change, and it allows the posibility to show the change with the error in a change list window.

A doit change that signaled a MessageNotUnderstood is assume to not be an error becuase those kinds of things are evaluations in specific contexts that will obiously generate errors.
All doits with errors could be assume not to be errors, but I limited to MNU type of errors to avoid filtering errors that should be shown.!

ChangeListElement subclass: #ChangeRecord
	instanceVariableNames: 'file position type class category meta stamp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!

!ChangeRecord methodsFor: 'initialization' stamp: 'HAW 9/4/2017 10:27:15'!
 fileIn
	"File the receiver in.  If I represent a method or a class-comment, file the method in and make a note of it in the recent-submissions list; if I represent a do-it, then, well, do it."
	| s |
	type == #method ifTrue: [
		self changeClass ifNotNil: [ :methodClass |
			methodClass
				compile: self text
				classified: category
				withStamp: stamp
				notifying: nil ]].
	self isDoIt ifTrue: [
		((s _ self string) beginsWith: '----') ifFalse: [ Compiler evaluate: s ]].
	type == #classDefinition ifTrue: [ Compiler evaluate: self string ].
	type == #classComment ifTrue: [
		(Smalltalk at: class asSymbol)
			comment: self text
			stamp: stamp ]! !

!ChangeRecord methodsFor: 'testing' stamp: 'HAW 9/4/2017 06:32:29'!
        isDoIt

	^type = #doIt! !


Object subclass: #ChangeSet
	instanceVariableNames: 'name preamble postscript changeRecords structures superclasses hasUnsavedChanges isForBaseSystem codePackage'
	classVariableNames: 'AllChangeSets CurrentBaseCSNumber Installing'
	poolDictionaries: ''
	category: 'Tools-Changes'!

!ChangeSet methodsFor: 'method changes' stamp: 'jmv 5/24/2017 00:28:50'!
 changedMessageList
	"Used by a message set browser to access the list view information."

	| messageList |
	messageList _ OrderedCollection new.
	changeRecords associationsDo: [ :clAssoc | | classNameInFull classNameInParts |
		classNameInFull _ clAssoc key asString.
		classNameInParts _ classNameInFull findTokens: ' '.

		(clAssoc value allChangeTypes includes: #comment) ifTrue: [
			messageList add:
				(MethodReference new
					setClassSymbol: classNameInParts first asSymbol
					classIsMeta: false 
					methodSymbol: #Comment 
					stringVersion: classNameInFull, ' Comment')].

		clAssoc value methodChangeTypes associationsDo: [ :mAssoc |
			(#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc value) ifFalse: [
				messageList add:
					(MethodReference new
						setClassSymbol: classNameInParts first asSymbol
						classIsMeta: classNameInParts size > 1 
						methodSymbol: mAssoc key 
						stringVersion: classNameInFull, ' ' , mAssoc key)]]].
	^ messageList sorted! !


ChangeSet class
	instanceVariableNames: ''!

!ChangeSet class methodsFor: 'file list services' stamp: 'jmv 8/28/2017 21:28:59'!
                     serviceFileIn
	"Answer a service for filing in an entire file"

	^ (SimpleServiceEntry 
		provider: self 
		label: 'fileIn entire file'
		selector: #fileIn:
		description: 'file in the entire contents of the file, which is expected to contain Smalltalk code in fileout ("chunk") format'
		buttonLabel: 'filein')
			sortOrder: 100;
			argumentGetter: [ :fileList | fileList selectedFileEntry ]! !

!ChangeSet class methodsFor: 'file list services' stamp: 'jmv 8/28/2017 21:29:05'!
serviceInstall
	"Answer a service for filing in an entire file"

	^ (SimpleServiceEntry 
		provider: self 
		label: 'install code'
		selector: #install:
		description: 'install change set'
		buttonLabel: 'install')
			sortOrder: 100;
			argumentGetter: [ :fileList | fileList selectedFileEntry ]! !


CodeProvider subclass: #ChangeSorter
	instanceVariableNames: 'myChangeSet currentClassName currentSelector priorChangeSetList priorDirtyFlags'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!

!ChangeSorter methodsFor: 'shout styling' stamp: 'jmv 8/26/2017 19:21:27'!
              shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Set the classOrMetaClass in anSHTextStyler, so that identifiers
	will be resolved correctly.
	Answer true to allow styling to proceed, or false to veto the styling"

	self isModeStyleable ifFalse: [^false].
	self currentSelector ifNil: [^false].
	anSHTextStyler classOrMetaClass: self selectedClassOrMetaClass.
	^true! !


CodeWindow subclass: #ChangeSorterWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!

!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'DM 8/22/2015 12:34'!
              buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes backColor labelBackground |
	backColor _ self textBackgroundColor.
	labelBackground _ Theme current background.
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: Theme current background;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: ' Unsaved?');
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: backColor.
	changeSetList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: 'Change Set name');
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: backColor.
	classList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: 'Classes');
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.13;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.47;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: backColor.
	messageList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: 'Methods');
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.2;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.55.

	self setLabel: model labelString! !

!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 6/19/2017 16:01:18'!
                   initialExtent
	^`540@300`! !


Object immediateSubclass: #Character
	instanceVariableNames: 'value'
	classVariableNames: 'CharacterTable ClassificationTable LetterBits LowercaseBit UnaccentedTable UnicodeCodePoints UppercaseBit'
	poolDictionaries: ''
	category: 'Kernel-Text'!

!Character methodsFor: 'accessing' stamp: 'jmv 5/9/2017 19:49:32'!
       digitValue
	"Answer 0-9 if the receiver is $0-$9, 10-35 if it is $A-$Z, and < 0 
	otherwise. This is used to parse literal numbers of radix 2-36.
	$0 numericValue = 48
	$9 numericValue = 57
	$A numericValue = 65
	$Z numericValue = 90 
	$7 digitValue = 7 
	"

	| nv |
	nv _ self numericValue.
	(nv between: 48 and: 57)
		ifTrue: [ ^ nv - 48 ].
	(nv between: 65 and: 90)
		ifTrue: [ ^ nv - 55 ].
	^ -1! !

!Character methodsFor: 'testing' stamp: 'jmv 12/10/2016 01:26:44'!
         isValidInIdentifiers
	"Can c be part of an identifier? (unary or keyword selector, or variable name)"

	^self isAlphaNumeric or: [ #( $_ ) statePointsTo: self ]! !


Character class
	instanceVariableNames: ''!

!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 9/24/2017 20:34:05'!
             shortUnderscore
	"Answer the Character representing very short (or invisible) underscore.
	Used to optionally mark subscript in code."

	^ Character numericValue: 127! !

!Character class methodsFor: 'accessing mathematical symbols' stamp: 'jmv 9/24/2017 20:13:24'!
                      infinity
	"
	Character infinity
	"
	^ $! !


Object subclass: #CharacterScanner
	instanceVariableNames: 'destX lastIndex xTable map destY stopConditions text alignment leftMargin rightMargin font line runStopIndex spaceCount spaceWidth kern paragraphStyle tabWidth defaultFont'
	classVariableNames: 'DefaultStopConditions StopConditionsWithPaddedSpace StopConditionsWithSpace'
	poolDictionaries: ''
	category: 'Graphics-Text'!

!CharacterScanner methodsFor: 'private' stamp: 'jmv 9/7/2017 17:00:23'!
           backgroundColor: ignored
	"Overridden in MorphicScanner"! !

!CharacterScanner methodsFor: 'private' stamp: 'jmv 9/7/2017 17:19:12'!
                           setFont
	| attributes |
	"Set the font and other emphasis.
	In fact set actual ParagraphStyle (or nil), alignment, font and emphasis"

	self setActualFont: (text fontAt: lastIndex default: defaultFont).
	attributes _ text attributesAt: lastIndex.
	text
		withAttributeValues: attributes
		do: [ :familyNameInText :pointSizeInText :emphasisInText :colorInText :alignmentInText :characterStyleInText :paragraphStyleInText :backgroundColorInText |
			colorInText ifNotNil: [ self textColor: colorInText ].
			self backgroundColor: backgroundColorInText.
			alignment _ alignmentInText.
			paragraphStyle _ paragraphStyleInText ].
	
	"Hardcoded color for TextAction"
	attributes do: [ :attribute |
		attribute forTextActionInfoDo: [ :info |
			self textColor: TextAction textActionColor ]].

	"Install various parameters from the font."
	spaceWidth _ font widthOf: Character space.
	tabWidth _ (font widthOf: $a) * 3.
	xTable _ font xTable.
	map _ font characterToGlyphMap! !

!CharacterScanner methodsFor: 'private' stamp: 'jmv 9/6/2017 20:40:09'!
           textColor: ignored
	"Overridden in MorphicScanner"! !


ClassDescription subclass: #Class
	instanceVariableNames: 'subclasses name classPool sharedPools'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Classes'!

!Class methodsFor: 'tdd' stamp: 'HAW 2/7/2017 10:42:40'!
 testCaseClass
		
	| potentialTestCaseClass |
	
	potentialTestCaseClass _ Smalltalk classNamed: self name, 'Test'.
	
	^potentialTestCaseClass 
	
 ! !


Object subclass: #ClassBuilder
	instanceVariableNames: 'instVarMap progress maxClassIndex currentClassIndex'
	classVariableNames: 'QuietMode'
	poolDictionaries: ''
	category: 'Kernel-Classes'!

!ClassBuilder methodsFor: 'private' stamp: 'jmv 7/17/2017 15:48:14'!
  informUserDuring: aBlock
	self class isSilent ifTrue:[^aBlock value].
	Utilities informUserDuring:[:barBlock|
		progress _ barBlock.
		aBlock value].
	progress _ nil.! !

!ClassBuilder methodsFor: 'private' stamp: 'jmv 8/28/2017 16:58:40'!
                reservedNames
	"Return a list of names that must not be used for variables"
	^#(#self #super #true #false #nil #thisContext)! !


Behavior subclass: #ClassDescription
	instanceVariableNames: 'instanceVariables organization'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Classes'!

!ClassDescription methodsFor: 'instance variables' stamp: 'jmv 5/24/2017 00:29:04'!
chooseInstVarAlphabeticallyThenDo: aBlock
	| allVars index |
	"Put up a menu of all the instance variables in the receiver, presented in alphabetical order, and when the user chooses one, evaluate aBlock with the chosen variable as its parameter."

	allVars _ self allInstVarNames sorted.
	allVars isEmpty ifTrue: [^ self inform: 'There are no
instance variables'].

	index _ (PopUpMenu labelArray: allVars lines: #()) startUpWithCaption: 'Instance variables in
', self name.
	index = 0 ifTrue: [^ self].
	aBlock value: (allVars at: index)! !

!ClassDescription methodsFor: 'method dictionary' stamp: 'jmv 5/24/2017 00:28:55'!
             allMethodsInCategory: aSymbol
	"Answer a list of all the method categories of the receiver and all its superclasses"

	| aColl |
	aColl _ OrderedCollection new.
	self withAllSuperclasses do:
		[:aClass | aColl addAll:
			(aSymbol == ClassOrganizer allCategory
				ifTrue:
					[aClass organization allMethodSelectors]
				ifFalse:
					[aClass organization listAtCategoryNamed: aSymbol])].
	^ aColl asSet sorted

"TileMorph allMethodsInCategory: #initialization"! !


Object subclass: #CodeFile
	instanceVariableNames: 'fullName sourceSystem classes doIts classOrder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Code File Browser'!

!CodeFile methodsFor: 'change record types' stamp: 'jmv 3/1/2017 12:31:23'!
       doIt: chgRec
	"See senders of #doIt "
	| string |
	string := chgRec string.
	
	"Method classification spec"
	(string beginsWith: '(''') ifTrue: [
		^ doIts add: chgRec ].
		
	"Just for compatibility with Squeak, as Cuis always adds the #classDefinition change type marker in the files."
	('*ubclass:*instanceVariableNames:*classVariableNames:*poolDictionaries:*category:*'
		match: string) ifTrue:[^self classDefinition: string with: chgRec].

	"Just for compatibility with Squeak, as Cuis always adds the #classDefinition change type marker in the files."
	('* class*instanceVariableNames:*'
		match: string) ifTrue:[^self metaClassDefinition: string with: chgRec].

	"Just for compatibility with Squeak, as Cuis always adds the #methodRemoval: (or similar) change type marker in the files."
	('* removeSelector: *'
		match: string) ifTrue:[^self removedMethod: string with: chgRec].

	"Just for compatibility with Squeak, as Cuis always adds the #classComment change type marker in the files."
	('* comment:*'
		match: string) ifTrue:[^self msgClassComment: string with: chgRec].

	"Don't add these to a CodeFile. They will be added on save if needed."
	('* initialize'
		match: string) ifTrue:[^self]. "Initialization is done based on class>>initialize"

	('''From *'
		match: string) ifTrue:[^self possibleSystemSource: chgRec].
	doIts add: chgRec.! !

!CodeFile methodsFor: 'reading' stamp: 'jmv 7/17/2017 15:44:20'!
                  buildFrom: aStream
	| chgRec changes |
	changes _ (ChangeList new scanFile: aStream from: 0 to: aStream size) changeList.
	('Processing ', self name) 
		displayProgressAt: Sensor mousePoint
		from: 1
		to: changes size
		during: [ :barBlock |
			1 to: changes size do:[:i|
				barBlock value: i.
				chgRec := changes at: i.
				chgRec class == MethodDeletionChangeRecord
					ifTrue: [ self removedMethod: chgRec command with: chgRec ]
					ifFalse: [ self perform: (chgRec changeType copyWith: $:) asSymbol with: chgRec ].
			].
		]! !


Browser subclass: #CodeFileBrowser
	instanceVariableNames: 'codeFile'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Code File Browser'!

!CodeFileBrowser methodsFor: 'shout styling' stamp: 'jmv 8/26/2017 19:21:30'!
                           shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Set the classOrMetaClass in anSHTextStyler, so that identifiers
	will be resolved correctly.
	Answer true to allow styling to proceed, or false to veto the styling"

	self isModeStyleable ifFalse: [^false].
	anSHTextStyler classOrMetaClass: self selectedClassOrMetaClass.
	^true! !


CodeFileBrowser class
	instanceVariableNames: ''!

!CodeFileBrowser class methodsFor: 'instance creation' stamp: 'jmv 8/28/2017 21:40:08'!
     serviceBrowseCode
	"Answer the service of opening a file-contents browser"

	^ (SimpleServiceEntry
		provider: self 
		label: 'code file browser'
		selector: #browseCode:
		description: 'open a "file-contents browser" on this file, allowing you to view and selectively load its code'
		buttonLabel: 'code')
			sortOrder: 10;
			argumentGetter: [ :fileList | fileList selectedFileEntry ]! !

!CodeFileBrowser class methodsFor: 'instance creation' stamp: 'jmv 8/28/2017 21:40:05'!
 serviceBrowsePackage
	"Answer the service of opening a file-contents browser"

	^ (SimpleServiceEntry
		provider: self 
		label: 'package file browser'
		selector: #browsePackage:
		description: 'open a "package file browser" on this file, allowing you to view and selectively load its code'
		buttonLabel: 'package browser')
			sortOrder: 10;
			argumentGetter: [ :fileList | fileList selectedFileEntry ]! !


CodePackageFile class
	instanceVariableNames: ''!

!CodePackageFile class methodsFor: 'file list services' stamp: 'jmv 8/28/2017 21:29:39'!
                         serviceInstallPackage
	"Answer the service of installing a CodePackageFile (a chunk format file for a CodePackage)"

	^ (SimpleServiceEntry
		provider: self 
		label: 'install package'
		selector: #installPackageStream:
		description: 'install the package, replacing all existing code in the package (if any); create a new change set just for the installation'
		buttonLabel: 'install package')
			sortOrder: 100;
			argumentGetter: [ :fileList | fileList selectedFileEntry ]! !


SystemWindow subclass: #CodePackageListWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!

!CodePackageListWindow methodsFor: 'GUI building' stamp: 'pb 7/23/2017 00:53:45'!
                         buildMorphicWindow
	" 
	CodePackageListWindow open: CodePackageList new
	"
	| dirtyFlags names fileNames upperRow  description summary backColor labelBackground textHeigth |
	backColor := self textBackgroundColor.	
	labelBackground := Theme current background.
	textHeigth := AbstractFont default height.
	
	dirtyFlags := PluggableListMorph
		model: model 
		listGetter: #packageDirtyFlags
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	dirtyFlags color: backColor.
	dirtyFlags := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: textHeigth;
		addMorphUseAll: dirtyFlags.

	names := PluggableListMorph
		model: model 
		listGetter: #packageNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	names color: backColor.
	names := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Package Name') fixedHeight: textHeigth;
		addMorphUseAll: names.

	fileNames := PluggableListMorph
		model: model 
		listGetter: #packageFullNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	fileNames color: backColor.
	fileNames := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' File Name') fixedHeight: textHeigth;
		addMorphUseAll: fileNames.

	upperRow := LayoutMorph newRow.
	upperRow
		addMorph: dirtyFlags proportionalWidth: 0.13;
		addAdjusterAndMorph: names proportionalWidth: 0.27;
		addAdjusterAndMorph: fileNames proportionalWidth: 0.6.
		
	description := TextModelMorph
		textProvider: model
		textGetter: #description 
		textSetter: #description:.

	summary := TextModelMorph
		textProvider: model
		textGetter: #summary.

	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.6;
		addAdjusterAndMorph: self buildButtonPane fixedHeight: Theme current buttonPaneHeight;
		addAdjusterAndMorph: summary fixedHeight: 60;
		addAdjusterAndMorph: description proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildRequirementsPane proportionalHeight: 0.15.
	self setLabel: 'Installed Packages'! !

!CodePackageListWindow methodsFor: 'GUI building' stamp: 'len 5/27/2016 21:51'!
                       buildRequirementsPane

	| requirements deleteReqButton "editReqButton" reqLayout buttonLayout |
	requirements := PluggableListMorph
		model: (PackageRequirementsList fromCodePackageList: model)
		listGetter: #requirementsStrings
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	requirements color: Theme current textPane.
		
	deleteReqButton := PluggableButtonMorph 
							model: requirements model
							action: #deleteSelectedRequirement 
							label: 'delete'.
	deleteReqButton color: self widgetsColor.
							
	buttonLayout := LayoutMorph newColumn.
	buttonLayout addMorph: deleteReqButton 
					layoutSpec: (LayoutSpec 
										proportionalWidth: 1.0 
										proportionalHeight: 1.0
										minorDirectionPadding: #top);
					color: self widgetsColor quiteWhiter.
		
	model when: #changed: send: #updateRequirementsFromPackageList to: requirements model.
	self when: #changed: send: #updateRequirementsFromPackageList to: requirements model.
	requirements model when: #changed: send: #verifyContents to: requirements.
	self when: #changed: send: #verifyContents to: requirements.
	
	reqLayout := LayoutMorph newRow.
	^ reqLayout 
		doAdoptWidgetsColor;
		addMorph: requirements 
			layoutSpec: (LayoutSpec 
							proportionalWidth: 0.9 
							proportionalHeight: 1.0 
							minorDirectionPadding: #left);
		addMorph: buttonLayout 
			layoutSpec: (LayoutSpec 
							proportionalWidth: 0.1 
							proportionalHeight: 1.0 
							minorDirectionPadding: #right);
		color: Color transparent;
		yourself
		! !

!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 6/19/2017 16:01:26'!
       initialExtent

	^`540@400`! !


TextProvider subclass: #CodeProvider
	instanceVariableNames: 'currentCompiledMethod contentsSymbol'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 6/5/2017 11:51:33'!
     exploreCompiledMethod
	"Open an Explorer on the CompiledMethod itself"

	self selectedMessageName ifNotNil: [
		(self selectedClassOrMetaClass compiledMethodAt: self selectedMessageName)
			explore ]! !

!CodeProvider methodsFor: 'shout styling' stamp: 'jmv 8/26/2017 19:21:32'!
         shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Answer false if showing difs, to veto the styling."
	
	^self showingAnyKindOfDiffs not! !


SystemWindow subclass: #CodeWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!

!CodeWindow methodsFor: 'updating' stamp: 'jmv 9/2/2013 10:25'!
       decorateForInheritance
	"Check to see if the currently-viewed method has a super send or an override, and if so, change screen feedback, unless the #decorateBrowserButtons says not to."

	| cm aColor aButton flags buttonColor |
	(aButton _ self inheritanceButton) ifNil: [^ self].
	buttonColor _ self buttonColor.

	Preferences decorateBrowserButtons
		ifFalse: [ ^aButton color: buttonColor ].
	cm _ model currentCompiledMethod.
	(cm is: #CompiledMethod)
		ifFalse: [ ^aButton color: buttonColor ].

	flags _ 0.
	model isThisAnOverride ifTrue: [ flags _ flags bitOr: 4 ].
	cm sendsToSuper ifTrue: [ flags _ flags bitOr: 2 ].
	model isThereAnOverride ifTrue: [ flags _ flags bitOr: 1 ].
	aColor _ {

		"This is NOTan override. There is no super implementation."
		buttonColor.							"no sends to super. there is not override in any subclass"
		Color tan.							"no sends to super. there is an override in some subclass"
		Color red.							"sends to super. there is no override in any subclass. Error: no super to call (or calls super with a different message)"
		Color red.							"sends to super. there is  an override in some subclass. Error: no super to call (or calls super with a different message)"

		"This is an override. There is some super implementation"
		Color red muchLighter.			"doesn't have sub; has super but doesn't call it"
		Color r: 0.94 g: 0.823 b: 0.673.		"has sub; has super but doesn't call it"
		Color green muchLighter.			"doesn't have sub; has super and callsl it"
		Color blue muchLighter.			"has sub; has super and callsl it"

	} at: flags + 1.
	aButton color: aColor! !

!CodeWindow methodsFor: 'keyboard shortcuts' stamp: 'HAW 1/31/2017 11:56:31'!
                 classListKey: aChar from: view 
	"Respond to a Command key.  I am a model with a list of classes and a 
	code pane, and I also have a listView that has a list of methods.  The 
	view knows how to get the list and selection."

	aChar == $r ifTrue: [^ model recent].
	aChar == $h ifTrue: [^ self browseHierarchy].
	aChar == $x ifTrue: [^ model removeClass].
	aChar == $t ifTrue: [^ model runClassTests ].
	
	^ self messageListKey: aChar from: view! !

!CodeWindow methodsFor: 'keyboard shortcuts' stamp: 'HAW 2/10/2017 17:33:25'!
                messageListKey: aChar from: view
	"Respond to a Command key.  I am a model with a code pane, and I also
	have a listView that has a list of methods.  The view knows how to get
	the list and selection."

	| sel class |
	aChar == $D ifTrue: [^ model toggleDiffing].

	sel _ model selectedMessageName.
	aChar == $m ifTrue: [  "These next two put up a type in if no message selected"
		^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllImplementorsOf: to: Smalltalk].
	aChar == $n ifTrue: [
		^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllCallsOn: to: Smalltalk].

	"The following require a class selection"
	(class _ model selectedClassOrMetaClass) ifNil: [^ self ].
	aChar == $b ifTrue: [^ BrowserWindow fullOnClass: class selector: sel].
	aChar == $N ifTrue: [^ self browseClassRefs].
	aChar == $i ifTrue: [^ self methodHierarchy].
	aChar == $h ifTrue: [^ self browseHierarchy].
	aChar == $p ifTrue: [^ self browseFullProtocol].

	"The following require a method selection"
	sel ifNotNil: [
		aChar == $o ifTrue: [^ model fileOutMessage].
		aChar == $c ifTrue: [^ model copySelector].
		aChar == $v ifTrue: [^ self browseVersions].
		aChar == $O ifTrue: [^ self openSingleMessageBrowser].
		aChar == $x ifTrue: [^ model removeMessage].
		aChar == $t ifTrue: [^ model runMethodTest].
		aChar == $r ifTrue: [^ model debugMethodTest]]! !

!CodeWindow methodsFor: 'keyboard shortcuts' stamp: 'HAW 2/7/2017 10:49:07'!
  systemCatListKey: aChar from: view
	"Respond to a Command key.  I am a model with a code pane, and I also have a listView that has a list of methods.  The view knows how to get the list and selection."

	aChar == $f ifTrue: [^ self findClass].
	aChar == $x ifTrue: [^ model removeSystemCategory].
	aChar == $t ifTrue: [ ^model runSystemCategoryTests ].
	
	^ self classListKey: aChar from: view! !


Object subclass: #Collection
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Abstract'!

!Collection methodsFor: 'converting' stamp: 'jmv 7/17/2017 16:59:02'!
 asFloat64Array
	"Answer a Float64Array whose elements are the elements of the receiver"

	^self as: Float64Array! !

!Collection methodsFor: 'sorting' stamp: 'jmv 5/24/2017 00:28:06'!
        sorted
	"Return a new sequenceable collection which contains the same elements as self but its elements are sorted "

	^self sorted: nil! !


FloatArray variableWordSubclass: #Color
	instanceVariableNames: ''
	classVariableNames: 'CachedColormaps ColorNamesDict FromGrayColormaps GrayToIndexMap IndexedColors MaskingMap ToGrayColormaps'
	poolDictionaries: ''
	category: 'Graphics-Primitives'!

!Color methodsFor: 'access' stamp: 'jmv 1/31/2011 09:25'!
                            alpha
	"Return the opacity ('alpha') value of opaque so that normal colors can be compared to TranslucentColors."

	^ 1.0
! !

!Color methodsFor: 'access' stamp: 'jmv 6/18/2017 20:35:34'!
    blue
	"Return the blue component of this color, a float in the range [0.0..1.0]."

	^ self at: 3! !

!Color methodsFor: 'access' stamp: 'jmv 6/18/2017 20:33:10'!
                              brightness
	"Return the brightness of this color, a float in the range [0.0..1.0].
	Color red brightness
	"

	"Do not include alpha if TranslucentColor"
	^ (self red max: self green) max: self blue! !

!Color methodsFor: 'access' stamp: 'jmv 6/18/2017 20:34:30'!
                         chroma
	"Return the chroma of this color, a value between 0.0 and 1.0, somewhat related to saturation.
	See http://en.wikipedia.org/wiki/HSL_and_HSV
	Color red chroma
	Color gray chroma
	"

	| r g b max min |
	r _ self red.
	g _ self green.
	b _ self blue. 
	max _ (r max: g) max: b.
	min _ (r min: g) min: b.
	^max - min! !

!Color methodsFor: 'access' stamp: 'jmv 6/18/2017 20:35:28'!
                             green
	"Return the green component of this color, a float in the range [0.0..1.0]."

	^ self at: 2! !

!Color methodsFor: 'access' stamp: 'jmv 6/18/2017 20:31:54'!
                            hue
	"Return the hue of this color, an angle in the range [0.0..360.0].
	Color orange hue
	"

	| r g b max min span h |
	r _ self red.
	g _ self green.
	b _ self blue. 
	max _ (r max: g) max: b.
	min _ (r min: g) min: b.
	span _ (max - min) asFloat.
	span = 0.0 ifTrue: [ ^ 0.0 ].

	r = max ifTrue: [
		h _ ((g - b) asFloat / span) * 60.0.
	] ifFalse: [
		g = max
			ifTrue: [ h _ 120.0 + (((b - r) asFloat / span) * 60.0). ]
			ifFalse: [ h _ 240.0 + (((r - g) asFloat / span) * 60.0). ].
	].

	^h mod: 360.0! !

!Color methodsFor: 'access' stamp: 'KenD 1/23/2013 18:19'!
   icon
	"Answer a swatch to display in a menu or browser"
	^self swatch! !

!Color methodsFor: 'access' stamp: 'KenD 1/23/2013 18:17'!
                           iconOrThumbnailOfSize: aNumberOrPoint 
	"Answer an appropiate form to represent the receiver"
	| form |
	form := Form extent: aNumberOrPoint asPoint asPoint depth: 32.
	form fillColor: self.
	^ form! !

!Color methodsFor: 'access' stamp: 'jmv 4/19/2013 16:46'!
                           luminance
	"Return the luminance of this color, a brightness value weighted by the human eye's color sensitivity."

	^ ((299 * self red) +
	   (587 * self green) +
	   (114 * self blue)) / 1000! !

!Color methodsFor: 'access' stamp: 'jmv 6/18/2017 20:35:25'!
                             red
	"Return the red component of this color, a float in the range [0.0..1.0]."

	^ self at: 1! !

!Color methodsFor: 'access' stamp: 'jmv 6/18/2017 20:34:08'!
saturation
	"Return the saturation of this color, a value between 0.0 and 1.0.
	Color red saturation
	Color gray saturation
	"

	| r g b max min |
	r _ self red.
	g _ self green.
	b _ self blue. 
	max _ (r max: g) max: b.
	min _ (r min: g) min: b.
	max = 0.0 ifTrue: [ ^0.0 ].
	^max - min / max! !

!Color methodsFor: 'access' stamp: 'KenD 1/23/2013 18:18'!
                          swatch
	"Answer a swatch to display in a menu or browser"
	^self iconOrThumbnailOfSize: 16! !

!Color methodsFor: 'conversions' stamp: 'sw 10/27/1999 10:51'!
  asNontranslucentColor
	^ self! !

!Color methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:20:07'!
                            bitPatternForDepth: depth
	"Return a Bitmap, that best represents this color at the given depth. BitBlt calls this method to convert colors into Bitmaps."
	"See also:	pixelValueForDepth:	-- value for single pixel
				pixelWordForDepth:	-- a 32-bit word filled with the pixel value"

	^ Bitmap with: (self pixelWordForDepth: depth)! !

!Color methodsFor: 'conversions' stamp: 'jmv 6/3/2016 17:28'!
                   bitPatternForGrayForm
	"Return a Bitmap, that best represents this color at the given depth. BitBlt calls this method to convert colors into Bitmaps."
	"See also:	pixelValueForDepth:	-- value for single pixel
				pixelWordForDepth:	-- a 32-bit word filled with the pixel value"
	"Details: The pattern for the most recently requested depth is cached."

	^Bitmap with: (self pixelWordFor: 8 filledWith: (self luminance * 255) rounded)! !

!Color methodsFor: 'conversions' stamp: 'jmv 4/19/2013 16:17'!
            closestPixelValue1
	"Return the nearest approximation to this color for a monochrome Form."

	"fast special cases"
	self isBlack ifTrue: [^ 1].  "black"
	self isWhite ifTrue: [^ 0].  "white"

	self luminance > 0.5
		ifTrue: [^ 0]  "white"
		ifFalse: [^ 1].  "black"! !

!Color methodsFor: 'conversions' stamp: 'jmv 12/13/2014 16:18'!
                  closestPixelValue2
	"Return the nearest approximation to this color for a 2-bit deep Form."

	| lum |
	"fast special cases"
	self isBlack ifTrue: [^ 1].  "black"
	self isWhite ifTrue: [^ 2].  "opaque white"

	lum _ self luminance.
	lum < 0.2 ifTrue: [^ 1].  "black"
	lum > 0.6 ifTrue: [^ 2].  "opaque white"
	^ 3  "50% gray"
! !

!Color methodsFor: 'conversions' stamp: 'jmv 12/13/2014 16:17'!
                      closestPixelValue4
	"Return the nearest approximation to this color for a 4-bit deep Form."

	| bIndex |
	"fast special cases"
	self isBlack ifTrue: [^ 1].  "black"
	self isWhite ifTrue: [^ 2].  "opaque white"

	self isRed ifTrue: [^ 4].
	self isGreen ifTrue: [^ 5].
	self isBlue ifTrue: [^ 6].
	self isCyan ifTrue: [^ 7].
	self isYellow ifTrue: [^ 8].
	self isMagenta ifTrue: [^ 9].

	bIndex _ (self luminance * 8.0) rounded.  "bIndex in [0..8]"
	^ #(
		1	"black"
		10	"1/8 gray"
		11	"2/8 gray"
		12	"3/8 gray"
		3	"4/8 gray"
		13	"5/8 gray"
		14	"6/8 gray"
		15	"7/8 gray"
		2	"opaque white"
	) at: bIndex + 1.
! !

!Color methodsFor: 'conversions' stamp: 'jmv 4/21/2015 09:57'!
                      closestPixelValue8
	"Return the nearest approximation to this color for an 8-bit deep Form."

	"fast special cases"
	self isBlack ifTrue: [^ 1].  "black"
	self isWhite ifTrue: [^ 255].  "white"

	^self saturation < 0.2
		ifTrue: [
			^ self class grayToIndexMap at:(self green * 255) rounded + 1.  "nearest gray"
			]
		ifFalse: [
			"compute nearest entry in the color cube"
			40 + 
				((self red * 5) rounded * 36) +
				((self blue * 5) rounded * 6) +
				(self green * 5) rounded ]! !

!Color methodsFor: 'conversions' stamp: 'di 9/2/97 20:21'!
                         dominantColor
	^ self! !

!Color methodsFor: 'conversions' stamp: 'jmv 6/2/2016 14:48'!
        indexInMap: aColorMap
	"Return the index corresponding to this color in the given color map. RGB colors are truncated to 3-, 4-, or 5-bits per color component when indexing into such a colorMap.  "

	aColorMap size = 2 ifTrue: [^ (self pixelValueForDepth: 1) + 1].
	aColorMap size = 4 ifTrue: [^ (self pixelValueForDepth: 2) + 1].
	aColorMap size = 16 ifTrue: [^ (self pixelValueForDepth: 4) + 1].
	aColorMap size = 256 ifTrue: [^ (self pixelValueForDepth: 8) + 1].
	aColorMap size = 512 ifTrue: [^ (self pixelValueForDepth: 9) + 1].
	aColorMap size = 4096 ifTrue: [^ (self pixelValueForDepth: 12) + 1].
	aColorMap size = 32768 ifTrue: [^ (self pixelValueForDepth: 15) + 1].
	self error: 'unknown pixel depth'.
! !

!Color methodsFor: 'conversions' stamp: 'bf 4/18/2001 16:25'!
                      makeForegroundColor
        "Make a foreground color contrasting with me"
        ^self luminance >= 0.5
                ifTrue: [Color black]
                ifFalse: [Color white]! !

!Color methodsFor: 'conversions' stamp: 'jmv 6/20/2017 17:46:14'!
    pixelValueForDepth: d
	"Returns an integer representing the bits that appear in a single pixel of this color in a Form of the given depth. The depth must be one of 1, 2, 4, 8, 16, or 32. Contrast with pixelWordForDepth: and bitPatternForDepth:, which return either a 32-bit word packed with the given pixel value or a multiple-word Bitmap containing a pattern. The inverse is the class message colorFromPixelValue:depth:"
	"Details: For depths of 8 or less, the result is a colorMap index. For depths of 16 and 32, it is a direct color value with 5 or 8 bits per color component."
	"Transparency: The pixel value zero is reserved for transparent. For depths greater than 8 and less than 32 (no Indexed colors, no real alpha), black maps to the darkest possible blue.
	Note that 
		Color transparent class = TranslucentColor
	this special case is handled in TranslucentColor >> #pixelValueForDepth:
	"

	| bitBltFakeBlack val |
	"Most common case"
	"eight bits per component; top 8 bits set to all ones (opaque alpha)"
	d = 32 ifTrue: [
		^ 16rFF000000 bitOr:
			((((self at: 1) * 255.999) truncated bitShift: 16) bitOr:
			((((self at: 2) * 255.999) truncated bitShift: 8) bitOr: 
			(((self at: 3) * 255.999) truncated))) ].

"Faster in 32 bit systems, but slower in 64 bits"
"	d = 32 ifTrue: [
		val _ LargePositiveInteger new: 4.
		val at: 3 put: ((self at: 1) * 255.999) truncated.
		val at: 2 put: ((self at: 2)  * 255.999) truncated.
		val at: 1 put: ((self at: 3)  * 255.999) truncated.
		val at: 4 put: 16rFF.
		^ val normalize]."

	d = 8 ifTrue: [^ self closestPixelValue8].  "common case"
	d < 8 ifTrue: [
		d = 4 ifTrue: [^ self closestPixelValue4].
		d = 2 ifTrue: [^ self closestPixelValue2].
		d = 1 ifTrue: [^ self closestPixelValue1]].

	"For the depth 16, pixelValue = 0 means transparent, black is represented as 16r8000 (rgb=0, pixelvalue !!= 0)."
	(d = 16) | (d = 15) ifTrue: [
		"five bits per component; top bits ignored"
		val _ ((self red * 31) rounded bitShift: 10) bitOr:
			(((self green * 31) rounded bitShift: 5) bitOr: 
			((self blue * 31) rounded)).
		^ val = 0
			ifTrue: [d = 16 ifTrue: [16r8000] ifFalse: [1]]
			ifFalse: [val]].

	"For the rest of the depths, pixelValue = 0 means transparent, and darkest blue is considered to be black."
	bitBltFakeBlack := 1.  "closest black that is not transparent in RGB - Not for depths <=8 (Indexed) or = 32 (RGBA)"
	d = 12 ifTrue: [  "for indexing a color map with 4 bits per color component"
		val _ ((self red * 15) rounded bitShift: 8) bitOr:
			(((self green * 15) rounded bitShift: 4) bitOr: 
			((self blue * 15) rounded)).
		^ val = 0 ifTrue: [bitBltFakeBlack] ifFalse: [val]].

	d = 9 ifTrue: [  "for indexing a color map with 3 bits per color component"
		val _ ((self red * 7) rounded bitShift: 6) bitOr:
			(((self green * 7) rounded bitShift: 3) bitOr: 
			((self blue * 7) rounded)).
		^ val = 0 ifTrue: [bitBltFakeBlack] ifFalse: [val]].

	self error: 'unknown pixel depth: ', d printString! !

!Color methodsFor: 'conversions' stamp: 'di 11/30/1998 09:03'!
                       pixelWordFor: depth filledWith: pixelValue
	"Return to a 32-bit word that concatenates enough copies of the given pixel value to fill the word (i.e., 32/depth copies). Depth should be one of 1, 2, 4, 8, 16, or 32. The pixel value should be an integer in 0..2^depth-1."
	| halfword |
	depth = 32 ifTrue: [^ pixelValue].
	depth = 16
		ifTrue: [halfword _ pixelValue]
		ifFalse: [halfword _ pixelValue * 
					(#(16rFFFF				"replicates at every bit"
						16r5555 -			"replicates every 2 bits"
						16r1111 - - -			"replicates every 4 bits"
						16r0101) at: depth)	"replicates every 8 bits"].
	^ halfword bitOr: (halfword bitShift: 16)! !

!Color methodsFor: 'conversions'!
                              pixelWordForDepth: depth
	"Return to a 32-bit word that concatenates enough copies of the receiver's pixel value to fill the word (i.e., 32/depth copies). Depth should be one of 1, 2, 4, 8, 16, or 32. The pixel value should be an integer in 0..2^depth-1."

	| pixelValue |
	pixelValue _ self pixelValueForDepth: depth.
	^ self pixelWordFor: depth filledWith: pixelValue
! !

!Color methodsFor: 'equality' stamp: 'jmv 6/18/2017 20:38:11'!
          diff: theOther
	"Returns a number between 0.0 and 1.0.
	Color gray diff: Color red
	"
	^(self - theOther ) abs sum / self size! !

!Color methodsFor: 'equality' stamp: 'KenD 12/8/2013 08:35'!
rgbDistance: otherColor
	"Compare two colors in distance"
"
	^ (self hue - otherColor hue) abs +
	  (self saturation - otherColor saturation) abs *10 +
	  (self brightness - otherColor brightness) abs
"
	"See http://www.compuphase.com/cmetric.htm"
	| meanRed deltaRed deltaGreen deltaBlue |
	meanRed := (self red + otherColor red) abs / 2.
	deltaRed := (self red - otherColor red) abs.
	deltaGreen := (self green - otherColor green) abs.
	deltaBlue := (self blue - otherColor blue) abs.
	
	^ ( ((2 + (meanRed / 256)) * (deltaRed * deltaRed)) +
		(4 * deltaGreen) +
		((2 + ((255 - meanRed) / 256)) * deltaBlue)
	  ) sqrt! !

!Color methodsFor: 'groups of shades' stamp: 'tk 6/18/96'!
                    darkShades: thisMany
	"An array of thisMany colors from black to the receiver.  Array is of length num. Very useful for displaying color based on a variable in your program.  "
	"Color showColors: (Color red darkShades: 12)"

	^ self class black mix: self shades: thisMany
! !

!Color methodsFor: 'groups of shades' stamp: 'tk 6/18/96'!
               lightShades: thisMany
	"An array of thisMany colors from white to self. Very useful for displaying color based on a variable in your program.  "
	"Color showColors: (Color red lightShades: 12)"

	^ self class white mix: self shades: thisMany
! !

!Color methodsFor: 'groups of shades' stamp: 'tk 6/18/96'!
              mix: color2 shades: thisMany
	"Return an array of thisMany colors from self to color2. Very useful for displaying color based on a variable in your program.  "
	"Color showColors: (Color red mix: Color green shades: 12)"

	| redInc greenInc blueInc rr gg bb c out |
	thisMany = 1 ifTrue: [^ Array with: color2].
	redInc _ color2 red - self red / (thisMany-1).
	greenInc _ color2 green - self green / (thisMany-1).
	blueInc _ color2 blue - self blue / (thisMany-1).
	rr _ self red.  gg _ self green.  bb _ self blue.
	out _ (1 to: thisMany) collect: [:num |
		c _ Color r: rr g: gg b: bb.
		rr _ rr + redInc.
		gg _ gg + greenInc.
		bb _ bb + blueInc.
		c].
	out at: out size put: color2.	"hide roundoff errors"
	^ out
! !

!Color methodsFor: 'groups of shades' stamp: 'di 10/23/2000 09:45'!
         wheel: thisMany
	"An array of thisMany colors around the color wheel starting at self and ending all the way around the hue space just before self.  Array is of length thisMany.  Very useful for displaying color based on a variable in your program.  "

	| sat bri hue step c |
	sat _ self saturation.
	bri _ self brightness.
	hue _ self hue.
	step _ 360.0 / (thisMany max: 1).
	^ (1 to: thisMany) collect: [:num |
		c _ Color h: hue s: sat v: bri.  "hue is taken mod 360"
		hue _ hue + step.
		c].
"
(Color wheel: 8) withIndexDo: [:c :i | Display fill: (i*10@20 extent: 10@20) fillColor: c]
"! !

!Color methodsFor: 'named colors' stamp: 'KenD 12/8/2013 14:59'!
          closestAssocFrom: aColorDict
	"Answer closest associated color in aColorDict"
"
	((Color r: 0.3 g: 0.2 b: 0.8) closestAssocFrom: (Color colorNamesDict)) explore.
"
	"Filter values for those close in hue (cheap test) then use rgbDistance"
	| closeInHue isClose close distance myHue |
	closeInHue := OrderedCollection new.
	myHue := self hue.
	isClose := [ :assoc | | delta |
		delta := ((assoc value hue) - myHue) abs.
		(delta < 20) or: [ delta > 340 ] "hues within 20 degrees"
	].
	aColorDict  associationsDo:  [ :assoc |
		(isClose value: assoc) ifTrue: [ closeInHue add: assoc ]
	].

	close := nil.
	distance := 1000. "big"
	(closeInHue size > 0)
		ifFalse: [ "fallback -- no color really close"
			aColorDict  associationsDo:  [ :assoc | | dist |
				dist := self rgbDistance: (assoc value). 
				(dist < distance)  ifTrue: [distance := dist. close := assoc]
				]
		]
		ifTrue: [ closeInHue do: [ :assoc | | dist |
				dist := self rgbDistance: (assoc value). 
				(dist < distance)  ifTrue: [distance := dist. close := assoc]
				]
		].
	
	^ close! !

!Color methodsFor: 'named colors' stamp: 'KenD 1/26/2013 16:33'!
                             closestColor
	"Answer the closest matching color in the colorNames dictionary"

"
	(Color red lighter lighter) closestColor explore.
"
	^ self closestColorFrom: (Color colorNamesDict)! !

!Color methodsFor: 'named colors' stamp: 'KenD 1/26/2013 16:36'!
   closestColorAssociation
	"Answer this color's closest name->color match."

"
	(Color blue lighter lighter) closestColorAssociation explore.
"	
	^ self closestAssocFrom: (Color colorNamesDict)! !

!Color methodsFor: 'named colors' stamp: 'KenD 1/25/2013 14:31'!
                           closestColorFrom: aColorDict
	"Answer closest associated color"
"
	((Color lightBlue) closestColorFrom: (Color css2NamedColors)) explore..
"
	^(self closestAssocFrom: aColorDict) value! !

!Color methodsFor: 'named colors' stamp: 'KenD 1/26/2013 16:36'!
  closestColorName
	"Answer the name symbol of the closest matching color in the colorNames dictionary"
"
	(Color red lighter lighter) closestColor name.
"
	
	^ self closestNameFrom: (Color colorNamesDict)! !

!Color methodsFor: 'named colors' stamp: 'KenD 1/26/2013 16:36'!
               closestNameFrom: aColorDict
	"Answer closest associated color name"
"
	((Color lightBlue) closestNameFrom: (Color namedColors)) print.
"
	^(self closestAssocFrom: aColorDict) key! !

!Color methodsFor: 'other' stamp: 'KenD 7/18/2015 20:41'!
               colorName
	"Return this color's name, or nil if it has no name. Only returns a name if it exactly matches the named color."

	^(Color colorNamesDict keyAtValue: self  ifAbsent: [nil])
! !

!Color methodsFor: 'other' stamp: 'KenD 7/18/2015 20:46'!
         name
	"Return this color's name, or description if unnamed."

	^ self printString
! !

!Color methodsFor: 'printing' stamp: 'jmv 2/13/2014 13:41'!
             hexStringRGB
	"
	Color fromUser hexStringRGB
	"
	^String streamContents: [ :strm |
		(self red * 255) rounded printOn: strm base: 16 length: 2 padded: true.
		(self green * 255) rounded printOn: strm base: 16 length: 2 padded: true.
		(self blue * 255) rounded printOn: strm base: 16 length: 2 padded: true ]! !

!Color methodsFor: 'printing' stamp: 'KenD 7/18/2015 20:42'!
          printOn: aStream
	 self colorName ifNotNil: [ :name |
		^ aStream
			nextPutAll: 'Color ';
			nextPutAll: name].
	self storeOn: aStream.
! !

!Color methodsFor: 'printing' stamp: 'KenD 7/18/2015 20:44'!
                     printString
	"Answer a String whose characters are a description of the receiver."
	
	^ String streamContents: [ :stream | self printOn: stream ]! !

!Color methodsFor: 'printing' stamp: 'mir 7/21/1999 11:41'!
              storeArrayOn: aStream

	aStream nextPutAll: '#('.
	self storeArrayValuesOn: aStream.
	aStream nextPutAll: ') '
! !

!Color methodsFor: 'printing' stamp: 'jmv 1/5/2014 21:04'!
                 storeArrayValuesOn: aStream


	self red printOn: aStream fractionDigits: 3.
	aStream space.
	self green printOn: aStream fractionDigits: 3.
	aStream space.
	self blue printOn: aStream fractionDigits: 3

! !

!Color methodsFor: 'printing' stamp: 'jmv 1/5/2014 21:01'!
                     storeOn: aStream

	aStream
		nextPut: $(;
		nextPutAll: self class name;
		nextPutAll: ' r: '.
	self red printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ' g: '.
	self green printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ' b: '.
	self blue printOn: aStream fractionDigits: 3.
	aStream nextPut: $)! !

!Color methodsFor: 'queries' stamp: 'jmv 6/18/2017 20:40:55'!
   isBlack
	"Return true if the receiver represents black"
	(self at: 1) = 0.0 ifFalse: [ ^ false ].
	(self at: 2) = 0.0 ifFalse: [ ^ false ].
	(self at: 3) = 0.0 ifFalse: [ ^ false ].
	^ true! !

!Color methodsFor: 'queries' stamp: 'ar 4/20/2001 04:33'!
    isOpaque
	^true! !

!Color methodsFor: 'queries'!
              isTransparent

	^ false
! !

!Color methodsFor: 'queries' stamp: 'jmv 6/18/2017 20:40:46'!
     isWhite
	"Return true if the receiver represents white"
	(self at: 1) = 1.0 ifFalse: [ ^ false ].
	(self at: 2) = 1.0 ifFalse: [ ^ false ].
	(self at: 3) = 1.0 ifFalse: [ ^ false ].
	^ true! !

!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:35'!
isBlue
	"Am I considered Blue?"

	^self blue > (self green + 0.3)
		and: [self blue > (self red + 0.3)]
			and: [(self green - self red) abs < 0.4]! !

!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:37'!
          isBlueGreen
	"Am I considered BlueGreen ?"

	^self green > self red 
		and: [self red < 0.3]
			and: [(self green - self blue) abs < 0.1]! !

!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:50'!
                    isBright
	"Am I considered a Bright color ?"

	^self brightness > 0.6! !

!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:40'!
                        isBrown
	"Am I considered Brown ?"

	^self red >= self green  
		and: [self green > self blue]					
			and: [(self red - self green) < 0.5]	
				and: [(self green - self blue) < 0.3]! !

!Color methodsFor: 'selection' stamp: 'jmv 4/19/2013 17:14'!
        isCyan
	"Am I considered Cyan ?"

	^self red < 0.05 
		and: [(self green min: self blue) > 0.5]					
			and: [(self green - self blue) abs < 0.2]! !

!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:50'!
            isDark
	"Am I considered a Dark color ?"

	^self brightness < 0.5! !

!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:42'!
                            isGray
	"Am I considered Gray  ?"

	^(self red closeTo: self green)
		and: [self blue closeTo: self green ]! !

!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:38'!
                  isGreen
	"Am I considered Green ?"

	^self green > (self blue + 0.3)
		and: [self blue > (self red + 0.3)]! !

!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:40'!
                   isGrey
	"Am I considered Grey  ?"

	^self isGray! !

!Color methodsFor: 'selection' stamp: 'jmv 4/19/2013 17:06'!
              isLight
	"Am I considered a Light color ?"

	^self brightness > 0.6! !

!Color methodsFor: 'selection' stamp: 'jmv 4/19/2013 17:13'!
                           isMagenta
	"Am I considered Magenta ?"

	^self green < 0.05 
		and: [(self red min: self blue) > 0.5]					
			and: [(self red - self blue) abs < 0.2]! !

!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:44'!
        isOrange
	"Am I considered Orange ?"

	^self red > ((self green max: self blue) + 0.2)  
		and: [self green > (self blue + 0.2)]! !

!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:45'!
                             isPastel
	"Am I considered Pastel ?"

	^self saturation < 0.4! !

!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:46'!
isPink
	"Am I considered Pink ?"

	^self red > ((self green max: self blue) + 0.3)  
		and: [self blue > (self green + 0.2)]! !

!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:47'!
 isRed
	"Am I considered Red ?"

	^self red > (self green + 0.4)
		and: [self red > (self blue + 0.6)]
			and: [(self green - self blue) abs < 0.4]! !

!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:55'!
           isSaturated
	"Am I considered to be a Saturated color ?"

	^self saturation > 0.6! !

!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:49'!
            isYellow
	"Am I considered Yellow ?"

	^self blue < 0.05 
		and: [(self red min: self green) > 0.5]					
			and: [(self red - self green) abs < 0.2]! !

!Color methodsFor: 'testing' stamp: 'jmv 12/2/2010 08:38'!
            is: aSymbol
	^ aSymbol == #Color or: [ super is: aSymbol ]! !

!Color methodsFor: 'testing' stamp: 'jmv 2/10/2011 21:46'!
      mightBeTranslucent
	"For Colors, answer if actually translucent or not."
	^self isOpaque not! !

!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:56:14'!
                         * aNumber
	"Answer this color with its RGB multiplied by the given number. "
	"
	(Color brown *2) display
	"
	^ (Color new
		setRed: (self red * aNumber min: 1.0 max: 0.0)
		green: (self green * aNumber min: 1.0 max: 0.0)
		blue: (self blue * aNumber min: 1.0 max: 0.0))
			alpha: self alpha! !

!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:56:18'!
                  + aColor
	"Answer this color mixed with the given color in an additive color space.  "
	"
	(Color blue + Color green) display
	"
	^ Color new
		setRed: (self red + aColor red min: 1.0 max: 0.0)
		green: (self green + aColor green min: 1.0 max: 0.0)
		blue: (self blue + aColor blue min: 1.0 max: 0.0)! !

!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:56:22'!
         - aColor
	"Answer aColor is subtracted from the given color in an additive color space.  "
	"
	(Color white - Color red) display
	"
	^ Color new
		setRed: (self red - aColor red min: 1.0 max: 0.0)
		green: (self green - aColor green min: 1.0 max: 0.0)
		blue: (self blue - aColor blue min: 1.0 max: 0.0)! !

!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:56:26'!
      / aNumber
	"Answer this color with its RGB divided by the given number. "
	"
	(Color red / 2) display
	"
	^ Color new
		setRed: (self red / aNumber min: 1.0 max: 0.0)
		green: (self green / aNumber min: 1.0 max: 0.0)
		blue: (self blue / aNumber min: 1.0 max: 0.0)! !

!Color methodsFor: 'transformations' stamp: 'dew 3/19/2002 23:50'!
                adjustBrightness: brightness
	"Adjust the relative brightness of this color. (lowest value is 0.005 so that hue information is not lost)"

	^ Color
		h: self hue
		s: self saturation
		v: (self brightness + brightness min: 1.0 max: 0.005)
		alpha: self alpha! !

!Color methodsFor: 'transformations' stamp: 'dew 3/19/2002 23:51'!
                      adjustSaturation: saturation brightness: brightness
	"Adjust the relative saturation and brightness of this color. (lowest value is 0.005 so that hue information is not lost)"

	^ Color
		h: self hue
		s: (self saturation + saturation min: 1.0 max: 0.005)
		v: (self brightness + brightness min: 1.0 max: 0.005)
		alpha: self alpha! !

!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:10:41'!
          alpha: alphaValue
	"Return a new TranslucentColor with the given amount of opacity ('alpha')."
	alphaValue = 1.0 ifFalse: [
		^ TranslucentColor new
			setRed: self red
			green: self green
			blue: self blue
			alpha: alphaValue ]! !

!Color methodsFor: 'transformations' stamp: 'tk 7/4/2000 11:55'!
                   alphaMixed: proportion with: aColor 
	"Answer this color mixed with the given color. The proportion, a number 
	between 0.0 and 1.0, determines what what fraction of the receiver to  
	use in the mix. For example, 0.9 would yield a color close to the  
	receiver. This method uses RGB interpolation; HSV interpolation can lead 
	to surprises.  Mixes the alphas (for transparency) also."

	| frac1 frac2 |
	frac1 _ proportion asFloat min: 1.0 max: 0.0.
	frac2 _ 1.0 - frac1.
	^ Color
		r: self red * frac1 + (aColor red * frac2)
		g: self green * frac1 + (aColor green * frac2)
		b: self blue * frac1 + (aColor blue * frac2)
		alpha: self alpha * frac1 + (aColor alpha * frac2)! !

!Color methodsFor: 'transformations' stamp: 'RAA 6/2/2000 08:47'!
                     atLeastAsLuminentAs: aFloat

	| revisedColor |
	revisedColor _ self.
	[revisedColor luminance < aFloat] whileTrue: [revisedColor _ revisedColor slightlyLighter].
	^revisedColor
! !

!Color methodsFor: 'transformations' stamp: 'nk 3/8/2004 09:43'!
         atMostAsLuminentAs: aFloat

	| revisedColor |
	revisedColor _ self.
	[revisedColor luminance > aFloat] whileTrue: [revisedColor _ revisedColor slightlyDarker].
	^revisedColor
! !

!Color methodsFor: 'transformations' stamp: 'dew 3/23/2002 01:38'!
         blacker

	^ self alphaMixed: 0.8333 with: Color black
! !

!Color methodsFor: 'transformations' stamp: 'dew 3/19/2002 23:54'!
  dansDarker
	"Return a darker shade of the same color.
	An attempt to do better than the current darker method.
	(now obsolete, since darker has been changed to do this. -dew)"
	^ Color h: self hue s: self saturation
		v: (self brightness - 0.16 max: 0.0)! !

!Color methodsFor: 'transformations' stamp: 'dew 3/4/2002 01:40'!
                           darker
	"Answer a darker shade of this color."

	^ self adjustBrightness: -0.08! !

!Color methodsFor: 'transformations' stamp: 'dew 3/8/2002 00:13'!
          duller

	^ self adjustSaturation: -0.03 brightness: -0.2! !

!Color methodsFor: 'transformations' stamp: 'dew 1/23/2002 20:19'!
lighter
	"Answer a lighter shade of this color."

	^ self adjustSaturation: -0.03 brightness: 0.08! !

!Color methodsFor: 'transformations' stamp: 'tk 7/4/2000 12:00'!
                        mixed: proportion with: aColor 
	"Mix with another color and do not preserve transpareny.  Only use this for extracting the RGB value and mixing it.  All other callers should use instead: 
	aColor alphaMixed: proportion with: anotherColor
	"

	| frac1 frac2 |
	frac1 _ proportion asFloat min: 1.0 max: 0.0.
	frac2 _ 1.0 - frac1.
	^ Color
		r: self red * frac1 + (aColor red * frac2)
		g: self green * frac1 + (aColor green * frac2)
		b: self blue * frac1 + (aColor blue * frac2)! !

!Color methodsFor: 'transformations' stamp: 'dew 1/19/2002 01:29'!
                          muchDarker

	^ self alphaMixed: 0.5 with: Color black
! !

!Color methodsFor: 'transformations' stamp: 'tk 7/4/2000 12:07'!
    muchLighter

	^ self alphaMixed: 0.233 with: Color white
! !

!Color methodsFor: 'transformations' stamp: 'ar 6/19/1999 00:36'!
negated
	"Return an RGB inverted color"
	^Color
		r: 1.0 - self red
		g: 1.0 - self green
		b: 1.0 - self blue! !

!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:37:53'!
       orColorUnlike: theOther
	"If this color is a lot like theOther, then return its complement, otherwide, return self"

	^ (self diff: theOther) < 0.3
		ifTrue: [theOther negated]
		ifFalse: [self]! !

!Color methodsFor: 'transformations' stamp: 'dew 3/4/2002 01:42'!
                       paler
	"Answer a paler shade of this color."

	^ self adjustSaturation: -0.09 brightness: 0.09
! !

!Color methodsFor: 'transformations' stamp: 'jmv 9/10/2009 18:41'!
                         quiteBlacker

	^ self alphaMixed: 0.8 with: Color black
! !

!Color methodsFor: 'transformations' stamp: 'jmv 9/10/2009 18:44'!
quiteWhiter

	^ self alphaMixed: 0.6 with: Color white! !

!Color methodsFor: 'transformations' stamp: 'dew 3/4/2002 01:43'!
   slightlyDarker

	^ self adjustBrightness: -0.03
! !

!Color methodsFor: 'transformations' stamp: 'dew 3/4/2002 01:43'!
         slightlyLighter

	^ self adjustSaturation: -0.01 brightness: 0.03! !

!Color methodsFor: 'transformations' stamp: 'dew 1/19/2002 01:25'!
                       slightlyWhiter

	^ self alphaMixed: 0.85 with: Color white
! !

!Color methodsFor: 'transformations' stamp: 'jmv 5/7/2012 15:05'!
                              twiceDarker
	"Answer a significantly darker shade of this color."

	^ self adjustSaturation: 0.076 brightness: -0.15! !

!Color methodsFor: 'transformations' stamp: 'dew 3/4/2002 01:45'!
     twiceLighter
	"Answer a significantly lighter shade of this color."

	^ self adjustSaturation: -0.06 brightness: 0.15! !

!Color methodsFor: 'transformations' stamp: 'jmv 8/23/2009 23:24'!
   veryMuchDarker

	^ self alphaMixed: 0.25 with: Color black
! !

!Color methodsFor: 'transformations' stamp: 'jmv 7/28/2016 15:43:04'!
                          veryMuchLighter

	^ self alphaMixed: 0.07 with: Color white! !

!Color methodsFor: 'transformations' stamp: 'dew 3/23/2002 01:38'!
                             whiter

	^ self alphaMixed: 0.8333 with: Color white
! !

!Color methodsFor: 'private'!
        attemptToMutateError
	"A color is immutable. Once a color's red, green, and blue have been initialized, you cannot change them. Instead, create a new Color and use it."

	self error: 'Color objects are immutable once created'
! !

!Color methodsFor: 'private' stamp: 'jmv 6/18/2017 20:29:32'!
                           basicSetRed: r green: g blue: b
	"Initialize this color's r, g, and b components to the given values in the range [0.0..1.0]."

	self
		at: 1 put: r;
		at: 2 put: g;
		at: 3 put: b! !

!Color methodsFor: 'private' stamp: 'jmv 6/18/2017 20:15:44'!
         setHue: hue chroma: chroma brightness: brightness
	"Initialize this color to the given hue, chroma, and luma. See the comment in the instance creation method for details.
	http://en.wikipedia.org/wiki/HSL_and_HSV
		hue belongs in [0.0, 360.0)
		chroma and luma belongs in [0.0, 1.0]
	"

	| x hf i r1 g1 b1 m | 
	hf _ hue \\ 360.
	i _ hf // 60.  				"integer part of hue"
	x _ (hf \\ 60) / 60.0 .         		"fractional part of hue"
	x _ x \\  2 .
	i \\ 2 = 1 ifTrue: [ x _ 1.0 - x ].
	x _ chroma  * x.

	0 = i ifTrue: [ r1 _ chroma. g1 _ x. b1 _ 0.0 ].
	1 = i ifTrue: [ r1 _ x. g1 _ chroma. b1 _ 0.0 ].
	2 = i ifTrue: [ r1 _ 0.0. g1 _ chroma. b1 _ x ].
	3 = i ifTrue: [ r1 _ 0.0. g1 _ x. b1 _ chroma ].
	4 = i ifTrue: [ r1 _ x. g1 _ 0.0. b1 _ chroma ].
	5 = i ifTrue: [ r1 _ chroma. g1 _ 0.0. b1 _ x ].

	m _ brightness - ((r1 max: g1) max: b1).
	m < 0.0
		ifTrue: [ ^nil ]. "No color exists with required parameters"
	r1 _ r1 + m.
	r1 > 1.0
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	g1 _ g1 + m.
	g1 > 1.0
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	b1 _ b1 + m.
	b1 > 1.0
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	self setRed: r1 green: g1 blue: b1! !

!Color methodsFor: 'private' stamp: 'jmv 6/18/2017 20:15:49'!
                             setHue: hue chroma: chroma luminance: luma
	"Initialize this color to the given hue, chroma, and luma. See the comment in the instance creation method for details.
	http://en.wikipedia.org/wiki/HSL_and_HSV
		hue belongs in [0.0, 360.0)
		chroma and luma belongs in [0.0, 1.0]
	"

	| x hf i r1 g1 b1 m | 

	hf _ hue \\ 360.
	i _ hf // 60.  				"integer part of hue"
	x _ (hf \\ 60) / 60.0 .         		"fractional part of hue"
	x _ x \\  2 .
	i \\ 2 = 1 ifTrue: [ x _ 1.0 - x ].
	x _ chroma  * x.

	0 = i ifTrue: [ r1 _ chroma. g1 _ x. b1 _ 0.0 ].
	1 = i ifTrue: [ r1 _ x. g1 _ chroma. b1 _ 0.0 ].
	2 = i ifTrue: [ r1 _ 0.0. g1 _ chroma. b1 _ x ].
	3 = i ifTrue: [ r1 _ 0.0. g1 _ x. b1 _ chroma ].
	4 = i ifTrue: [ r1 _ x. g1 _ 0.0. b1 _ chroma ].
	5 = i ifTrue: [ r1 _ chroma. g1 _ 0.0. b1 _ x ].

	m _ luma - (0.299*r1) - (0.587*g1) - (0.114*b1).
	m < 0.0
		ifTrue: [ ^nil ]. "No color exists with required parameters"
	r1 _ r1 + m.
	r1 > 1.0 
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	g1 _ g1 + m.
	g1 > 1.0
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	b1 _ b1 + m.
	b1 > 1.0
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	self setRed: r1 green: g1 blue: b1! !

!Color methodsFor: 'private' stamp: 'jmv 6/18/2017 20:16:07'!
                          setHue: hue saturation: saturation brightness: brightness
	"Initialize this color to the given hue, saturation, and brightness. See the comment in the instance creation method for details."

	| s v hf i f p q t | 
	s _ saturation asFloat min: 1.0 max: 0.0.
	v _ brightness asFloat min: 1.0 max: 0.0.
	hf _ hue \\ 360.
	i _ hf // 60.  			"integer part of hue"
	f _ (hf \\ 60) / 60.0.         	"fractional part of hue"

	p _ (1.0 - s) * v.
	q _ (1.0 - (s * f)) * v.
	t _ (1.0 - (s * (1.0 - f))) * v.

	0 = i ifTrue: [ ^ self setRed: v green: t blue: p ].
	1 = i ifTrue: [ ^ self setRed: q green: v blue: p ].
	2 = i ifTrue: [ ^ self setRed: p green: v blue: t ].
	3 = i ifTrue: [ ^ self setRed: p green: q blue: v ].
	4 = i ifTrue: [ ^ self setRed: t green: p blue: v ].
	5 = i ifTrue: [ ^ self setRed: v green: p blue: q ].

	self error: 'implementation error'! !

!Color methodsFor: 'private' stamp: 'jmv 6/18/2017 20:13:04'!
  setRed: r green: g blue: b

	self basicSetRed: r green: g blue: b! !

!Color methodsFor: 'private' stamp: 'jmv 6/18/2017 20:29:48'!
                            setRed: r green: g blue: b range: range
	"Initialize this color's r, g, and b components to the given values in the range [0..r]."

	self basicSetRed: r green: g blue: b.
	self /= range! !

!Color methodsFor: 'as yet unclassified' stamp: 'jmv 8/15/2015 18:23'!
                           color
	^ self! !

!Color methodsFor: 'as yet unclassified' stamp: 'jmv 6/22/2017 12:54:10'!
    convertToCurrentVersion: varDict refStream: smartRefStrm

	"subclasses should implement if they wish to convert old instances to modern ones"
	self size = 0 ifTrue: [
		^ Color new copyFrom: (varDict at: 'floatRGB') ].
	^ self! !

!Color commentStamp: 'jmv 6/18/2017 20:14:31' prior: 0!
 This class represents abstract color, regardless of the depth of bitmap it will be shown in.  At the very last moment a Color is converted to a pixelValue that depends on the depth of the actual Bitmap inside the Form it will be used with.  The supported depths (in bits) are 1, 2, 4, 8, 16, and 32.  The number of actual colors at these depths are: 2, 4, 16, 256, 32768, and 16 million.  (See comment in BitBlt.)  To change the depth of the Display and set how many colors you can see, execute: (Display newDepth: 8).  (See comment in DisplayMedium)
	Color is represented as the amount of light in red, green, and blue.  White is (1.0, 1.0, 1.0) and black is (0, 0, 0).  Pure red is (1.0, 0, 0).  These colors are "additive".  Think of Color's instance variables as:
	r	amount of red, a Float between 0.0 and 1.0.
	g	amount of green, a Float between 0.0 and 1.0.
	b	amount of blue, a Float between 0.0 and 1.0.
	Many colors are named.  You find a color by name by sending a message to class Color, for example (Color lightBlue).  Also, (Color red: 0.2 green: 0.6 blue: 1.0) or (Color r: 0.2 g: 0.6 b: 1.0) creates a color. (see below)
	A color is essentially immutable.  Once you set red, green, and blue, you cannot change them.  Instead, create a new Color and use it.
	Applications such as contour maps and bar graphs will want to display one of a set of shades based on a number.  Convert the range of this number to an integer from 1 to N.  Then call (Color green lightShades: N) to get an Array of colors from white to green.  Use the Array messages at:, atPin:, or atWrap: to pull out the correct color from the array.  atPin: gives the first (or last) color if the index is out of range.  atWrap: wraps around to the other end if the index is out of range.
	Here are some fun things to run in when your screen has color:
		Pen new mandala: 30 diameter: Display height-100.
		Pen new web  "Draw with the mouse, opt-click to end"
		Display fillWhite.  Pen new hilberts: 5.
		Form toothpaste: 30  "Draw with mouse, opt-click to end"

Messages:
	mixed: proportion with: aColor	Answer this color mixed with the given color additively. The proportion, a number between 0.0 and 1.0, determines what what fraction of the receiver to use in the mix.

	+ 	add two colors
	- 	subtract two colors
	*	multiply the values of r, g, b by a number or an Array of factors.  ((Color named: #white) * 0.3) gives a darkish gray.  (aColor * #(0 0 0.9)) gives a color with slightly less blue.
	/	divide a color by a factor or an array of three factors.

	hue			Returns the hue of the color. On a wheel from 0 to 360 with pure red at 0 and again at 360.
	saturation	Returns the saturation of the color.  0.0 to 1.0
	brightness	Returns the brightness of the color.  0.0 to 1.0

	name    Look to see if this Color has a name.
	display	Show a swatch of this color tracking the cursor.

	lightShades: thisMany		An array of thisMany colors from white to the receiver. 
	darkShades: thisMany		An array of thisMany colors from black to the receiver.  Array is of length num.
	mix: color2 shades: thisMany		An array of thisMany colors from the receiver to color2.
	wheel: thisMany			An array of thisMany colors around the color wheel starting and ending at the receiver.

	pixelValueForDepth: d    Returns the bits that appear be in a Bitmap of this depth for this color.  Represents the nearest available color at this depth.  Normal users do not need to know which pixelValue is used for which color. 

Messages to Class Color.
	red: r green: g blue: b		Return a color with the given r, g, and b components.
	r: g: b:		Same as above, for fast typing.

 	hue: h saturation: s brightness: b		Create a color with the given hue, saturation, and brightness.

	pink
 	blue
	red ...	Many colors have messages that return an instance of Color.
	canUnderstand: #brown	  Returns true if #brown is a defined color.
	names		An OrderedCollection of the names of the colors.
	named: #notAllThatGray put: aColor    Add a new color to the list and create an access message and a class variable for it.
	fromUser	Shows the palette of colors available at this display depth.  Click anywhere to return the color you clicked on.

	hotColdShades: thisMany	An array of thisMany colors showing temperature from blue to red to white hot.

    stdColorsForDepth: d        An Array of colors available at this depth.  For 16 bit and 32 bits, returns a ColorGenerator.  It responds to at: with a Color for that index, simulating a very big Array. 

   colorFromPixelValue: value depth: d    Returns a Color whose bit pattern (inside a Bitmap) at this depth is the number specified.  Normal users do not need to use this.

(See also comments in these classes: Form, Bitmap, BitBlt)

Default colorSpace is #sRGB. Subclasses might use other color spaces!

Color class
	instanceVariableNames: ''!

!Color class methodsFor: 'instance creation' stamp: 'jmv 9/17/2015 15:22'!
       clipR: r g: g b: b
	"Return a color with the given r, g, and b components in the range [0.0..1.0].
	Clip if necessary"

	^ self 
		r: (r min: 1.0 max: 0.0)
		g: (g min: 1.0 max: 0.0)
		b: (b min: 1.0 max: 0.0)! !

!Color class methodsFor: 'instance creation' stamp: 'jmv 4/2/2016 23:05'!
colorFrom: parm
	"Return an instantiated color from parm.  If parm is already a color, return it, else return the result of my performing it if it's a symbol or, if it is a list, it can either be an array of three numbers, which will be interpreted as RGB values, or a list of symbols, the first of which is sent to me and then the others of which are in turn sent to the prior result, thus allowing entries of the form #(blue darker).  Else just return the thing"

	| aColor firstParm |
	(parm is: #Color) ifTrue: [ ^ parm ].
	parm isSymbol ifTrue: [ ^ self perform: parm ].
	(parm isSequenceableCollection and: [ parm size > 0 ])
		ifTrue: [
			firstParm _ parm first.
			firstParm isNumber ifTrue: [
				^ self fromRgbTriplet: parm].
			aColor _ self colorFrom: firstParm.
			parm withIndexDo: [ :sym :ind |
				ind > 1 ifTrue: [
					aColor _ aColor perform: sym ]].
			^ aColor].
	^ parm

"
Color colorFrom: #(blue darker)
Color colorFrom: Color blue darker
Color colorFrom: #blue
Color colorFrom: #(0.0 0.0 1.0)
"! !

!Color class methodsFor: 'instance creation' stamp: 'jmv 6/2/2016 15:04'!
                      colorFromPixelValue: p depth: d
	"Convert a pixel value for the given display depth into a color."
	"Details: For depths of 8 or less, the pixel value is simply looked up in a table. For greater depths, the color components are extracted and converted into a color."
	"Warning: In BitBlt, a pixel with pixelValue = 0 is transparent.
	Squeak usually assumes that r=g=b=0 => transparent. But this is false if we have alpha (opacity).
	A color with r=g=b=0 and opacity = 255 is BLACK, not TRANSPARENT.
	Squeak also answers darkest possible blue when asked for black. Again, this is not needed in 32 bits (with alpha). It is also not really needed for 16 bits as we have an extra, unused bit: 16r8000 is not zero, but rgb=0, and hence, black.
	The real rule is that pixelValue=0 means transparent.
	And that darkest blue must be used instead of black, but only for depths >8 and < 16 (no indexed colors, no alpha)
	This method is updated to reflect that."

	| r g b alpha |

	d = 1 ifTrue: [^ self indexedColors at: (p bitAnd: 16r01) + 1].

	"For the rest of the depths, pixelValue = 0 means transparent, and darkest blue is considered to be black."
	p = 0 ifTrue: [ ^Color transparent ].

	d = 8 ifTrue: [^ self indexedColors at: (p bitAnd: 16rFF) + 1].
	d = 4 ifTrue: [^ self indexedColors at: (p bitAnd: 16r0F) + 1].
	d = 2 ifTrue: [^ self indexedColors at: (p bitAnd: 16r03) + 1].

	d = 32 ifTrue: [
		"eight bits per component; 8 bits of alpha"
		alpha _ p bitShift: -24.
		alpha = 0 ifTrue: [ ^Color transparent ].
		r _ (p bitShift: -16) bitAnd: 16rFF.
		g _ (p bitShift: -8) bitAnd: 16rFF.
		b _ p bitAnd: 16rFF.
		^alpha < 255
			ifTrue: [ (Color r: r g: g b: b range: 255) alpha: alpha asFloat / 255.0 ]
			ifFalse: [ Color r: r g: g b: b range: 255 ]].

	d = 16 ifTrue: [
		"five bits per component. The most significant bit, unused, allows having real black, without p being zero"
		r _ (p bitShift: -10) bitAnd: 16r1F.
		g _ (p bitShift: -5) bitAnd: 16r1F.
		b _ p bitAnd: 16r1F.
		^ Color r: r g: g b: b range: 31].

	d = 15 ifTrue: [
		"five bits per component"
		r _ (p bitShift: -10) bitAnd: 16r1F.
		g _ (p bitShift: -5) bitAnd: 16r1F.
		b _ p bitAnd: 16r1F.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Color black ].
		^ Color r: r g: g b: b range: 31].

	d = 12 ifTrue: [
		"four bits per component"
		r _ (p bitShift: -8) bitAnd: 16rF.
		g _ (p bitShift: -4) bitAnd: 16rF.
		b _ p bitAnd: 16rF.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Color black ].
		^ Color r: r g: g b: b range: 15].

	d = 9 ifTrue: [
		"three bits per component"
		r _ (p bitShift: -6) bitAnd: 16r7.
		g _ (p bitShift: -3) bitAnd: 16r7.
		b _ p bitAnd: 16r7.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Color black ].
		^ Color r: r g: g b: b range: 7].

	self error: 'unknown pixel depth: ', d printString! !

!Color class methodsFor: 'instance creation' stamp: 'sqr 10/15/2016 20:41:04'!
      fromArray: colorDef

	| answer |
	colorDef size = 0 ifTrue: [^self transparent].
	colorDef size between: 3 and: 4 :: ifFalse: [self error: 'Undefined color definition'].
	answer _ self r: (colorDef at: 1) g: (colorDef at: 2) b: (colorDef at: 3).
	^colorDef size = 3
		ifTrue: [answer]
		ifFalse: [answer alpha: (colorDef at: 4)]! !

!Color class methodsFor: 'instance creation' stamp: 'sw 8/8/97 22:03'!
            fromRgbTriplet: list
	^ self r: list first g: list second b: list last! !

!Color class methodsFor: 'instance creation' stamp: 'pb 10/16/2016 18:42:44'!
       fromString: aString
	"For HTML color spec: #FFCCAA. Also support named colors.
	See http://www.w3schools.com/cssref/css_colors_legal.asp"
	"
	Color fromString: '#FFCCAA'.
	Color fromString: 'white'.
	Color fromString: 'orange'
	Color fromString: 'rgb(255,0,98)'
	"
	(aString size = 7 and: [ aString first = $# ]) ifTrue: [
		| aColorHexU red green blue |
		aColorHexU _ aString asUppercase.
		red _ ('16r', (aColorHexU copyFrom: 2 to: 3)) asNumber/255.
		green _ ('16r', (aColorHexU copyFrom: 4 to: 5)) asNumber/255.
		blue _ ('16r', (aColorHexU copyFrom: 6 to: 7)) asNumber/255.
		^ self r: red g: green b: blue].

	(aString beginsWith: 'rgb')
		ifTrue: [|values r g b|
				values := (aString allButFirst: 4) allButLast findTokens: ','.
				r  := (values first includes: $%)
						ifTrue: [(values first asNumber min: 100 max: 0) / 100.0]
						ifFalse: [(values first asInteger min: 255 max: 0) / 255.0].
				g := (values second includes: $%)
						ifTrue: [(values second asNumber min: 100 max: 0) / 100.0]
						ifFalse: [(values second asInteger min: 255 max: 0) / 255.0].
				b := (values third includes: $%)
						ifTrue: [(values third asNumber min: 100 max: 0) / 100.0]
						ifFalse: [(values third asInteger min: 255 max: 0) / 255.0].
				^self r: r g: g b: b].

	^self exactColorNamed: aString! !

!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:29'!
                    gray: brightness
	"Return a gray shade with the given brightness in the range [0.0..1.0]."

	^ self new
		setRed: brightness
		green: brightness
		blue: brightness! !

!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:31'!
          h: hue s: saturation v: brightness
	"Create a color with the given hue, saturation, and brightness. Hue is given as the angle in degrees of the color on the color circle where red is zero degrees. Saturation and brightness are numbers in [0.0..1.0] where larger values are more saturated or brighter colors. For example, (Color h: 0 s: 1 v: 1) is pure red."
	"Note: By convention, brightness is abbreviated 'v' to to avoid confusion with blue."

	^ self new setHue: hue saturation: saturation brightness: brightness! !

!Color class methodsFor: 'instance creation' stamp: 'dew 3/19/2002 23:49'!
             h: h s: s v: v alpha: alpha

	^ (self h: h s: s v: v) alpha: alpha! !

!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:34'!
           hue: hue chroma: chroma brightness: brightness
	^self new setHue: hue chroma: chroma brightness: brightness! !

!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:37'!
  hue: hue chroma: chroma luminance: luma
	^self new setHue: hue chroma: chroma luminance: luma! !

!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:39'!
                hue: hue saturation: saturation brightness: brightness
	"Create a color with the given hue, saturation, and brightness. Hue is given as the angle in degrees of the color on the color circle where red is zero degrees. Saturation and brightness are numbers in [0.0..1.0] where larger values are more saturated or brighter colors. For example, (Color h: 0 s: 1 v: 1) is pure red."
	"Note: By convention, brightness is abbreviated 'v' to to avoid confusion with blue."

	^ self new setHue: hue saturation: saturation brightness: brightness! !

!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:54:20'!
                      new
	^ self new: 3! !

!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:41'!
                           r: r g: g b: b
	"Return a color with the given r, g, and b components in the range [0.0..1.0]."

	^ self new
		setRed: r
		green: g
		blue: b! !

!Color class methodsFor: 'instance creation'!
r: r g: g b: b alpha: alpha

	^ (self r: r g: g b: b) alpha: alpha! !

!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:43'!
           r: r g: g b: b range: range
	"Return a color with the given r, g, and b components specified as integers in the range [0..r]. This avoids the floating point arithmetic in the red:green:blue: message and is thus a bit faster for certain applications (such as computing a sequence of colors for a palette)."

	^ self new setRed: r green: g blue: b range: range! !

!Color class methodsFor: 'instance creation' stamp: 'jmv 4/4/2015 20:30'!
           random
	"Return a random color that isn't too dark or under-saturated.
		Display fill: (10@10 extent: 200@200) fillColor: Color random
	"

	^ Random withDefaultDo: [ :random |
		self random: random ]! !

!Color class methodsFor: 'instance creation' stamp: 'jmv 4/4/2015 20:30'!
          random2
	"Return a random color with a distribution that spans over all possible colors.
		Display fill: (10@10 extent: 200@200) fillColor: Color random2
	"

	^ Random withDefaultDo: [ :random |
		self random2: random ]! !

!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:46'!
                  random2: aRandom
	"Return a random color with a distribution that spans over all possible colors."

	^ self new
		setRed: aRandom next
		green: aRandom next
		blue: aRandom next! !

!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:48'!
                            random: aRandom
	"Return a random color that isn't too dark or under-saturated."

	^ self new
		setHue: (360.0 * aRandom next)
		saturation: (0.3 + (aRandom next * 0.7))
		brightness: (0.4 + (aRandom next * 0.6))! !

!Color class methodsFor: 'class initialization' stamp: 'jmv 4/17/2015 15:06'!
                         initializeGrayToIndexMap
	"Build an array of gray values available in the 8-bit colormap. This array is indexed by a gray level between black (1) and white (256) and returns the pixel value for the corresponding gray level."
	"Note: This method must be called after initializeIndexedColors, since it uses IndexedColors."
	"
	Color initializeGrayToIndexMap
	"

	| grayLevels grayIndices c distToClosest dist indexOfClosest indexedColors |
	"record the level and index of each gray in the 8-bit color table"
	grayLevels _ OrderedCollection new.
	grayIndices _ OrderedCollection new.
	indexedColors _ self indexedColors.
	"Note: skip the first entry, which is reserved for transparent"
	2 to: indexedColors size do: [:i |
		c _ indexedColors at: i.
		c saturation = 0.0 ifTrue: [  "c is a gray"
			grayLevels add: (c green * 255) rounded.  "0 to 255; R, G, and B are the same"
			grayIndices add: i - 1]].  "pixel values are zero-based"
	grayLevels _ grayLevels asArray.
	grayIndices _ grayIndices asArray.

	"for each gray level in [0..255], select the closest match"
	GrayToIndexMap _ ByteArray new: 256.
	0 to: 255 do: [ :level |
		distToClosest _ 10000.  "greater than distance to any real gray"
		1 to: grayLevels size do: [:i |
			dist _ (level - (grayLevels at: i)) abs.
			dist < distToClosest ifTrue: [
				distToClosest _ dist.
				indexOfClosest _ grayIndices at: i]].
		GrayToIndexMap at: (level + 1) put: indexOfClosest]! !

!Color class methodsFor: 'class initialization'!
                    initializeIndexedColors
	"Build an array of colors corresponding to the fixed colormap used
	 for display depths of 1, 2, 4, or 8 bits."
	"Color initializeIndexedColors"

	| a index grayVal |
	a _ Array new: 256.

	"1-bit colors (monochrome)"
	a at: 1 put: (Color r: 1.0 g: 1.0 b: 1.0).		"white or transparent"
	a at: 2 put: (Color r: 0.0 g: 0.0 b: 0.0).	"black"

	"additional colors for 2-bit color"
	a at: 3 put: (Color r: 1.0 g: 1.0 b: 1.0).	"opaque white"
	a at: 4 put: (Color r: 0.5 g: 0.5 b: 0.5).	"1/2 gray"

	"additional colors for 4-bit color"
	a at:  5 put: (Color r: 1.0 g: 0.0 b: 0.0).	"red"
	a at:  6 put: (Color r: 0.0 g: 1.0 b: 0.0).	"green"
	a at:  7 put: (Color r: 0.0 g: 0.0 b: 1.0).	"blue"
	a at:  8 put: (Color r: 0.0 g: 1.0 b: 1.0).	"cyan"
	a at:  9 put: (Color r: 1.0 g: 1.0 b: 0.0).	"yellow"
	a at: 10 put: (Color r: 1.0 g: 0.0 b: 1.0).	"magenta"

	a at: 11 put: (Color r: 0.125 g: 0.125 b: 0.125).		"1/8 gray"
	a at: 12 put: (Color r: 0.25 g: 0.25 b: 0.25).		"2/8 gray"
	a at: 13 put: (Color r: 0.375 g: 0.375 b: 0.375).		"3/8 gray"
	a at: 14 put: (Color r: 0.625 g: 0.625 b: 0.625).		"5/8 gray"
	a at: 15 put: (Color r: 0.75 g: 0.75 b: 0.75).		"6/8 gray"
	a at: 16 put: (Color r: 0.875 g: 0.875 b: 0.875).		"7/8 gray"

	"additional colors for 8-bit color"
	"24 more shades of gray (1/32 increments but not repeating 1/8 increments)"
	index _ 17.
	1 to: 31 do: [:v |
		(v \\ 4) = 0 ifFalse: [
			grayVal _ v / 32.0.
			a at: index put: (Color r: grayVal g: grayVal b: grayVal).
			index _ index + 1]].

	"The remainder of color table defines a color cube with six steps
	 for each primary color. Note that the corners of this cube repeat
	 previous colors, but this simplifies the mapping between RGB colors
	 and color map indices. This color cube spans indices 40 through 255
	 (indices 41-256 in this 1-based array)."
	0 to: 5 do: [:r |
		0 to: 5 do: [:g |
			0 to: 5 do: [:b |
				index _ 41 + ((36 * r) + (6 * b) + g).
				index > 256 ifTrue: [
					self error: 'index out of range in color table compuation'].
				a at: index put: (Color r: r g: g b: b range: 5)]]].

	IndexedColors _ a.
! !

!Color class methodsFor: 'examples' stamp: 'jmv 8/17/2012 18:48'!
                   colorRampForDepth: depth extent: aPoint
	"Returns a form of the given size showing R, G, B, and gray ramps for the given depth. Useful for testing color conversions between different depths."
	"(Color colorRampForDepth: Display depth extent: 256@80) display"
	"(Color colorRampForDepth: 32 extent: 256@80) displayOn: Display at: 0@0 rule: Form paint"

	| f dx dy r |
	f _ Form extent: aPoint depth: depth.
	dx _ aPoint x // 256.
	dy _ aPoint y // 4.
	0 to: 255 do: [:i |
		r _ (dx * i)@0 extent: dx@dy.
		f fill: r fillColor: (Color r: i g: 0 b: 0 range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Color r: 0 g: i b: 0 range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Color r: 0 g: 0 b: i range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Color r: i g: i b: i range: 255)].
	^ f
! !

!Color class methodsFor: 'examples' stamp: 'jmv 6/18/2017 21:29:30'!
                             experimentsTowarsANewColorPalette
"
self experimentsTowarsANewColorPalette
"
| selectedHue selectedSaturation selectedV selectedColor h s v color width height selectedChroma selectedLuminance |
width _ 300.
height _ 120.
selectedColor _ Color random.
selectedHue _ selectedColor hue.
selectedSaturation _ selectedColor saturation.
selectedChroma _ selectedColor chroma.
selectedV _ selectedColor brightness.
selectedLuminance _ selectedColor luminance.
Display getCanvas fillRectangle: (0@0 extent: height@height) color: selectedColor.
0 to: height do: [ :y |
	v _ 1.0 - (y / height).
	0 to: height do: [ :x |
		s _ x / height.
		color _ Color new setHue: selectedHue saturation: s brightness: v.
		Display colorAt: x@(y+height) put: color
	].
	DisplayScreen screenUpdateRequired: nil
].
0 to: height do: [ :y | | c |
	v _ 1.0 - (y / height).
	s _ 1.0 - (y / height).
	c _ s.
	0 to: width do: [ :x |
		h _ x / width * 360.
		
		color _ Color new setHue: h chroma: c luminance: selectedLuminance.
"		color _ Color new setHue: h chroma: c brightness: selectedV."
		color ifNil: [ color _ Color black ].
"		color _ Color new setHue: h saturation: s brightness: selectedV."
		Display colorAt: x+height@y put: color.
		
		color _ Color new setHue: h chroma: selectedChroma luminance: v.
"		color _ Color new setHue: h chroma: selectedChroma brightness: v."
		color ifNil: [ color _ Color black ].
"		color _ Color new setHue: h saturation: selectedSaturation brightness: v."
		Display colorAt: x+height@(y+height) put: color.
		
	].
	DisplayScreen screenUpdateRequired: nil
].! !

!Color class methodsFor: 'examples' stamp: 'tk 6/19/96'!
                               hotColdShades: thisMany
	"An array of thisMany colors showing temperature from blue to red to white hot.  (Later improve this by swinging in hue.)  "
	"Color showColors: (Color hotColdShades: 25)"

	| n s1 s2 s3 s4 s5 |
	thisMany < 5 ifTrue: [^ self error: 'must be at least 5 shades'].
	n _ thisMany // 5.
	s1 _ self white mix: self yellow shades: (thisMany - (n*4)).
	s2 _ self yellow mix: self red shades: n+1.
	s2 _ s2 copyFrom: 2 to: n+1.
	s3 _ self red mix: self green darker shades: n+1.
	s3 _ s3 copyFrom: 2 to: n+1.
	s4 _ self green darker mix: self blue shades: n+1.
	s4 _ s4 copyFrom: 2 to: n+1.
	s5 _ self blue mix: self black shades: n+1.
	s5 _ s5 copyFrom: 2 to: n+1.
	^ s1, s2, s3, s4, s5
! !

!Color class methodsFor: 'examples'!
                      showColorCube
	"Show a 12x12x12 color cube."
	"Color showColorCube"

	0 to: 11 do: [:r |
		0 to: 11 do: [:g |
			0 to: 11 do: [:b |	
				Display fill: (((r*60) + (b*5)) @ (g*5) extent: 5@5)
					fillColor: (Color r: r g: g b: b range: 11)]]].
! !

!Color class methodsFor: 'examples' stamp: 'jmv 8/17/2012 18:48'!
      showColors: colorList
	"Display the given collection of colors across the top of the Display."

	| w r |
	w _ Display width // colorList size.
	r _ 0@0 extent: w@((w min: 30) max: 10).
	colorList do: [:c |
		Display fill: r fillColor: c.
		r _ r translatedBy: w@0].
! !

!Color class methodsFor: 'examples'!
            showHSVPalettes
	"Shows a palette of hues, varying the saturation and brightness for each one. Best results are with depths 16 and 32."
	"Color showHSVPalettes"

	| left top c |
	left _ top _ 0.
	0 to: 179 by: 15 do: [:h |
		0 to: 10 do: [:s |
			left _ (h * 4) + (s * 4).
			0 to: 10 do: [:v |
				c _ Color h: h s: s asFloat / 10.0 v: v asFloat / 10.0.
				top _ (v * 4).
				Display fill: (left@top extent: 4@4) fillColor: c.

				c _ Color h: h + 180 s: s asFloat / 10.0 v: v asFloat / 10.0.
				top _ (v * 4) + 50.
				Display fill: (left@top extent: 4@4) fillColor: c]]].
! !

!Color class methodsFor: 'examples' stamp: 'jmv 1/14/2013 21:12'!
                       showHuesInteractively
	"Shows a palette of hues at a (saturation, brightness) point determined by the mouse position. Click the mouse button to exit and return the selected (saturation, brightness) point."
	"Color showHuesInteractively"

	| p s v |
	[Sensor isAnyButtonPressed] whileFalse: [
		p _ Sensor mousePoint.
		s _ p x asFloat / 300.0.
		v _ p y asFloat / 300.0.
		self showColors: (self wheel: 12 saturation: s brightness: v)].
	^ (s min: 1.0) @ (v min: 1.0)! !

!Color class methodsFor: 'examples'!
   wheel: thisMany
	"Return a collection of thisMany colors evenly spaced around the color wheel."
	"Color showColors: (Color wheel: 12)"

	^ Color wheel: thisMany saturation: 0.9 brightness: 0.7
! !

!Color class methodsFor: 'examples'!
                     wheel: thisMany saturation: s brightness: v
	"Return a collection of thisMany colors evenly spaced around the color wheel, all of the given saturation and brightness."
	"Color showColors: (Color wheel: 12 saturation: 0.4 brightness: 1.0)"
	"Color showColors: (Color wheel: 12 saturation: 0.8 brightness: 0.5)"

	^ (Color h: 0.0 s: s v: v) wheel: thisMany
! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:58'!
                  aqua

	^ self colorNamesDict at: #aqua! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:58'!
               beige

	^ self colorNamesDict at: #beige! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:58'!
             black

	^ self colorNamesDict at: #black! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:58'!
             blue

	^ self colorNamesDict at: #blue! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:58'!
               brightGreen

	^ self colorNamesDict at: #brightGreen! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:58'!
 brown

	^ self colorNamesDict at: #brown! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
             cyan

	^ self colorNamesDict at: #cyan! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
               darkBlue

	^ self colorNamesDict at: #darkBlue! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
       darkGray

	^ self colorNamesDict at: #darkGray! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
       darkGreen

	^ self colorNamesDict at: #darkGreen! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
     darkPink

	^ self colorNamesDict at: #darkPink! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
       darkPurple

	^ self colorNamesDict at: #darkPurple! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
   forestGreen

	^ self colorNamesDict at: #forestGreen! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
 gray

	^ self colorNamesDict at: #gray! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
               green

	^ self colorNamesDict at: #green! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
             grey

	^ self colorNamesDict at: #grey! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
               hotPink

	^ self colorNamesDict at: #hotPink! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
         indigo

	^ self colorNamesDict at: #indigo! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
           lavender

	^ self colorNamesDict at: #lavender! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
       lightBlue

	^ self colorNamesDict at: #lightBlue! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
     lightBrown

	^ self colorNamesDict at: #lightBrown! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
   lightCyan

	^ self colorNamesDict at: #lightCyan! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
     lightGray

	^ self colorNamesDict at: #lightGray! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
     lightGreen

	^ self colorNamesDict at: #lightGreen! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
   lightMagenta

	^ self colorNamesDict at: #lightMagenta! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
                               lightOrange

	^ self colorNamesDict at: #lightOrange! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
 lightPink

	^ self colorNamesDict at: #lightPink! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
     lightPurple

	^ self colorNamesDict at: #lightPurple! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
 lightRed

	^ self colorNamesDict at: #lightRed! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
       lightYellow

	^ self colorNamesDict at: #lightYellow! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
 lilac

	^ self colorNamesDict at: #lilac! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
             lime

	^ self colorNamesDict at: #lime! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
               limeGreen

	^ self colorNamesDict at: #limeGreen! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
     magenta

	^ self colorNamesDict at: #magenta! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
         maroon

	^ self colorNamesDict at: #maroon! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
           mauve

	^ self colorNamesDict at: #mauve! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
             mustard

	^ self colorNamesDict at: #mustard! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
         navyBlue

	^ self colorNamesDict at: #navyBlue! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
       olive

	^ self colorNamesDict at: #olive! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
             oliveGreen

	^ self colorNamesDict at: #oliveGreen! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
   orange

	^ self colorNamesDict at: #orange! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
           paleGreen

	^ self colorNamesDict at: #paleGreen! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
     peach

	^ self colorNamesDict at: #peach! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
             periwinkle

	^ self colorNamesDict at: #periwinkle! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
   pink

	^ self colorNamesDict at: #pink! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
               purple

	^ self colorNamesDict at: #purple! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
           red

	^ self colorNamesDict at: #red! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
                 royalBlue

	^ self colorNamesDict at: #royalBlue! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
     salmon

	^ self colorNamesDict at: #salmon! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
           seaGreen

	^ self colorNamesDict at: #seaGreen! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
       skyBlue

	^ self colorNamesDict at: #skyBlue! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
         tan

	^ self colorNamesDict at: #tan! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
                 teal

	^ self colorNamesDict at: #teal! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
               transparent

	^ self colorNamesDict at: #transparent! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
 turquoise

	^ self colorNamesDict at: #turquoise! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
     veryDarkGray

	^ self colorNamesDict at: #veryDarkGray! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
                               veryLightGray

	^ self colorNamesDict at: #veryLightGray! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
                             veryVeryDarkGray

	^ self colorNamesDict at: #veryVeryDarkGray! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
                       veryVeryLightGray

	^ self colorNamesDict at: #veryVeryLightGray! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
                     violet

	^ self colorNamesDict at: #violet! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
           white

	^ self colorNamesDict at: #white! !

!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
             yellow

	^ self colorNamesDict at: #yellow! !

!Color class methodsFor: 'colormaps' stamp: 'jmv 5/12/2016 15:49'!
              cachedColormapForGrayFrom: sourceDepth
	"Return a cached colormap for mapping from the given depth to the 8bpp grays. Always return a real colormap, not nil; this allows the client to get an identity colormap that can then be copied and modified to do color transformations."
	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"
	"Note: The colormap cache may be cleared by evaluating 'Color shutDown'."
	"Note: The color maps for sourceDepth=16 and for sourceDepth=32 are the same"

	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| srcIndex map |
	ToGrayColormaps ifNil: [
		ToGrayColormaps _ Array new: 5].
	
	srcIndex _ sourceDepth highBit min: 5.

	(ToGrayColormaps at: srcIndex) ifNotNil: [ :m | ^ m ].

	map _ self computeColormapForGray8bppFrom: sourceDepth.
	ToGrayColormaps at: srcIndex put: map.
	^ map! !

!Color class methodsFor: 'colormaps' stamp: 'jmv 5/12/2016 14:50'!
                              cachedColormapFrom: sourceDepth to: destDepth
	"Return a cached colormap for mapping between the given depths. Always return a real colormap, not nil; this allows the client to get an identity colormap that can then be copied and modified to do color transformations."
	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"
	"Note: The colormap cache may be cleared by evaluating 'Color shutDown'."
	"Note: The color maps for sourceDepth=16 and for sourceDepth=32 are the same"

	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| srcIndex dstIndex map |
	CachedColormaps
		ifNil: [CachedColormaps _ (1 to: 5) collect: [:i | Array new: 6]].

	srcIndex _ sourceDepth highBit min: 5.
	dstIndex _ destDepth highBit.

	((CachedColormaps at: srcIndex) at: dstIndex) ifNotNil: [ :m | ^ m ].

	map _ self computeColormapFrom: sourceDepth to: destDepth.
	(CachedColormaps at: srcIndex) at: dstIndex put: map.
	^ map! !

!Color class methodsFor: 'colormaps' stamp: 'jmv 5/12/2016 15:49'!
    cachedColormapFromGrayTo: destDepth
	"Return a cached colormap for mapping from 8bpp grays to the given depth. Always return a real colormap, not nil; this allows the client to get an identity colormap that can then be copied and modified to do color transformations."
	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"
	"Note: The colormap cache may be cleared by evaluating 'Color shutDown'."
	"Note: The color maps for sourceDepth=16 and for sourceDepth=32 are the same"

	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| dstIndex map |
	FromGrayColormaps
		ifNil: [FromGrayColormaps _ Array new: 6 ].

	dstIndex _ destDepth highBit.

	(FromGrayColormaps at: dstIndex) ifNotNil: [ :m | ^ m ].

	map _ self computeColormapFromGray8bppForDepth: destDepth.
	FromGrayColormaps at: dstIndex put: map.
	^ map! !

!Color class methodsFor: 'colormaps'!
 colorMapIfNeededFrom: sourceDepth to: destDepth
	"Return a colormap for mapping between the given depths, or nil if no colormap is needed."
	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"

	sourceDepth = destDepth ifTrue: [^ nil].  "not needed if depths are the same"

	(sourceDepth >= 16) & (destDepth >= 16) ifTrue: [
		"mapping is done in BitBlt by zero-filling or truncating each color component"
		^ nil].

	^ Color cachedColormapFrom: sourceDepth to: destDepth
! !

!Color class methodsFor: 'colormaps' stamp: 'jmv 8/27/2009 08:47'!
  computeColorConvertingMap: targetColor from: sourceDepth to: destDepth keepSubPixelAA: keepSubPix
	"Note: The color converting map for sourceDepth=16 and for sourceDepth=32 are the same"
	sourceDepth < 16 ifTrue: [
		"source is 1-, 2-, 4-, or 8-bit indexed color.
		Assumed not to include subpixelAA"
		^ self computeIndexedColorConvertingMap: targetColor from: sourceDepth to: destDepth
	] ifFalse: [
		"source is 16-bit or 32-bit RGB.
		Might include subpixelAA"
		^ self computeRGBColorConvertingMap: targetColor to: destDepth keepSubPixelAA: keepSubPix
	]! !

!Color class methodsFor: 'colormaps' stamp: 'jmv 5/12/2016 15:55'!
         computeColormapForGray8bppFrom: sourceDepth
	"Compute a colorMap for translatingfrom the given depth to the 8bpp grays"
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| map |
	sourceDepth < 16 ifTrue: [
		"source is 1-, 2-, 4-, or 8-bit indexed color"
		map _ (self indexedColors copyFrom: 1 to: (1 bitShift: sourceDepth))
					collect: [ :c | (c luminance * 255) rounded].
		map _ map as: Bitmap.
		^ map
		]
	ifFalse: [
		^ self computeRGBColormapForGray8 ]! !

!Color class methodsFor: 'colormaps' stamp: 'jmv 4/17/2015 15:05'!
                             computeColormapFrom: sourceDepth to: destDepth
	"Compute a colorMap for translating between the given depths. A colormap is a Bitmap whose entries contain the pixel values for the destination depth. Typical clients use cachedColormapFrom:to: instead."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| map bitsPerColor |
	sourceDepth < 16 ifTrue: [
		"source is 1-, 2-, 4-, or 8-bit indexed color"
		map _ (self indexedColors copyFrom: 1 to: (1 bitShift: sourceDepth))
					collect: [:c | c pixelValueForDepth: destDepth].
		map _ map as: Bitmap.
	] ifFalse: [
		"source is 16-bit or 32-bit RGB"
		destDepth > 8
			ifTrue: [bitsPerColor _ 5]  "retain maximum color resolution"
			ifFalse: [bitsPerColor _ 4].
		map _ self computeRGBColormapFor: destDepth bitsPerColor: bitsPerColor].

	"Note: zero is transparent except when source depth is one-bit deep"
	sourceDepth > 1 ifTrue: [map at: 1 put: 0].
	^ map
! !

!Color class methodsFor: 'colormaps' stamp: 'jmv 5/12/2016 15:56'!
                              computeColormapFromGray8bppForDepth: destDepth
	"Return a colormap for displaying a GrayForm at the given depth"

	| newMap |
	newMap _ Bitmap new: 256.
	1 to: 256 do: [ :i |
		newMap
			at: i
			put: ((Color gray: (i-1) asFloat / 255.0) pixelValueForDepth: destDepth)].
	^ newMap! !

!Color class methodsFor: 'colormaps' stamp: 'jmv 4/17/2015 15:05'!
computeIndexedColorConvertingMap: targetColor from: sourceDepth to: destDepth
	| map |
	
	map _ (self indexedColors copyFrom: 1 to: (1 bitShift: sourceDepth)) collect: [ :cc | | f c |
		f _ 1.0 - (cc red + cc green + cc blue / 3.0 ).
		c _ targetColor
			ifNotNil: [
				destDepth = 32
					ifTrue: [ targetColor * f alpha: f]
					ifFalse: [ targetColor alphaMixed: f*1.5 with: Color white ]]
			ifNil: [ cc ].
		destDepth = 32
			ifTrue: [ c pixelValueForDepth: destDepth]
			ifFalse: [
				f = 0.0
					ifTrue: [ 0 ]
					ifFalse: [ c pixelValueForDepth: destDepth ]]].
	map _ map as: Bitmap.
	^map! !

!Color class methodsFor: 'colormaps' stamp: 'jmv 12/26/2011 13:49'!
                              computeRGBColorConvertingMap: targetColor to: destDepth keepSubPixelAA: keepSubPix
	"Builds a colormap intended to convert from subpixelAA black values to targetColor values.
	keepSubPix
		ifTrue: [ Answer colors that also include subpixelAA ]
		ifFalse: [ 
			Take fullpixel luminance level. Apply it to targetColor.
			I.e. answer colors with NO subpixelAA ]"

	| mask map c bitsPerColor r g b f v |

	destDepth > 8
		ifTrue: [bitsPerColor _ 5]  "retain maximum color resolution"
		ifFalse: [bitsPerColor _ 4].
	"Usually a bit less is enough, but make it configurable"
	bitsPerColor _ bitsPerColor min: Preferences aaFontsColormapDepth.
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		r _ (i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask.
		g _ (i bitShift: 0 - bitsPerColor) bitAnd: mask.
		b _ (i bitShift: 0) bitAnd: mask.
		f _ 1.0 - (r + g + b / 3.0 / mask).
		c _ targetColor
			ifNotNil: [
				(keepSubPix and: [destDepth > 8]) ifTrue: [
						Color
							r: 1.0 - (r asFloat/mask) * targetColor red
							g: 1.0 - (g asFloat/mask) * targetColor green
							b: 1.0 - (b asFloat/mask) * targetColor blue
							alpha: f	* targetColor alpha "alpha will be ignored below, in #pixelValueForDepth: if destDepth ~= 32" ]
				ifFalse: [
					destDepth = 32
						ifTrue: [ targetColor * f alpha: f * targetColor alpha ]
						ifFalse: [ targetColor alphaMixed: f*1.5 with: Color white ]]]
			ifNil: [ Color r: r g: g b: b range: mask].	"This is currently used only to keep some SubPixelAA on destDepth = 8, using a single pass of rule 25"
		v _ destDepth = 32
			ifTrue: [ c pixelValueForDepth: destDepth]
			ifFalse: [
				f < 0.1
					ifTrue: [ 0 ]
					ifFalse: [ c pixelValueForDepth: destDepth ]].
		map at: i + 1 put: v ].
	^ map! !

!Color class methodsFor: 'colormaps' stamp: 'jmv 1/30/2011 23:10'!
                              computeRGBColormapFor: destDepth bitsPerColor: bitsPerColor
	"Compute a colorMap for translating from 16-bit or 32-bit RGB color to the given depth, using the given number of of bits per color component."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| mask map c |
	(#(3 4 5) includes: bitsPerColor)
		ifFalse: [self error: 'BitBlt only supports 3, 4, or 5 bits per color component'].
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		c _ Color
			r: ((i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask)
			g: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)
			b: ((i bitShift: 0) bitAnd: mask)
			range: mask.
		map at: i + 1 put: (c pixelValueForDepth: destDepth)].

	map at: 1 put: (Color transparent pixelWordForDepth: destDepth).  "zero always transparent"
	^ map
! !

!Color class methodsFor: 'colormaps' stamp: 'jmv 5/12/2016 15:57'!
                             computeRGBColormapForGray8
	"Compute a colorMap for translating from 16-bit or 32-bit RGB color to 8bpp grays, using the default number of of bits per color component."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| bitsPerColor mask map c |
	bitsPerColor _ 5.
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		c _ Color
			r: ((i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask)
			g: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)
			b: ((i bitShift: 0) bitAnd: mask)
			range: mask.
		map at: i + 1 put: (c luminance * 255) rounded].

	^ map! !

!Color class methodsFor: 'other' stamp: 'jmv 1/31/2011 09:30'!
 maskingMap: depth
	"Return a color map that maps all colors except transparent to words of all ones. Used to create a mask for a Form whose transparent pixel value is zero. Cache the most recently used map."
	"Warning: The behavior is incorrect if depth = 32.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| sizeNeeded |
	depth <= 8
		ifTrue: [sizeNeeded _ 1 bitShift: depth]
		ifFalse: [sizeNeeded _ 4096].

	(MaskingMap == nil or: [MaskingMap size ~= sizeNeeded]) ifTrue:
		[MaskingMap _ Bitmap new: sizeNeeded withAll: 16rFFFFFFFF.
		MaskingMap at: 1 put: 0.  "transparent"].

	^ MaskingMap
! !

!Color class methodsFor: 'color from user' stamp: 'jmv 3/1/2010 15:13'!
                        colorPaletteForDepth: depth extent: chartExtent
	"Display a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."
	"Note: It is slow to build this palette, so it should be cached for quick access."
	"(Color colorPaletteForDepth: 16 extent: 190@60) display"

	| basicHue x y startHue palette transHt vSteps transCaption grayWidth hSteps |
	palette _ Form extent: chartExtent depth: depth.
	transCaption _ 
		(Form extent: 34@9 depth: 1
			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)
			offset: 0@0).
	transHt _ transCaption height.
	palette fillWhite: (0@0 extent: palette width@transHt).
	palette fillBlack: (0@transHt extent: palette width@1).
	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).
	grayWidth _ 10.
	startHue _ 338.0.
	vSteps _ palette height - transHt // 2.
	hSteps _ palette width - grayWidth.
	x _ 0.
	startHue to: startHue + 360.0 by: 360.0/hSteps do: [ :h |
		basicHue _ Color h: h asFloat s: 1.0 v: 1.0.
		y _ transHt+1.
		0 to: vSteps do: [ :n | | c |
 			c _ basicHue mixed: (n asFloat / vSteps asFloat) with: Color white.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		1 to: vSteps do: [ :n | | c |
 			c _ Color black mixed: (n asFloat / vSteps asFloat) with: basicHue.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		x _ x + 1].
	y _ transHt + 1.
	1 to: vSteps * 2 do: [ :n | | c |
 		c _ Color black mixed: (n asFloat / (vSteps*2) asFloat) with: Color white.
		palette fill: (x@y extent: 10@1) fillColor: c.
		y _ y + 1].
	^ palette
! !

!Color class methodsFor: 'color from user' stamp: 'jmv 7/27/2009 11:32'!
              colorTest: depth extent: chartExtent colorMapper: colorMapper
	"Create a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."
	"Note: It is slow to build this palette, so it should be cached for quick access."
	"(Color colorTest: 32 extent: 570@180 colorMapper: [:c | c]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 7) asInteger / 7
			g: (c green * 7) asInteger / 7
			b: (c blue * 3) asInteger / 3]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 5) asInteger / 5
			g: (c green * 5) asInteger / 5
			b: (c blue * 5) asInteger / 5]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 15) asInteger / 15
			g: (c green * 15) asInteger / 15
			b: (c blue * 15) asInteger / 15]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 31) asInteger / 31
			g: (c green * 31) asInteger / 31
			b: (c blue * 31) asInteger / 31]) display"

	| basicHue x y c startHue palette transHt vSteps transCaption grayWidth hSteps |
	palette _ Form extent: chartExtent depth: depth.
	transCaption _ 
		(Form extent: 34@9 depth: 1
			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)
			offset: 0@0).
	transHt _ transCaption height.
	palette fillWhite: (0@0 extent: palette width@transHt).
	palette fillBlack: (0@transHt extent: palette width@1).
	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).
	grayWidth _ 10.
	startHue _ 338.0.
	vSteps _ palette height - transHt // 2.
	hSteps _ palette width - grayWidth.
	x _ 0.
	startHue to: startHue + 360.0 by: 360.0/hSteps do: [:h |
		basicHue _ Color h: h asFloat s: 1.0 v: 1.0.
		y _ transHt+1.
		0 to: vSteps do: [:n |
 			c _ basicHue mixed: (n asFloat / vSteps asFloat) with: Color white.
			c _ colorMapper value: c.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		1 to: vSteps do: [:n |
 			c _ Color black mixed: (n asFloat / vSteps asFloat) with: basicHue.
			c _ colorMapper value: c.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		x _ x + 1].
	y _ transHt + 1.
	1 to: vSteps * 2 do: [:n |
 		c _ Color black mixed: (n asFloat / (vSteps*2) asFloat) with: Color white.
		c _ colorMapper value: c.
		palette fill: (x@y extent: 10@1) fillColor: c.
		y _ y + 1].
	^ palette
! !

!Color class methodsFor: 'color name lookup' stamp: 'KenD 1/26/2013 20:13'!
    colorNames
	"Answer the current dictionary of  name->color associations."

	^self colorNamesDict keys! !

!Color class methodsFor: 'color name lookup' stamp: 'KenD 1/28/2013 20:34'!
          defaultColorNamesDictionary
	"Answer a amall but  useful name->color dictionary"
	
	| defaultDict |
	"Meld most used xkcd colors into traditional colors."
	defaultDict := (self traditionalColorNamesDictionary addAll: 
					self xkcdFirst48ColorNamesDictionary; 
					yourself).
		
	"Override traditional names existing in extended XKCD naming"
	defaultDict at: #lightYellow    put: (Color r: 1.0 g: 0.996 b: 0.478).
	defaultDict at: #lightOrange   put: (Color r: 0.992 g: 0.667 b: 0.283).
	defaultDict at: #lightCyan        put: (Color r: 0.674 g: 1.0 b: 0.988).
	defaultDict at: #lightRed          put: (Color r: 1.0 g: 0.279 b: 0.298).
	defaultDict at: #lightMagenta put: (Color r: 0.98 g: 0.372 b: 0.969).
	
	^defaultDict! !

!Color class methodsFor: 'color name lookup' stamp: 'KenD 2/1/2013 14:39'!
                            doesNotUnderstand: aMessage
	"Some code takes
		 Color colorNames 
	and does
		Color perform: aColorname.
		
	Make this work."

	^(Color colorNamesDict) 
		at: (aMessage selector)
		ifAbsent: [super doesNotUnderstand: aMessage]! !

!Color class methodsFor: 'color name lookup' stamp: 'KenD 1/26/2013 20:51'!
            exactColorNamed: aColorName

	"Answer color matching name or nil 
	from my ColorName->Color Dictionary"
	
	^ self colorNamesDict at: (aColorName asSymbol) ifAbsent: [nil]! !

!Color class methodsFor: 'color name lookup' stamp: 'KenD 7/25/2014 21:22'!
     setColorNamesDict: aNameColorDictionary
	"Answer the current dictionary of  name->color associations."
	
	"Note: This is a non-standard name because this is a non-standard action!!
	Do this if you really, really know what you are doing."
	
	"Some Colors are required for proper system operation"
	Color defaultColorNamesDictionary keysAndValuesDo: [ :colorName :colorValue |
		aNameColorDictionary at: colorName ifAbsentPut: colorValue
	].

	ColorNamesDict := aNameColorDictionary! !

!Color class methodsFor: 'color name lookup' stamp: 'sqr 10/21/2016 12:44:48'!
            traditionalColorNamesDictionary
	"Answer a dictionary of Squeak traditional name->color associations.."

	| nameDict |
	nameDict _ Dictionary new.
	nameDict at: #black put: (Color r: 0 g: 0 b: 0).
	nameDict at: #veryVeryDarkGray put: (Color r: 0.125 g: 0.125 b: 0.125).
	nameDict at: #veryDarkGray put: (Color r: 0.25 g: 0.25 b: 0.25).
	nameDict at: #darkGray put: (Color r: 0.375 g: 0.375 b: 0.375).
	nameDict at: #gray put: (Color r: 0.5 g: 0.5 b: 0.5).
	nameDict at: #lightGray put: (Color r: 0.625 g: 0.625 b: 0.625).
	nameDict at: #veryLightGray put: (Color r: 0.75 g: 0.75 b: 0.75).
	nameDict at: #veryVeryLightGray put: (Color r: 0.875 g: 0.875 b: 0.875).
	nameDict at: #white put: (Color r: 1.0 g: 1.0 b: 1.0).
	nameDict at: #red put: (Color r: 1.0 g: 0 b: 0).
	nameDict at: #yellow put: (Color r: 1.0 g: 1.0 b: 0).
	nameDict at: #green put: (Color r: 0 g: 1.0 b: 0).
	nameDict at: #cyan put: (Color r: 0 g: 1.0 b: 1.0).
	nameDict at: #blue put: (Color r: 0 g: 0 b: 1.0).
	nameDict at: #magenta put: (Color r: 1.0 g: 0 b: 1.0).
	nameDict at: #brown put: (Color r: 0.6 g: 0.2 b: 0).
	nameDict at: #orange put: (Color r: 1.0 g: 0.6 b: 0).
	nameDict at: #lightRed put: (Color r: 1.0 g: 0.8 b: 0.8).
	nameDict at: #lightYellow put: (Color r: 1.0 g: 1.0 b: 0.8).
	nameDict at: #lightGreen put: (Color r: 0.8 g: 1.0 b: 0.6).
	nameDict at: #lightCyan put: (Color r: 0.4 g: 1.0 b: 1.0).
	nameDict at: #lightBlue put: (Color r: 0.8 g: 1.0 b: 1.0).
	nameDict at: #lightMagenta put: (Color r: 1.0 g: 0.8 b: 1.0).
	nameDict at: #lightBrown put: (Color r: 1.0 g: 0.6 b: 0.2).
	nameDict at: #lightOrange put: (Color r: 1.0 g: 0.8 b: 0.4).
	nameDict at: #transparent put: (TranslucentColor r: 0.0 g: 0.0 b: 0.0 alpha: 0.0).
	
	^nameDict
! !

!Color class methodsFor: 'color name lookup' stamp: 'jmv 6/30/2014 15:22'!
              xkcdFirst48ColorNamesDictionary
	"XKCD color names are based on a survey oc colors people call by the same name.
	 http://blog.xkcd.com/2010/05/03/color-survey-results/"

	"Answer a dictionary of the most agreed upon first 48 xkcd colors"
"
	Color xkcdFirst48ColorNamesDictionary explore.
"	
	| xkcdDict |
	xkcdDict := Dictionary new
	at: #lightPink put: (Color fromString: '#ffd1df') ;
	at: #mustard put: (Color fromString: '#ceb301') ;
	at: #indigo put: (Color fromString: '#380282') ;
	at: #lime put: (Color fromString: '#aaff32') ;
	at: #seaGreen put: (Color fromString: '#53fca1') ;
	at: #periwinkle put: (Color fromString: '#8e82fe') ;
	at: #darkPink put: (Color fromString: '#cb416b') ;
	at: #oliveGreen put: (Color fromString: '#677a04') ;
	at: #peach put: (Color fromString: '#ffb07c') ;
	at: #paleGreen put: (Color fromString: '#c7fdb5') ;
	at: #lightBrown put: (Color fromString: '#ad8150') ;
	at: #hotPink put: (Color fromString: '#ff028d') ;
	at: #black put: (Color fromString: '#000000') ;
	at: #lilac put: (Color fromString: '#cea2fd') ;
	at: #navyBlue put: (Color fromString: '#001146') ;
	at: #royalBlue put: (Color fromString: '#0504aa') ;
	at: #beige put: (Color fromString: '#e6daa6') ;
	at: #salmon put: (Color fromString: '#ff796c') ;
	at: #olive put: (Color fromString: '#6e750e') ;
	at: #maroon put: (Color fromString: '#650021') ;
	at: #brightGreen put: (Color fromString: '#01ff07') ;
	at: #darkPurple put: (Color fromString: '#35063e') ;
	at: #mauve put: (Color fromString: '#ae7181') ;
	at: #forestGreen put: (Color fromString: '#06470c') ;
	at: #aqua put: (Color fromString: '#13eac9') ;
	at: #cyan put: (Color fromString: '#00ffff') ;
	at: #tan put: (Color fromString: '#d1b26f') ;
	at: #darkBlue put: (Color fromString: '#00035b') ;
	at: #lavender put: (Color fromString: '#c79fef') ;
	at: #turquoise put: (Color fromString: '#06c2ac') ;
	at: #darkGreen put: (Color fromString: '#033500') ;
	at: #violet put: (Color fromString: '#9a0eea') ;
	at: #lightPurple put: (Color fromString: '#bf77f6') ;
	at: #limeGreen put: (Color fromString: '#89fe05') ;
	at: #grey put: (Color fromString: '#929591') ;
	at: #skyBlue put: (Color fromString: '#75bbfd') ;
	at: #yellow put: (Color fromString: '#ffff14') ;
	at: #magenta put: (Color fromString: '#c20078') ;
	at: #lightGreen put: (Color fromString: '#96f97b') ;
	at: #orange put: (Color fromString: '#f97306') ;
	at: #teal put: (Color fromString: '#029386') ;
	at: #lightBlue put: (Color fromString: '#95d0fc') ;
	at: #red put: (Color fromString: '#e50000') ;
	at: #brown put: (Color fromString: '#653700') ;
	at: #pink put: (Color fromString: '#ff81c0') ;
	at: #blue put: (Color fromString: '#0343df') ;
	at: #green put: (Color fromString: '#15b01a') ;
	at: #purple put: (Color fromString: '#7e1e9c') ;
  	yourself.

	^xkcdDict

! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:26'!
     blueColorDict
	"Answer a dictionary of named colors considered Blue"
"
	Color blueColorDict explore.
"
	^self blueColorDict: (self colorNamesDict )! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:24'!
    blueColorDict: aColorDict
	"Answer a dictionary of named colors considered Blue"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isBlue)
				or: [assoc key asString asLowercase includesSubString: 'blue'])
			ifTrue: [dict add: assoc]
		].
	^dict! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:28'!
                  blueGreenColorDict
	"Answer a dictionary of named colors considered Blue"
"
	Color blueGreenColorDict explore.
"
	^self blueGreenColorDict: (self colorNamesDict )! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:29'!
                     blueGreenColorDict: aColorDict
	"Answer a dictionary of named colors considered Blue"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isBlueGreen)
				or: [assoc key asString asLowercase includesSubString: 'bluegreen'])
			ifTrue: [dict add: assoc]
		].
	^dict! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:31'!
   brightColorDict
	"Answer a dictionary of named colors considered Bright"
"
	Color brightColorDict explore.
"
	^self brightColorDict: (self colorNamesDict )! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:31'!
                            brightColorDict: aColorDict
	"Answer a dictionary of named colors considered Bright"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			(assoc value isBright) ifTrue: [dict add: assoc]
		].
	^dict! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:34'!
                    brownColorDict
	"Answer a dictionary of named colors considered Brown"
"
	Color brownColorDict explore.
"
	^self brownColorDict: (self colorNamesDict )! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:33'!
brownColorDict: aColorDict
	"Answer a dictionary of named colors considered Brown"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isBrown)
				or: [assoc key asString asLowercase includesSubString: 'brown'])
			ifTrue: [dict add: assoc]
		].
	^dict! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:36'!
              darkColorDict
	"Answer a dictionary of named colors considered Dark"
"
	Color darkColorDict explore.
"
	^self darkColorDict: (self colorNamesDict )! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:37'!
    darkColorDict: aColorDict
	"Answer a dictionary of named colors considered Dark"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			(assoc value isDark) ifTrue: [dict add: assoc]
		].
	^dict! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:41'!
                          grayColorDict: aColorDict
	"Answer a dictionary of named colors considered Grey"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isGrey)
				or: [assoc key asString asLowercase includesSubString: 'grey'])
			ifTrue: [dict add: assoc]
		].
	^dict! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:38'!
                  greenColorDict
	"Answer a dictionary of named colors considered Green"
"
	Color greenColorDict explore.
"
	^self greenColorDict: (self colorNamesDict )! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:38'!
greenColorDict: aColorDict
	"Answer a dictionary of named colors considered Green"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isGreen)
				or: [assoc key asString asLowercase includesSubString: 'green'])
			ifTrue: [dict add: assoc]
		].
	^dict! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:41'!
              greyColorDict
	"Answer a dictionary of named colors considered Grey"
"
	Color greyColorDict explore.
"
	^self greyColorDict: (self colorNamesDict )! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:40'!
    greyColorDict: aColorDict
	"Answer a dictionary of named colors considered Grey"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isGrey)
				or: [assoc key asString asLowercase includesSubString: 'grey'])
			ifTrue: [dict add: assoc]
		].
	^dict! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:44'!
                  lightColorDict
	"Answer a dictionary of named colors considered light"
"
	Color lightColorDict explore.
"
	^self lightColorDict: (self colorNamesDict )! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:43'!
lightColorDict: aColorDict
	"Answer a dictionary of named colors considered Liight"

	^self brightColorDict: aColorDict! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:46'!
orangeColorDict
	"Answer a dictionary of named colors considered Orange"
"
	Color orangeColorDict explore.
"
	^self orangeColorDict: (self colorNamesDict )! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:46'!
                            orangeColorDict: aColorDict
	"Answer a dictionary of named colors considered Orange"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isOrange)
				or: [assoc key asString asLowercase includesSubString: 'orange'])
			ifTrue: [dict add: assoc]
		].
	^dict! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:48'!
          pastelColorDict
	"Answer a dictionary of named colors considered Pastel"
"
	Color pastelColorDict explore.
"
	^self pastelColorDict: (self colorNamesDict )! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:48'!
                            pastelColorDict: aColorDict
	"Answer a dictionary of named colors considered Bright"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			(assoc value isPastel) ifTrue: [dict add: assoc]
		].
	^dict! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:50'!
                    pinkColorDict
	"Answer a dictionary of named colors considered Pink"
"
	Color pinkColorDict explore.
"
	^self pinkColorDict: (self colorNamesDict )! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:50'!
    pinkColorDict: aColorDict
	"Answer a dictionary of named colors considered Pink"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isPink)
				or: [assoc key asString asLowercase includesSubString: 'pink'])
			ifTrue: [dict add: assoc]
		].
	^dict! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:52'!
                  purpleColorDict
	"Answer a dictionary of named colors considered Purple"
"
	Color purpleColorDict explore.
"
	^self purpleColorDict: (self colorNamesDict )! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:52'!
                            purpleColorDict: aColorDict
	"Answer a dictionary of named colors considered Pink"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc key asString asLowercase includesSubString: 'purple')
				or: [assoc key asString asLowercase includesSubString: 'violet'])
			ifTrue: [dict add: assoc]
		].
	^dict! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:54'!
      redColorDict
	"Answer a dictionary of named colors considered Red"
"
	Color redColorDict explore.
"
	^self redColorDict: (self colorNamesDict )! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:53'!
        redColorDict: aColorDict
	"Answer a dictionary of named colors considered Red"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isRed)
				or: [assoc key asString asLowercase includesSubString: 'red'])
			ifTrue: [dict add: assoc]
		].
	^dict! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:56'!
                      saturatedColorDict
	"Answer a dictionary of named colors considered Saturated"
"
	Color saturatedColorDict explore.
"
	^self saturatedColorDict: (self colorNamesDict )! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:55'!
                saturatedColorDict: aColorDict
	"Answer a dictionary of named colors considered Saturated"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			(assoc value isSaturated) ifTrue: [dict add: assoc]
		].
	^dict! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:26'!
           yellowColorDict
	"Answer a dictionary of named colors considered Yellow"
"
	Color yellowColorDict explore.
"
	^self yellowColorDict: (self colorNamesDict)! !

!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:19'!
                             yellowColorDict: aColorDict
	"Answer a dictionary of named colors considered Yellow"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isYellow)
				or: [assoc key asString asLowercase includesSubString: 'yellow'])
			ifTrue: [dict add: assoc]
		].
	^dict! !

!Color class methodsFor: 'color space conversions' stamp: 'jmv 4/24/2013 10:55'!
                             applySimpleGamma: gamma to: value
	"Encode / decode Gamma. Typical gamma are 0.4545 ( = 1.0 / 2.2, for encoding) and 2.2 (for decoding)
	In a non gamma encoded image, the pixel values are proportional to luminance, i.e. the actual light intensity, the photon count.
	In an gamma encoded image, the pixel value is close to the average perceived brightness, or 'lightness'. This optimizes the use of available bits in digital images, and dynamic range in analog images and film. This is like the 'luma' signal in video.

	Usually:
		- Images stored in file formats such as jpg, png, tiff and bmp are gamma encoded
				(unless they are actually raw images).
		- Images sent to a framebuffer (video memory) should be gamma encoded.
		- Raw images from sensors are not gamma encoded.

		- Image processing algorithms that simulate the real world, or are applied to real world data should work on unencoded (linear) images.
				This includes filtering, resizing, blending, and most operations done on images.
				This means that if the images come from jpg photos from a camera, they should be gamma decoded.
		- Image processing algorithms that works on human perception should work on gamma encoded images.
				This includes histograms, histogram equalization, bit allocation (i.e. quantization), compression, etc.
				This also includes detecting objects like a human would do
				

	See
		http://en.wikipedia.org/wiki/Gamma_correction
		http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html

	Mostly for documentation.
	value must be in [0.0 .. 1.0].
	Note that the sRGB standard specifies a function that is close to this, but slightly different.
	See #linearTosRGBGamma: and #sRGBGammaToLinear:"

	^ value raisedTo: gamma! !

!Color class methodsFor: 'color space conversions' stamp: 'jmv 4/24/2013 10:49'!
           linearTosRGBGamma: value
	"The sRGB standard specifies a gamma curve that is close to gamma = 2.2, but is actually
	built from one stright line segment, and a curve with exponent = 2.4.
	This method converts value from linearSpace to gammaSpace, i.e. it 'encodes' with gamma.
	This is the operation done when producing an 8bit Form for displaying, or for saving on a JPG, PNG, etc; if source data is in linear space (for example, from raw data a sensor image, or data that was converted previously to linear space for proper image processing).
	value must be in [0.0 .. 1.0].

	See
		http://en.wikipedia.org/wiki/Gamma_correction
		http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html
		http://entropymine.com/imageworsener/srgbformula
	
	| r v |
	r _ Random new.
	1000 timesRepeat: [
		v _ r next.
		self assert: ((Color sRGBGammaToLinear: (Color linearTosRGBGamma: v)) closeTo: v) ]

	| r |
	r _ 10@10 extent: 600@400.
	Display fill: r fillColor: Color white.
	FFT new plot: ((0.0 to: 1.0 count: 100) collect: [ :v | Color linearTosRGBGamma: v ]) in: r color: Color black min: 0.0 max: 1.0.
	FFT new plot: ((0.0 to: 1.0 count: 100) collect: [ :v | Color applySimpleGamma: 1/2.2 to: v ]) in: r color: Color blue min: 0.0 max: 1.0.
	FFT new plot: ((0.0 to: 1.0 count: 100) collect: [ :v | Color sRGBGammaToLinear: v ]) in: r color: Color black min: 0.0 max: 1.0.
	FFT new plot: ((0.0 to: 1.0 count: 100) collect: [ :v | Color applySimpleGamma: 2.2 to: v ]) in: r color: Color blue min: 0.0 max: 1.0.
	"

	^ value <= 0.00313066844250063
		ifTrue: [ value * 12.92 ]
		ifFalse: [ (value raisedTo: 1.0/2.4) * 1.055 - 0.055 ]! !

!Color class methodsFor: 'color space conversions' stamp: 'jmv 4/24/2013 10:50'!
               sRGBGammaToLinear: value
	"The sRGB standard specifies a gamma curve that is close to gamma = 2.2, but is actually
	built from one stright line segment, and a curve with exponent = 2.4.
	This method converts value from gammaSpace to linearSpace, i.e. it 'decodes'.
	This is the operation done by display screens. It is also needed to convert 8bit Forms (from a frameBuffer, or from PNG, JPG, etc.) to linear space for proper image processing.
	value must be in [0.0 .. 1.0].

	See
		http://en.wikipedia.org/wiki/Gamma_correction
		http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html
		http://entropymine.com/imageworsener/srgbformula
	"

	^ value <= 0.0404482362771082
		ifTrue: [ value / 12.92 ]
		ifFalse: [ value + 0.055 / 1.055 raisedTo: 2.4 ]! !

!Color class methodsFor: 'cached state access' stamp: 'jmv 4/17/2015 14:58'!
                           colorNamesDict
	"Answer the current dictionary of  name->color associations."
"
	Color colorNamesDict explore.
"
	ColorNamesDict ifNil: [
		self setColorNamesDict: self defaultColorNamesDictionary ].
	^ColorNamesDict! !

!Color class methodsFor: 'cached state access' stamp: 'jmv 4/17/2015 15:08'!
                      grayToIndexMap
	"
	Color grayToIndexMap explore.
	"
	GrayToIndexMap ifNil: [
		self initializeGrayToIndexMap ].
	^GrayToIndexMap! !

!Color class methodsFor: 'cached state access' stamp: 'jmv 4/17/2015 15:04'!
              indexedColors
	"
	Color indexedColors explore.
	"
	IndexedColors ifNil: [
		self initializeIndexedColors ].
	^IndexedColors! !

!Color class methodsFor: 'cached state access' stamp: 'jmv 5/12/2016 14:58'!
                   releaseClassCachedState
	"
	Color releaseClassCachedState
	"
	CachedColormaps _ nil. 		"Maps to translate between color depths"
	ToGrayColormaps _ nil.			"Maps colors to 8bpp grays for various color depths"
	FromGrayColormaps _ nil.		"Maps from 8bpp grays to colors of various depths"
	MaskingMap _ nil. 				"Maps all colors except transparent to black for creating a mask"
	ColorNamesDict _ nil.
	IndexedColors _ nil.
	GrayToIndexMap _ nil! !


Form subclass: #ColorForm
	instanceVariableNames: 'colors cachedDepth cachedColormap'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Display Objects'!

!ColorForm methodsFor: 'accessing' stamp: 'ar 5/17/2001 15:45'!
                      colors: colorList
	"Set my color palette to the given collection."

	| colorArray colorCount newColors |
	colorList ifNil: [
		colors _ cachedDepth _ cachedColormap _ nil.
		^ self].

	colorArray _ colorList asArray.
	colorCount _ colorArray size.
	newColors _ Array new: (1 bitShift: self depth).
	1 to: newColors size do: [:i |
		i <= colorCount
			ifTrue: [newColors at: i put: (colorArray at: i)]
			ifFalse: [newColors at: i put: Color transparent]].

	colors _ newColors.
	cachedDepth _ nil.
	cachedColormap _ nil.
! !

!ColorForm methodsFor: 'color manipulation' stamp: 'jmv 6/19/2017 15:47:08'!
     asGrayForm
	"Build an optimal GrayForm,
	for any color palette in the receiver."
	| answer map |
	answer _ GrayForm extent: width@height.
	map _ self colormapIfNeededForGray8bpp.
	(BitBlt toForm: answer)
		colorMap: map;
		copy: self boundingBox
		from: `0@0` in: self
		fillColor: nil rule: Form over.
	^ answer! !

!ColorForm methodsFor: 'color manipulation' stamp: 'di 11/11/1998 13:20'!
                         asGrayScale
	"Return a grayscale ColorForm computed by mapping each color into its grayscale equivalent"
	^ self copy colors:
		(colors collect:
			[:c | c isTransparent ifTrue: [c]
						ifFalse: [Color gray: c luminance]])! !

!ColorForm methodsFor: 'color manipulation' stamp: 'jmv 3/1/2010 09:41'!
                  colormapIfNeededForDepth: destDepth
	"Return a colormap for displaying the receiver at the given depth, or nil if no colormap is needed."

	| newMap |
	colors ifNil: [
		"use the standard colormap"
		^ Color colorMapIfNeededFrom: self depth to: destDepth].

	(destDepth = cachedDepth and:[cachedColormap isColormap not]) 
		ifTrue: [^ cachedColormap].
	newMap _ Bitmap new: colors size.
	1 to: colors size do: [:i |
		newMap
			at: i
			put: ((colors at: i) pixelValueForDepth: destDepth)].

	cachedDepth _ destDepth.
	^ cachedColormap _ newMap.
! !

!ColorForm methodsFor: 'copying' stamp: 'jmv 6/19/2017 15:47:12'!
                       copy: aRect
 	"Return a new ColorForm containing the portion of the receiver delineated by aRect."

	| newForm |
	newForm _ self class extent: aRect extent depth: depth.
	((BitBlt
		destForm: newForm
		sourceForm: self
		combinationRule: Form over
		destOrigin: `0@0`
		sourceOrigin: aRect origin
		extent: aRect extent
		clipRect: newForm boundingBox)
		colorMap: nil) copyBits.
	colors ifNotNil: [newForm colors: colors copy].
	^ newForm
! !

!ColorForm methodsFor: 'private' stamp: 'ar 5/17/2001 15:44'!
     ensureColorArrayExists
	"Return my color palette."

	colors ifNil: [
		self depth > 8 ifTrue: [^ self error: 'ColorForms only support depths up to 8 bits'].
		self colors: (Color indexedColors copyFrom: 1 to: (1 bitShift: self depth))].
! !


ColorForm class
	instanceVariableNames: ''!

!ColorForm class methodsFor: 'as yet unclassified' stamp: 'jmv 6/19/2017 15:47:16'!
            mappingWhiteToTransparentFrom: aFormOrCursor
	"Return a ColorForm copied from the given Form or Cursor with white mapped to transparent."

	| f map |
	aFormOrCursor depth <= 8 ifFalse: [
		^ self error: 'argument depth must be 8-bits per pixel or less'].
	(aFormOrCursor is: #ColorForm) ifTrue: [
		f _ aFormOrCursor copy.
		map _ aFormOrCursor colors.
	] ifFalse: [
		f _ ColorForm extent: aFormOrCursor extent depth: aFormOrCursor depth.
		f copyBits: aFormOrCursor boundingBox
			from: aFormOrCursor
			at: `0@0`
			clippingBox: aFormOrCursor boundingBox
			rule: Form over.
		map _ Color indexedColors copyFrom: 1 to: (1 bitShift: aFormOrCursor depth)].
	map _ map collect: [:c |
		c = Color white ifTrue: [Color transparent] ifFalse: [c]].
	f colors: map.
	^ f
! !

!ColorForm class methodsFor: 'instance creation' stamp: 'jmv 5/4/2016 16:31'!
               grayScaleAndTransparentExtent: aPoint
"Native depth"
	"Answer a ColorForm for storing 8bpp gray scale. (do not include any slot for transparent)"

	| grays result |
	result _ self extent: aPoint depth: (Smalltalk isLittleEndian ifTrue: [ -8 ] ifFalse: [ 8 ]).
	grays _ (0 to: 255) collect: [ :brightness | Color gray: brightness asFloat / 255.0].
	grays at: 1 put: Color transparent.
	result colors: grays.
	^result! !


ByteArray variableByteSubclass: #CompiledMethod
	instanceVariableNames: ''
	classVariableNames: 'LargeFrame PrimaryBytecodeSetEncoderClass SecondaryBytecodeSetEncoderClass SmallFrame'
	poolDictionaries: ''
	category: 'Kernel-Methods'!

!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 12/17/2016 22:38:52'!
     initialPC
	"Answer the program counter for the receiver's first bytecode."
	^ (self numLiterals + 1) * Smalltalk wordSize + 1! !

!CompiledMethod methodsFor: 'comparing' stamp: 'jmv 12/10/2016 01:27:06'!
                    = method
	| numLits lit1 lit2 |

	"Any object is equal to itself"
	self == method ifTrue: [ ^ true ].

	"Answer whether the receiver implements the same code as the 
	argument, method."
	(method is: #CompiledMethod) ifFalse: [ ^false ].
	self size = method size ifFalse: [ ^false ].
	self header = method header ifFalse: [ ^false ].
	self initialPC to: self endPC do: [ :i |
		(self at: i) = (method at: i) ifFalse: [ ^false ]].
	(numLits _ self numLiterals) ~= method numLiterals ifTrue: [ ^false ].

	"Dont bother checking FFI and named primitives''
	jmv: Does this make any sense?
	 (#(117 120) includes: self primitive) ifTrue: [^ true]."

	 "properties"
	(self properties analogousCodeTo: method properties) ifFalse: [
		^false ].

	"#penultimateLiteral is selector (or properties, just compared, above)
	Last literal is #methodClass.
	Don't compare them. Two methods might be equal even if they have different selector (or none at all)
	or are installed in different classes (or none at all)"
	1 to: numLits-2 do: [ :i |
		lit1 _ self literalAt: i.
		lit2 _ method literalAt: i.
		lit1 = lit2 ifFalse: [
			(i = 1 and: [ #(117 120) includes: self primitive ])
				ifTrue: [
					lit1 isArray
						ifTrue: [
							(lit2 isArray and: [ lit1 allButLast = lit2 allButLast ]) ifFalse: [
								^false ]]
						ifFalse: [ "ExternalLibraryFunction"
							(lit1 analogousCodeTo: lit2) ifFalse: [
								^false ]]]
				ifFalse: [
					 lit1 isFloat
						ifTrue: [
							"Floats match if values are close, due to roundoff error."
							(lit1 closeTo: lit2) ifFalse: [ ^false ].
							self flag: 'just checking'. self halt ]
						ifFalse: [
							"any other discrepancy is a failure"
							^ false ]]]].
	^true! !

!CompiledMethod methodsFor: 'testing' stamp: 'HernanWilkinson 1/10/2017 18:22:10'!
                   isTestMethod

    ^ (self methodClass is: #TestCaseClass) 
		and: [ ((self selector beginsWith: 'test') or: [ (self selector beginsWith: 'should')]) 
		and: [ self numArgs isZero ] ]! !

!CompiledMethod methodsFor: 'file in/out' stamp: 'jmv 12/29/2016 15:25:13'!
                         storeDataOn: aDataStream
	"Store myself on a DataStream.  I am a mixture of objects and raw data bytes.  Only use this for blocks.  Normal methodDictionaries should not be put out using ReferenceStreams.  Their fileOut should be attached to the beginning of the file."

	| byteLength lits |
	"No inst vars of the normal type"
	byteLength _ self basicSize.
	aDataStream
		beginInstance: self class
		size: byteLength.
	lits _ self numLiterals + 1.	"counting header"
	1 to: lits do:
		[:ii | aDataStream nextPut: (self objectAt: ii)].
	lits*Smalltalk wordSize+1 to: byteLength do:
		[:ii | aDataStream byteStream nextPut: (self basicAt: ii)].
			"write bytes straight through to the file"! !

!CompiledMethod methodsFor: 'ometa2preload' stamp: 'pb 5/11/2016 15:28'!
    methodNode
	"Return the parse tree that represents self.  Note: this is brittle and will need to be updated to reflect any upstream methodNode changes in the future."
	| aClass source |
	aClass := self methodClass.
	source := self
				getSourceFor: (self selector ifNil: [self defaultSelector])
				in: aClass.
	"Fix for debugging OMeta"
	((self methodClass inheritsFrom: OMeta2) and: [
		OMeta2RuleParser isOMeta2Rule: (self getSourceFromFile ifNil: [''])
	]) ifTrue: [
		^ self decompile
	]. "end OMeta"
	^(Parser new
		encoderClass: EncoderForV3PlusClosures;
		parse: source class: aClass)
			sourceText: source;
			yourself! !


CompiledMethod class
	instanceVariableNames: ''!

!CompiledMethod class methodsFor: 'method encoding' stamp: 'HAW 8/28/2017 13:59:31'!
headerFlagForEncoder: anEncoder
	
	(anEncoder class includesBehavior: PrimaryBytecodeSetEncoderClass) ifTrue: [^0].
	(anEncoder class includesBehavior: SecondaryBytecodeSetEncoderClass) ifTrue: [^SmallInteger minVal].
	
	self error: 'The encoder is not one of the two installed bytecode sets'! !


InstructionStream subclass: #ContextPart
	instanceVariableNames: 'stackp'
	classVariableNames: 'PrimitiveFailToken QuickStep ValueIndex'
	poolDictionaries: ''
	category: 'Kernel-Methods'!

!ContextPart methodsFor: 'debugger access' stamp: 'HAW 1/12/2017 17:48:35'!
             arguments

	| arguments |

	arguments _ Array new: self selector numArgs.
	1 to: arguments size do: [ :index | arguments at: index put: (self tempAt: index)].

	^arguments.
	
	! !

!ContextPart methodsFor: 'debugger access' stamp: 'HAW 1/12/2017 17:47:30'!
                               messageForYourself

	^Message selector: self selector arguments: self arguments.
	! !

!ContextPart methodsFor: 'debugger access' stamp: 'jmv 8/25/2017 10:55:54'!
                             print: anObject on: aStream
	"Safely print anObject in the face of direct ProtoObject subclasses."
	| objClass title |
	objClass _ self objectClass: anObject.
	(objClass canUnderstand: #printOn:) ifTrue: [
		^anObject printOn: aStream].
	title _ objClass name.
	aStream
		nextPutAll: title aOrAnPrefix;
		space;
		nextPutAll: title! !


Inspector subclass: #ContextVariablesInspector
	instanceVariableNames: 'fieldList'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Debugger'!

!ContextVariablesInspector methodsFor: 'shout styling' stamp: 'jmv 8/17/2017 16:58:45'!
                        bindingNamesDo: aBlock
	fieldList do: aBlock! !

!ContextVariablesInspector methodsFor: 'shout styling' stamp: 'jmv 8/17/2017 16:58:56'!
                       hasBindingOf: aString
	^ fieldList includes: aString! !


Form subclass: #Cursor
	instanceVariableNames: ''
	classVariableNames: 'BlankCursor BottomLeftCursor BottomRightCursor CornerCursor CrossHairCursor CurrentCursor DownCursor MarkerCursor MenuCursor MoveCursor NormalCursor OriginCursor ReadCursor ResizeLeftCursor ResizeTopCursor ResizeTopLeftCursor ResizeTopRightCursor RightArrowCursor SquareCursor TargetCursor TopLeftCursor TopRightCursor UpCursor WaitCursor WebLinkCursor WriteCursor XeqCursor'
	poolDictionaries: ''
	category: 'Graphics-Display Objects'!

!Cursor methodsFor: 'converting' stamp: 'jmv 2/25/2011 19:47'!
         asCursorForm
	| form |
	form _ Form extent: self extent depth: 8.
	form fillShape: self fillColor: Color black at: offset negated.
	^ form offset: offset! !

!Cursor methodsFor: 'converting' stamp: 'jmv 6/19/2017 15:47:21'!
enlargedBy: scale
	"Big cursors are 32 bits deep (ARGB premultiplied)"
	| big |
	scale = 1 ifTrue: [^self].
	big := CursorWithAlpha extent: self extent * scale depth: 32.
	(self asCursorForm magnifyBy: scale) displayOn: big.
	big offset: (self offset - 0.5 * scale min: `0@0` max: big extent negated) asIntegerPoint.
	big fallback: self.
	^big! !


Cursor subclass: #CursorWithMask
	instanceVariableNames: 'maskForm'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Display Objects'!

!CursorWithMask methodsFor: 'converting' stamp: 'jmv 2/25/2011 19:47'!
  asCursorForm
	| form |
	form _ Form extent: self extent depth: 8.
	form fillShape: maskForm fillColor: Color white.
	form fillShape: self fillColor: Color black at: offset negated.
	^ form offset: offset! !


Stream subclass: #DataStream
	instanceVariableNames: 'byteStream topCall basePos'
	classVariableNames: 'ReferenceTypes TypeMap'
	poolDictionaries: ''
	category: 'System-Object Storage'!

!DataStream methodsFor: 'write and read' stamp: 'jmv 12/29/2016 15:27:40'!
         readMethod
	"PRIVATE -- Read the contents of an arbitrary instance.
	 ASSUMES: readDataFrom:size: sends me beginReference: after it
	   instantiates the new object but before reading nested objects.
	 NOTE: We must restore the current reference position after
	   recursive calls to next.
	Let the instance, not the class read the data.  "
	| instSize refPosn newClass className xxHeader nLits byteCodeSizePlusTrailer newMethod lits |

	instSize _ (byteStream nextUnsignedInt32BigEndian: true) - 1.
	refPosn _ self getCurrentReference.
	className _ self next.
	newClass _ Smalltalk at: className asSymbol.

	xxHeader _ self next.
		"nArgs _ (xxHeader >> 24) bitAnd: 16rF."
		"nTemps _ (xxHeader >> 18) bitAnd: 16r3F."
		"largeBit _ (xxHeader >> 17) bitAnd: 1."
	nLits _ (xxHeader >> 9) bitAnd: 16rFF.
		"primBits _ ((xxHeader >> 19) bitAnd: 16r600) + (xxHeader bitAnd: 16r1FF)."
	byteCodeSizePlusTrailer _ instSize - (newClass instSize "0") - (nLits + 1 * Smalltalk wordSize).

	newMethod _ newClass 
		newMethod: byteCodeSizePlusTrailer
		header: xxHeader.

	self setCurrentReference: refPosn.  "before readDataFrom:size:"
	self beginReference: newMethod.
	lits _ newMethod numLiterals + 1.	"counting header"
	2 to: lits do:
		[:ii | newMethod objectAt: ii put: self next].
	lits*Smalltalk wordSize+1 to: newMethod basicSize do:
		[:ii | newMethod basicAt: ii put: byteStream next].
			"Get raw bytes directly from the file"
	self setCurrentReference: refPosn.  "before returning to next"
	^ newMethod! !

!DataStream methodsFor: 'other' stamp: 'jmv 12/29/2016 15:36:22'!
                           vacantRef
	"Answer the magic 32-bit constant we use ***ON DISK*** as a stream 'reference
	 position' to identify a reference that's not yet filled in. This must be a
	 value that won't be used as an ordinary reference. Cf. outputReference: and
	 readReference. -- 
	 NOTE: We could use a different type ID for vacant-refs rather than writing
		object-references with a magic value. (The type ID and value are
		overwritten by ordinary object-references when weak refs are fullfilled.)"

	"In 32 bit Cuis it was:"
	"^ SmallInteger maxVal"

	"Use that very same value even if in 64 bit Cuis.
	This means that DataStreams are limited to 1GibiBytes in size."
	^16r3FFFFFFF! !


DataStream class
	instanceVariableNames: ''!

!DataStream class methodsFor: 'as yet unclassified'!
                           example
    "An example and test of DataStream/ReferenceStream.
     11/19/92 jhm: Use self testWith:."
    "DataStream example"
    "ReferenceStream example"
    | input sharedPoint |

    "Construct the test data."
    input _ Array new: 9.
    input at: 1 put: nil.
    input at: 2 put: true.
    input at: 3 put: (Form extent: 63 @ 50 depth: 8).
		(input at: 3) fillWithColor: Color lightBlue.
    input at: 4 put: #(3 3.0 'three').
    input at: 5 put: false.
    input at: 6 put: 1024 @ -2048.
    input at: 7 put: #x.
    input at: 8 put: (Array with: (sharedPoint _ 0 @ -30000)).
    input at: 9 put: sharedPoint.

    "Write it out, read it back, and return it for inspection."
    ^ self testWith: input! !

!DataStream class methodsFor: 'as yet unclassified' stamp: 'jmv 12/30/2016 17:33:27'!
                            unStream: aByteArray

	^(self on: ((RWBinaryOrTextStream with: aByteArray) reset; binary)) next! !


Timespan subclass: #Date
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Chronology'!

!Date methodsFor: 'smalltalk-80' stamp: 'jmv 5/12/2017 10:54:58'!
                      weekdayIndex
	"Sunday=1, ... , Saturday=7
	Monday=1, ... , Sunday=7
	'12 May 2017 ' asDate weekdayIndex = 5
	"

	^ self dayOfWeek! !


Date class
	instanceVariableNames: ''!

!Date class methodsFor: 'squeak protocol' stamp: 'jmv 5/10/2017 21:56:27'!
      readFrom: aStream 
	"Read a Date from the stream in any of the forms:
		<day> <month> <year>		(15 April 1982; 15-APR-82; 15.4.82; 15APR82)  
		<month> <day> <year>		(April 15, 1982; 4/15/82)
		<year>-<month>-<day>		(1982-04-15) (ISO8601)"
	| day month year firstAsNumber firstAsNumberSign |
	firstAsNumberSign := aStream peek = $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	aStream peek isDigit ifTrue: [
		firstAsNumber := (Integer readFrom: aStream) * firstAsNumberSign.
		(firstAsNumber < 0 or: [firstAsNumber > 31])
			ifTrue: [year := firstAsNumber]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	aStream peek isLetter
		ifTrue: ["MonthName-DD-YY or DD-MonthName-YY or YY-MonthName-DD"
			month _ String streamContents: [ :strm |
				[ aStream peek isLetter ] whileTrue: [ strm nextPut: aStream next ]].
			[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
			firstAsNumber
				ifNil: ["MonthName DD YY"
					day := Integer readFrom: aStream]
				ifNotNil: [
					year ifNil: ["DD MonthName YY"
						day := firstAsNumber]]]
		ifFalse: ["MM-DD-YY or DD-MM-YY or YY-MM-DD"
			year 
				ifNil: ["MM-DD-YY or DD-MM-YY"
					firstAsNumber > 12
						ifTrue: ["DD-MM-YY"
							day := firstAsNumber.
							month := Month nameOfMonth: (Integer readFrom: aStream)]
						ifFalse: ["MM-DD-YY"
							month := Month nameOfMonth: firstAsNumber.
							day := Integer readFrom: aStream]]
				ifNotNil: ["YY-MM-DD"
					month := Month nameOfMonth: (Integer readFrom: aStream)]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	year
		ifNil: [year := Integer readFrom: aStream]
		ifNotNil: [day := Integer readFrom: aStream].
	(year < 100 and: [year >= 0])  ifTrue: [
		year _  year < 69 
			ifTrue: [2000 + year]
			ifFalse: [1900 + year]].

	^ self year: year month: month day: day! !

!Date class methodsFor: 'instance creation' stamp: 'jmv 5/12/2017 16:48:52'!
 includingDateAndTime: aDateAndTime

	^self basicNew
 		start: aDateAndTime midnight;
		duration: (Duration days: 1);
		yourself! !


Magnitude subclass: #DateAndTime
	instanceVariableNames: 'seconds offset jdn nanos'
	classVariableNames: 'LastTick LastTickSemaphore LocalTimeZone'
	poolDictionaries: ''
	category: 'Kernel-Chronology'!

!DateAndTime methodsFor: 'ansi protocol' stamp: 'pb 9/13/2017 06:20:43'!
       - operand
	"operand is a DateAndTime or a Duration.
	Double dispatch"

	^ operand subtractFrom: self! !

!DateAndTime methodsFor: 'ansi protocol' stamp: 'jmv 5/12/2017 10:55:06'!
             dayOfWeek

	"
	Sunday=1, ... , Saturday=7
	Monday=1, ... , Sunday=7
	'12 May 2017 ' asDate dayOfWeek = 5
	"

	^ (jdn rem: 7) + 1! !

!DateAndTime methodsFor: 'ansi protocol' stamp: 'jmv 5/12/2017 10:53:00'!
                 dayOfWeekName
	"
	'12 May 2017 ' asDate dayOfWeek = 5 
	'12 May 2017 ' asDate dayOfWeekName = #Friday 
	"

	^ Week nameOfDay: self dayOfWeek
! !

!DateAndTime methodsFor: 'private' stamp: 'pb 9/13/2017 06:17:35'!
           subtractDateAndtime: operand
	"operand is a DateAndTime or a Duration"

	| lvalue rvalue |
	offset = operand offset
		ifTrue: [
			lvalue _ self.
			rvalue _ operand ]
		ifFalse: [
			lvalue _ self asUTC.
			rvalue _ operand asUTC ].
	^ Duration
		seconds: (Time secondsInDay *(lvalue julianDayNumber - rvalue julianDayNumber)) + 
					(lvalue secondsSinceMidnight - rvalue secondsSinceMidnight)
		nanoSeconds: lvalue nanoSecond - rvalue nanoSecond! !

!DateAndTime methodsFor: 'private' stamp: 'pb 9/13/2017 06:17:41'!
                        subtractDuration: operand
	"operand is a DateAndTime or a Duration"

	^self + operand negated! !

!DateAndTime methodsFor: 'double dispatching' stamp: 'jmv 5/12/2017 17:17:21'!
               includingTimespanOf: aTimespanClass

	^ aTimespanClass includingDateAndTime: self! !

!DateAndTime methodsFor: 'double dispatching' stamp: 'pb 9/13/2017 06:20:33'!
                            subtractFrom: aDateAndTime

	^ aDateAndTime subtractDateAndtime: self! !


CodeProvider subclass: #Debugger
	instanceVariableNames: 'interruptedProcess contextStack contextStackTop contextStackIndex contextStackList receiverInspector contextVariablesInspector externalInterrupt proceedValue selectingPC savedCursor labelString interruptedProcessUI sendProceeds'
	classVariableNames: 'ErrorRecursion'
	poolDictionaries: ''
	category: 'Tools-Debugger'!

!Debugger methodsFor: 'context stack menu' stamp: 'HAW 7/29/2017 20:49:55'!
                doStep
	"Send the selected message in the accessed method, and regain control 
	after the invoked method returns."
	
	| currentContext newContext |

	currentContext := self selectedContext.
	newContext := self handleLabelUpdatesIn: [interruptedProcess completeStep: currentContext]
						whenExecuting: currentContext.
	newContext == currentContext ifTrue:
		[newContext := interruptedProcess stepToSendOrReturn].
	self contextStackIndex > 1
		ifTrue: [self resetContext: newContext]
		ifFalse:
			[newContext == currentContext
				ifTrue: [self changed: #contentsSelection.
						self updateInspectors]
				ifFalse: [self resetContext: newContext]].
! !

!Debugger methodsFor: 'context stack menu' stamp: 'HAW 7/29/2017 20:50:01'!
    handleLabelUpdatesIn: aBlock whenExecuting: aContext
	"Send the selected message in the accessed method, and regain control 
	after the invoked method returns."
	
	^aBlock
		on: Notification
		do: [:ex|
			(ex tag isArray
			 and: [ex tag size = 2
			 and: [(ex tag first == aContext or: [ex tag first hasSender: aContext])]])
				ifTrue:
					[self labelString: ex tag second description.
					 ex resume]
				ifFalse:
					[ex pass]]! !

!Debugger methodsFor: 'context stack menu' stamp: 'HAW 7/29/2017 20:50:15'!
                            stepIntoBlock
	"Send messages until you return to the present method context.
	 Used to step into a block in the method."

	self 
		handleLabelUpdatesIn: [interruptedProcess stepToHome: self selectedContext]
		whenExecuting: self selectedContext.
	self resetContext: interruptedProcess stepToSendOrReturn! !

!Debugger methodsFor: 'code pane' stamp: 'jmv 8/18/2017 18:02:55'!
        contentsSelection

	"If we are just creating the method in the debugger, help the user by selecting the method body."
	| sendInterval |
	currentCompiledMethod ifNotNil: [
		((currentCompiledMethod hasLiteral: #shouldBeImplemented) and: [
			(currentCompiledMethod abstractPCForConcretePC: self selectedContext pc) = 1]) ifTrue: [
				sendInterval _ (self selectedContext debuggerMap abstractSourceMap at: 2 ifAbsent: [nil]).
				sendInterval ifNotNil: [ ^ sendInterval first - 5 to: sendInterval last + 1 ]]].

	^self pcRange! !

!Debugger methodsFor: 'shout styling' stamp: 'jmv 8/26/2017 19:21:36'!
       shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Set the classOrMetaClass in anSHTextStyler, so that identifiers
	will be resolved correctly.
	Answer true to allow styling to proceed, or false to veto the styling"
	
	self isModeStyleable ifFalse: [^false].
	anSHTextStyler 
		classOrMetaClass: self selectedClassOrMetaClass;
		disableFormatAndConvert;
		workspace: self.
	^true! !

!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 18:31:48'!
                      askForSuperclassOf: aClass toImplement: aSelector ifCancel: cancelBlock

	^self askForSuperclassOf: aClass upTo: ProtoObject toImplement: aSelector ifCancel: cancelBlock
! !

!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 18:31:14'!
        askForSuperclassOf: aClass upTo: aSuperclass toImplement: aSelector ifCancel: cancelBlock

	| classes chosenClassIndex |

	classes _ aClass withAllSuperclassesUpTo: aSuperclass. 
	chosenClassIndex _ PopUpMenu
		withCaption: 'Define #', aSelector, ' in which class?'
		chooseFrom: (classes collect: [:c | c name]).
	chosenClassIndex = 0 ifTrue: [^ cancelBlock value].

	^ classes at: chosenClassIndex! !

!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 18:46:00'!
   createMethod

	self wasInterrupedOnDoesNotUnderstand ifTrue: [ ^self createMethodWhenDoesNotUndertand ].
	self wasInterruptedOnSubclassResponsibility ifTrue: [ ^self createMethodOnSubclassResponsibility ].
	
	self inform: 'Only available for #doesNotUndertand: and #subclassResponsibility' ! !

!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 18:45:03'!
                createMethodOnSubclassResponsibility

	| message chosenClass subclassResponsibilityContext |
	
	subclassResponsibilityContext _ self interruptedContext sender sender.
	message _ subclassResponsibilityContext messageForYourself.
	
	chosenClass _ self
		askForSuperclassOf: subclassResponsibilityContext receiver class
		upTo: subclassResponsibilityContext method methodClass
		toImplement: message selector
		ifCancel: [^self].
		
	self implement: message inClass: chosenClass context: subclassResponsibilityContext 

! !

!Debugger methodsFor: 'method creation' stamp: 'HAW 3/17/2017 10:24:51'!
             createMethodWhenDoesNotUndertand

	| message chosenClass interruptedContext |
	
	"The doesNotUndertand context must be selected - Hernan"
	contextStackIndex = 1 ifFalse: [ self contextStackIndex: 1 oldContextWas: self selectedContext ].
		
	interruptedContext _ self interruptedContext.
	message _ interruptedContext tempAt: 1.
	
	chosenClass _ self
		askForSuperclassOf: interruptedContext receiver class
		toImplement: message selector
		ifCancel: [^self].
	
	self implement: message inClass: chosenClass context: self selectedContext

! !

!Debugger methodsFor: 'method creation' stamp: 'HAW 8/22/2017 11:22:30'!
                        implement: aMessage inClass: aClass context: aContext 
	
	aClass
		compile: (aMessage createStubMethodFor: aClass)
		classified: (self askForCategoryIn: aClass default: 'as yet unclassified').
		
	aContext privRefreshWith: (aClass lookupSelector: aMessage selector).
	aMessage arguments withIndexDo: [ :arg :index | aContext tempAt: index put: arg ].
	self resetContext: aContext! !

!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 17:22:47'!
                       shouldBeAbleToCreateMethod

	^self wasInterrupedOnDoesNotUnderstand or: [ self wasInterruptedOnSubclassResponsibility]! !

!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 17:22:28'!
                            wasInterrupedOnDoesNotUnderstand

	^self interruptedContext selector == #doesNotUnderstand:! !

!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 17:25:23'!
                       wasInterruptedOnSubclassResponsibility

	^self interruptedContext sender ifNil: [ false ] ifNotNil: [ :senderContext | senderContext selector == #subclassResponsibility ]! !

!Debugger methodsFor: 'testing' stamp: 'jmv 8/18/2017 17:41:49'!
                is: aSymbol
	^ aSymbol == #providesBindings or: [ super is: aSymbol ]! !


Debugger class
	instanceVariableNames: ''!

!Debugger class methodsFor: 'opening' stamp: 'pb 7/27/2017 03:27:10'!
   openOn: process context: context label: title fullView: bool
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."
	| w |
	Preferences logDebuggerStackToFile ifTrue: [
		Smalltalk
			logError: title
			inContext: context
			to: 'CuisDebug.log' ].
	w := ProjectX newProcessIfUIX: process.
	"schedule debugger in deferred UI message to address redraw
	problems after opening a debugger e.g. from the testrunner."
	WorldState addDeferredUIMessage: [
		[ | debugger |
		"In case an error in Morphic code got us here, ensure mouse focus has been released"
		true runningWorld ifNotNil: [ :rWorld |
			rWorld activeHand ifNotNil: [ :aHand |
				aHand releaseMouseFocus ]].
		debugger := self new
			process: process
			context: context.
		debugger interruptedProcessUI: w.
		bool
			ifTrue: [ debugger openFullMorphicLabel: title ]
			ifFalse: [
				PreDebugWindow
					open: debugger
					label: title
					message: nil ]]
			on: UnhandledError
			do: [ :exOuter | | errorDescription |
				errorDescription := 'Error while trying to open Debugger' , String newLineString , 'Orginal error: ' , title asString , '.' , String newLineString , '	Debugger error: ' ,
					([ exOuter description ]
						on: UnhandledError
						do: [ :exInner |
							exInner return: 'a ' , exInner class printString ]) , ':'.
				self primitiveError: errorDescription ]].
	process suspend.! !


CodeWindow subclass: #DebuggerWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!

!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 12/29/2016 10:59:15'!
               buildMorphicWindow
	"Open a full morphic debugger with the given label"

	| upperMorph receiverInspector receiverInspectorText contextVariableInspector contextVariableInspectorText bottomMorph |

	upperMorph _ PluggableListMorph
		model: model 
		listGetter: #contextStackList
		indexGetter: #contextStackIndex
		indexSetter: #toggleContextStackIndex:
		mainView: self
		menuGetter: #contextStackMenu
		keystrokeAction: #contextStackKey:from:.

	receiverInspector _ PluggableListMorph
			model: model receiverInspector
			listGetter: #fieldList
			indexGetter: #selectionIndex 
			indexSetter: #toggleIndex:
			mainView: self
			menuGetter: #receiverFieldListMenu
			keystrokeAction: #inspectorKey:from:.
	receiverInspector doubleClickSelector: #inspectSelection.
	receiverInspectorText _ TextModelMorph
			textProvider: model receiverInspector
			textGetter: #acceptedContents 
			textSetter: #accept:
			selectionGetter: #contentsSelection.
	contextVariableInspector _ PluggableListMorph
			model: model contextVariablesInspector 
			listGetter: #fieldList
			indexGetter: #selectionIndex 
			indexSetter: #toggleIndex:
			mainView: self
			menuGetter: #contextFieldListMenu
			keystrokeAction: #inspectorKey:from:.
	contextVariableInspector doubleClickSelector: #inspectSelection.
	contextVariableInspectorText _ TextModelMorph
			textProvider: model contextVariablesInspector
			textGetter: #acceptedContents 
			textSetter: #accept:
			selectionGetter: #contentsSelection.

	bottomMorph _ LayoutMorph newRow.
	bottomMorph
		addMorph: receiverInspector proportionalWidth: 0.2;
		addAdjusterAndMorph: receiverInspectorText proportionalWidth: 0.3;
		addAdjusterAndMorph: contextVariableInspector proportionalWidth: 0.2;
		addAdjusterAndMorph: contextVariableInspectorText proportionalWidth: 0.3.

	self layoutMorph
		addMorph: upperMorph proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.55;
		addAdjusterAndMorph: bottomMorph proportionalHeight: 0.2! !

!DebuggerWindow methodsFor: 'GUI building' stamp: 'HAW 1/12/2017 18:46:32'!
     customButtonSpecs
	"Answer an array of elements of the form wording, selector, help-message, that characterize the custom button row of a debugger."

	^#(
		('Restart'		restart				'reset this context to its start.')
		('Into'			send					'step Into message sends')
		('Over'			doStep				'step Over message sends')
		('Through'		stepIntoBlock		'step into a block')
		('Full Stack'	fullStack			'show full stack')
		('Where'		where				'select current pc range')
		('Create'		createMethod		'create method'))! !

!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 1/17/2017 10:51:52'!
                         initialExtent
	^ RealEstateAgent standardWindowExtent * 3 // 2! !


Delay class
	instanceVariableNames: ''!

!Delay class methodsFor: 'instance creation' stamp: 'HAW 3/27/2017 09:08:00'!
     forDuration: aDuration

	^ self forMilliseconds: aDuration totalMilliseconds! !

!Delay class methodsFor: 'timer process' stamp: 'jmv 3/7/2017 09:51:10'!
      handleTimerEvent
	"Handle a timer event; which can be either:
		- a schedule request (ScheduledDelay notNil)
		- an unschedule request (FinishedDelay notNil)
		- a timer signal (not explicitly specified)
	We check for timer expiry every time we get a signal."
	| nowTick nextTick afterwardsTick |
	"Wait until there is work to do."
	TimingSemaphore wait.

	"Process any schedule requests"
	ScheduledDelay ifNotNil: [
		"Schedule the given delay"
		self scheduleDelay: ScheduledDelay.
		ScheduledDelay := nil.
		ScheduledDelayNilledSemaphore initSignals. 
		ScheduledDelayNilledSemaphore signal ].

	"Process any unschedule requests"
	FinishedDelay ifNotNil: [
		self unscheduleDelay: FinishedDelay.
		FinishedDelay := nil.
		FinishedDelayNilledSemaphore initSignals.
		FinishedDelayNilledSemaphore signal ].

	"Check for clock wrap-around."
	nowTick := Time millisecondClockValue.
	nowTick < ActiveDelayStartTime ifTrue: [
		"clock wrapped"
		self saveResumptionTimes.
		self restoreResumptionTimes ].
	ActiveDelayStartTime := nowTick.

	"Signal any expired delays"
	[ ActiveDelay notNil and:[ nowTick >= ActiveDelay resumptionTime ]] whileTrue: [
		ActiveDelay signalWaitingProcess.
		SuspendedDelays isEmpty 
			ifTrue: [ ActiveDelay := nil ] 
			ifFalse:[ ActiveDelay := SuspendedDelays removeFirst ]].

	"And signal when the next request is due. We sleep at most 1sec here
	as a soft busy-loop so that we don't accidentally miss signals."
	nextTick := nowTick + 1000.
	ActiveDelay ifNotNil: [
		nextTick := nextTick min: ActiveDelay resumptionTime ].
	nextTick := nextTick min: 16r1FFFFFFF.	"MillisecondClockMask"

	"Since we have processed all outstanding requests, reset the timing semaphore so
	that only new work will wake us up again. Do this RIGHT BEFORE setting the next
	wakeup call from the VM because it is only signaled once so we mustn't miss it."
	TimingSemaphore initSignals.
	Delay primSignal: TimingSemaphore atMilliseconds: nextTick.

	"This test is necessary for the obscure case that the msecs clock rolls over
	after nowTick has been computed (unlikely but not impossible). In this case we'd
	wait for MillisecondClockMask msecs (roughly six days) or until another delay gets
	scheduled (which may not be any time soon). In any case, since handling the
	condition is easy, let's just deal with it."
	afterwardsTick _ Time millisecondClockValue.
	afterwardsTick < nowTick  						"Means clock rollover."
		ifTrue: [ TimingSemaphore signal ]. "retry"

	"It seems that #primSignal:atMilliseconds: might not signal the semaphore if the requested moment is in the past.
	This behavior was observed in Linux Spur64 VMs.
	If this happens, next delay never finishes. Usual symptom is frozen Morphic.
	If there is any risk of this happening, just do another iteration right now."
	nextTick < afterwardsTick  						"We're already late for next signal."
		ifTrue: [ TimingSemaphore signal ]. "retry"! !

!Delay class methodsFor: 'primitives' stamp: 'jmv 3/7/2017 12:19:39'!
                      primSignal: aSemaphore atUTCMicroseconds: anInteger
	"Signal the semaphore when the UTC microsecond clock reaches the value of the second argument.
	 Fail if the first argument is neither a Semaphore nor nil.
	Fail if the second argument is not an integer (either SmallInteger or LargePositiveInteger).
	See #primUtcMicrosecondClock
	 Essential. See Object documentation whatIsAPrimitive."
	<primitive: 242>
	^self primitiveFailed! !


Set subclass: #Dictionary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Unordered'!

!Dictionary methodsFor: 'removing' stamp: 'jmv 7/17/2017 15:44:29'!
unreferencedKeys
	"| uk | (Time millisecondsToRun: [uk := TextConstants unreferencedKeys]) -> uk"

	^'Scanning for references . . .' 
		displayProgressAt: Sensor mousePoint
		from: 0
		to: Smalltalk classNames size * 2
		during: 
			[:barBlock | | currentClass n associations referencedAssociations |
			currentClass := nil.
			n := 0.
			associations := self associations asIdentitySet.
			referencedAssociations := IdentitySet new: associations size.
			Smalltalk allSelect:
				[:m|
				m methodClass ~~ currentClass ifTrue:
					[currentClass := m methodClass.
					 barBlock value: (n := n + 1)].
				m literalsDo:
					[:l|
					(l isVariableBinding and: [associations includes: l]) ifTrue:
						[referencedAssociations add: l]].
				false].
			((associations reject: [:assoc | referencedAssociations includes: assoc]) collect: [:assoc| assoc key]) asSet]! !


Dictionary class
	instanceVariableNames: ''!

!Dictionary class methodsFor: 'instance creation' stamp: 'pb 7/29/2017 22:47:17'!
                            newFrom: aDict 
	"Answer an instance of me containing the same associations as aDict.
	 Error if any key appears twice."
	| newDictionary |
	newDictionary _ self new: aDict size.
	aDict associationsDo:
		[:x |
		(newDictionary includesKey: x key)
			ifTrue: [self error: 'Duplicate key: ', x key printString]
			ifFalse: [newDictionary add: x copy]].
	^ newDictionary

"	NewDictionary newFrom: {1->#a. 2->#b. 3->#c}
	{1->#a. 2->#b. 3->#c} as: NewDictionary
	NewDictionary newFrom: {1->#a. 2->#b. 1->#c}
	{1->#a. 2->#b. 1->#c} as: NewDictionary
"! !


Object subclass: #DifferenceFinder
	instanceVariableNames: 'base case x y map tally matrix differences'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Code Differ'!

!DifferenceFinder methodsFor: 'private' stamp: 'jmv 6/19/2017 16:02:44'!
                         maxLengthPoints
	| max points |
	max := self maxLength.
	max = 0 ifTrue: [^Array with: `0 @ 0`].
	points := OrderedCollection new.
	tally withIndexesDo: [:i :j :t | t = max ifTrue: [points add: i @ j]].
	^points! !


FileSystemEntry subclass: #DirectoryEntry
	instanceVariableNames: 'children'
	classVariableNames: 'CurrentDirectory ImageDirectory VMDirectory'
	poolDictionaries: ''
	category: 'System-FileMan-Core'!

!DirectoryEntry methodsFor: 'enumeration' stamp: 'jmv 1/18/2017 11:13:59'!
                   directoriesDo: aBlock
	self childrenDo: [ :each |
		each isFile ifFalse: [
			aBlock value: each ]]! !

!DirectoryEntry methodsFor: 'enumeration' stamp: 'jmv 1/18/2017 11:19:42'!
             directoryMatching: pattern
"
	DirectoryEntry smalltalkImageDirectory directoryMatching: 'C*Pack*'.
	DirectoryEntry smalltalkImageDirectory directoryMatching: 'xC*Pack*'.
"
	self directoriesDo: [ :directory |
		(pattern match: directory name)
			ifTrue: [ ^ directory ]].
	^ nil! !

!DirectoryEntry methodsFor: 'enumeration' stamp: 'jmv 1/18/2017 11:20:57'!
                           fileMatching: pattern
"
	DirectoryEntry smalltalkImageDirectory fileMatching: '*.image'.
	DirectoryEntry smalltalkImageDirectory fileMatching: 'x*.image'.
"
	self filesDo: [ :file |
		(pattern match: file name)
			ifTrue: [ ^ file ]].
	^ nil! !

!DirectoryEntry methodsFor: 'enumeration' stamp: 'jmv 1/18/2017 11:14:17'!
                               filesDo: aBlock
	self childrenDo: [ :each |
		each isFile ifTrue: [
			aBlock value: each ]]! !


Form subclass: #DisplayScreen
	instanceVariableNames: ''
	classVariableNames: 'Damage ScreenUpdaterProcess ScreenUpdaterSemaphore'
	poolDictionaries: ''
	category: 'Graphics-Display Objects'!

!DisplayScreen methodsFor: 'displaying' stamp: 'HernanWilkinson 1/10/2017 18:45:48'!
        flash: aRectangle with: aColor

	self fill: aRectangle fillColor: aColor.
	self forceToScreen: aRectangle.
	(Delay forMilliseconds: 100) wait.
	self fill: aRectangle fillColor: aColor.
	self forceToScreen: aRectangle! !


DisplayScreen class
	instanceVariableNames: ''!

!DisplayScreen class methodsFor: 'snapshots' stamp: 'jmv 6/19/2017 16:02:49'!
   actualScreenSize
	<primitive: 106>
	^ `640@480`! !

!DisplayScreen class methodsFor: 'snapshots' stamp: 'jmv 6/19/2017 16:02:57'!
                              shutDown 
	"Minimize Display memory saved in image"
	Display setExtent: `240@120` depth: Display nativeDepth.
	ScreenUpdaterProcess ifNotNil: [
		ScreenUpdaterProcess terminate.
		ScreenUpdaterProcess _ nil ]! !


Stream subclass: #DummyStream
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Object Storage'!

!DummyStream methodsFor: 'as yet unclassified' stamp: 'KenD 11/5/2016 16:17:09'!
             space! !


Magnitude subclass: #Duration
	instanceVariableNames: 'nanos seconds'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Chronology'!

!Duration methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 10:59:51'!
                       printOn: aStream
	"Format as per ANSI 5.8.2.16: [-]D:HH:MM:SS[.S]
	(Duration days: 2 hours: 3 minutes: 16 seconds: 43) printString =  '2:03:16:43' 
	"
	| d h m s n |
	d _ self days abs.
	h _ self hours abs.
	m _ self minutes abs.
 	s _ self seconds abs truncated.
	n _ self nanoSeconds abs. 	self negative ifTrue: [ aStream nextPut: $- ].
	d printOn: aStream. aStream nextPut: $:.
	h printOn: aStream length: 2 zeroPadded: true.aStream nextPut: $:.
	m printOn: aStream length: 2 zeroPadded: true.aStream nextPut: $:.
	s printOn: aStream length: 2 zeroPadded: true.
	n = 0 ifFalse: [
		| z ps |
		aStream nextPut: $..
		ps _ n printString padded: #left to: 9 with: $0. 
		z _ ps findLast: [ :c | c digitValue > 0 ].
		ps from: 1 to: z do: [ :c | aStream nextPut: c ] ]! !

!Duration methodsFor: 'double dispatching' stamp: 'pb 9/13/2017 06:21:11'!
                 subtractFrom: aDateAndTimeOrDate

	^aDateAndTimeOrDate subtractDuration: self! !


Editor class
	instanceVariableNames: 'shortcuts cmdShortcuts'!

!Editor class methodsFor: 'class initialization' stamp: 'jmv 12/30/2016 11:00:14'!
                          initialize
	"
	Editor initialize
	"
	self withAllSubclassesDo: [ :c |
		c basicInitialize ]! !


BorderedRectMorph subclass: #EllipseMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Basic'!

!EllipseMorph methodsFor: 'geometry testing' stamp: 'jmv 6/19/2017 16:03:06'!
 morphContainsPoint: aLocalPoint

	| radius other delta xOverY |
	((`0@0` extent: extent) containsPoint: aLocalPoint) ifFalse: [^ false].  "quick elimination"
	extent > `1@1`
		ifFalse: [^ true].  "Degenerate case -- code below fails by a bit"

	radius _ extent y asFloat / 2.
	other _ extent x asFloat / 2.
	delta _ aLocalPoint - (other@radius).
	xOverY _ extent x asFloat / extent y asFloat.
	^ (delta x asFloat / xOverY) squared + delta y squared <= radius squared! !

!EllipseMorph methodsFor: 'visual properties' stamp: 'ar 6/25/1999 11:14'!
                              defaultColor
	"Return the default fill style for the receiver"
	^Color yellow! !


EllipseMorph class
	instanceVariableNames: ''!

!EllipseMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:50:14'!
    categoryInNewMorphMenu
	^ 'Basic'! !


InputSensor subclass: #EventSensor
	instanceVariableNames: 'mouseButtons mousePosition keyboardBuffer interruptKey interruptSemaphore eventQueue inputSemaphore lastEventPoll hasInputSemaphore'
	classVariableNames: 'EventTicklerProcess'
	poolDictionaries: ''
	category: 'Kernel-Processes'!

!EventSensor methodsFor: 'initialization' stamp: 'jmv 6/19/2017 15:48:40'!
            initialize
	"Run the I/O process"
	mouseButtons _ 0.
	mousePosition _ `0@0`.
	self setInterruptKey: (interruptKey ifNil: [$. numericValue bitOr: 16r0800 ]). 	"cmd-."
	interruptSemaphore _ (Smalltalk specialObjectsArray at: 31) ifNil: [Semaphore new].
	self flushAllButDandDEvents.
	inputSemaphore _ Semaphore new.
	hasInputSemaphore _ false.

	self primSetInputSemaphore: (Smalltalk registerExternalObject: inputSemaphore).
	self installInterruptWatcher.
	self installEventTickler.
	self flushAllButDandDEvents.

	"Attempt to discover whether the input semaphore is actually being signaled."
	hasInputSemaphore _ false.
	inputSemaphore initSignals! !


Object subclass: #Exception
	instanceVariableNames: 'messageText tag signalContext handlerContexts outerContext'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions Kernel'!

!Exception methodsFor: 'debug support' stamp: 'HAW 7/29/2017 15:47:08'!
           canSearchForSignalerContext
	"This method is /only/ to support the debugger's catching of exceptions in stepIntoBlock."
	^signalContext isContext! !


Exception class
	instanceVariableNames: ''!

!Exception class methodsFor: 'handling condition creation' stamp: 'HAW 3/28/2017 15:48:57'!
, anExceptionHandlingCondition

	"See ExceptionHandlingCondition>>,"
	
	^anExceptionHandlingCondition createOrConditionWithExceptionType: self! !

!Exception class methodsFor: 'handling condition creation' stamp: 'HAW 3/28/2017 15:49:08'!
                 - anExceptionHandlingCondition

	"See ExceptionHandlingCondition>>-"

	^anExceptionHandlingCondition createFilterConditionWithExceptionType: self! !

!Exception class methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 11:23:04'!
    createFilterConditionWithExceptionType: anExceptionType

	^FilterExceptionHandlingCondition handling: anExceptionType filtering: self! !

!Exception class methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 11:26:42'!
                createFilterConditionWithFilterCondition: aFilterExceptionHandlingCondition 
	
	^FilterExceptionHandlingCondition handling: aFilterExceptionHandlingCondition filtering: self! !

!Exception class methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 15:40:33'!
        createFilterConditionWithOrCondition: anOrExceptionHandlingCondition 
	
	^FilterExceptionHandlingCondition handling: anOrExceptionHandlingCondition filtering: self! !

!Exception class methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 15:37:59'!
                  createOrConditionWithExceptionType: anExceptionType

	^OrExceptionHandlingCondition handling: anExceptionType or: self
! !

!Exception class methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 15:48:29'!
                              createOrConditionWithFilterCondition: aFilterExceptionHandlingCondition 
	
	^aFilterExceptionHandlingCondition handleCondition, self - aFilterExceptionHandlingCondition filterCondition 
	
	! !

!Exception class methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 11:09:54'!
                        createOrConditionWithOrCondition: anOrExceptionHandlingCondition 
	
	^OrExceptionHandlingCondition handling: anOrExceptionHandlingCondition or: self! !


Object subclass: #ExceptionHandlingCondition
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions Kernel'!

!ExceptionHandlingCondition methodsFor: 'error handling' stamp: 'HAW 3/28/2017 17:29:18'!
                     handles: anException 
	
	"Must return true if anException must be handle
	See also Exception class>>handles: anException"
	
	self subclassResponsibility ! !

!ExceptionHandlingCondition methodsFor: 'handling condition creation' stamp: 'HAW 3/28/2017 17:17:36'!
                           , anExceptionHandlingCondition

	"Creates a handling condition that will return true if either part of the condition handles the exception.
	It behaves like an or
	The following example will handle the exception
	[ Error signal ]
	   on:  Error, Halt 
	  do: [ :anError | ... ]
	
	The following example will also handle the exception:
	[ Halt signal ]
	   on:  Error, Halt
	  do: [ :anError | ... ]"
	
	self subclassResponsibility 
	! !

!ExceptionHandlingCondition methodsFor: 'handling condition creation' stamp: 'HAW 3/29/2017 13:59:37'!
   - anExceptionHandlingCondition

	"Creates a handling condition that will not handle exceptions that meet the right side of the condition
	The following example will not handle the exception
	[ 1/0 ]
	   on:  Error - ZeroDivide 
	  do: [ :anError | ... ]
	
	The following example will handle the exception:
	[ Error signal ]
	   on:  Error - ZeroDivide 
	  do: [ :anError | ... ]
	
	Due to inconsisties that can arrise with combining #, with #- the implementation orders the in such a way that 'or conditions' go first 
	and 'filter conditions' go last. Doing so (Error - Notification) , (UnhandledError - ZeroDivide)  is converted to  Error, UnhandledError - Notification - ZeroDivide 
	Inconsisties can arrise because ZeroDivide is a subclass of Error and therefore if the condition is not ordered correctly a ZeroDivide could be handled.
	This inconsisty can be found in Pharo where the condition (Error - Notification) , (UnhandledError - ZeroDivide) does not filter ZeroDivide but 
	the condition Error, UnhandledError - Notification - ZeroDivide does filter it.
	That is the reason the implementation uses double dispatch
	"
	
	self subclassResponsibility 
	! !

!ExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/29/2017 13:31:13'!
                               createFilterConditionWithExceptionType: anExceptionType

	self subclassResponsibility ! !

!ExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/29/2017 13:33:31'!
                    createFilterConditionWithFilterCondition: aFilterExceptionHandlingCondition 

	self subclassResponsibility ! !

!ExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/29/2017 13:33:39'!
                               createFilterConditionWithOrCondition: anOrExceptionHandlingCondition 

	self subclassResponsibility ! !

!ExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/29/2017 13:33:51'!
      createOrConditionWithExceptionType: anExceptionType

	self subclassResponsibility ! !

!ExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/29/2017 13:34:31'!
                        createOrConditionWithFilterCondition: aFilterExceptionHandlingCondition 

	self subclassResponsibility ! !

!ExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/29/2017 13:34:42'!
   createOrConditionWithOrCondition: anOrExceptionHandlingCondition 

	self subclassResponsibility ! !

!ExceptionHandlingCondition commentStamp: '<historical>' prior: 0!
                        I represent the protocol expected to be as condition on the exception handling message on:do:
I also define the protocol to create and combine exceptions handling conditions.
See methods #, and #- for a complemented documentation!
!FileList commentStamp: '<historical>' prior: 0!
        I am model that can be used to navigate the host file system. By omitting the volume list, file list, and template panes from the view, I can also be used as the model for an editor on an individual file.

The FileList provides a dynamic extension mechanism.  To extend FileList functionality, tools should implement the following class-side method (look for implementors in the image):

#fileReaderServicesForFile:suffix: (appropriate services for given file, takes a file name and a lowercased suffix)

This method returns a collection of SimpleServiceEntry instances.  These contain a class, a menu label and a method selector having one argument.  They may also provide separate button labels and description.

The argument to the specified method will be a string representing the full name of a file when one is selected or the file list itself when there is no selected file.!

FileList class
	instanceVariableNames: ''!

!FileList class methodsFor: 'file reader registration' stamp: 'jmv 8/28/2017 21:39:36'!
       itemsForFile: filename
	"Answer a list of services appropriate for a file of the given name"
	| services suffix classList |
	suffix _ (FileIOAccessor default extensionFor: filename) asLowercase.
	"Build the list dynamically for all implementers of the appropriate class method... registration no longer required"
	classList _ (Smalltalk allClassesImplementing: #fileReaderServicesForFile:suffix:)
		collect: [ :item |
			item class == Metaclass ifTrue: [ item soleInstance ]]
		thenSelect: [ :item |
			item notNil ].
	services _ OrderedCollection new.
	classList do: [ :reader |
		services addAll:
			(reader
				fileReaderServicesForFile: filename
				suffix: suffix) ].
	services sort: [ :a :b | a sortOrder < b sortOrder ].
	^ services.! !

!FileList class methodsFor: 'file reader registration' stamp: 'pb 7/27/2017 06:02:20'!
registerFileReader: aProviderClass
	"For compatibility... no longer necessary"! !

!FileList class methodsFor: 'file reader registration' stamp: 'pb 7/27/2017 06:02:32'!
                      unregisterFileReader: aProviderClass
	"For compatibility... no longer necessary"! !


Object subclass: #FileSystemEntry
	instanceVariableNames: 'drive pathComponents parent name creationTime modificationTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-FileMan-Core'!

!FileSystemEntry methodsFor: 'accessing-file name' stamp: 'jmv 2/16/2017 11:21:10'!
          baseName
	^self fileAccessor baseNameFor: name! !


RectangleLikeMorph subclass: #FillInTheBlankMorph
	instanceVariableNames: 'response done textPane responseUponCancel'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:03:19'!
                      createAcceptButton
	"create the [accept] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current acceptButton;
		 label: 'Accept';
		 action: #acceptClicked.
	result morphExtent: `6@2` * self sizeUnit.
	self addMorph: result position: `2@7.5` * self sizeUnit // 1.
	^ result! !

!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:03:31'!
               createCancelButton
	"create the [cancel] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current cancelButton;
		 label: 'Cancel';
		 action: #cancelClicked.
	result morphExtent: `6@2` * self sizeUnit.
	self addMorph: result position: `12@7.5` * self sizeUnit // 1.
	^ result! !

!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:03:37'!
              createQueryTextMorph: queryString 
	"create the queryTextMorph"
	| result |
	result _ StringMorph new contents: queryString.
	result lock.
	result morphExtent: `24@2` * self sizeUnit.
	self addMorph: result position: `2@0.5` * self sizeUnit // 1.
	^ result! !

!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:03:44'!
        createTextPaneAcceptOnCR: acceptBoolean
	"create the textPane"
	| result |

	self flag: #todo. "Integrate this method with the Theme system. --cbr"

	result _ TextModelMorph
				textProvider: self
				textGetter: #response
				textSetter: #response:
				selectionGetter: #selectionInterval.
	result hasUnacceptedEdits: true.
	result acceptOnCR: acceptBoolean.
	result morphExtent: `18@5` * self sizeUnit.
	self addMorph: result position: `1@2` * self sizeUnit.
	^ result! !

!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:03:48'!
                  initialize

	super initialize.
	extent _ `20@10` * self sizeUnit.
	responseUponCancel _ ''! !

!FillInTheBlankMorph methodsFor: 'invoking' stamp: 'jmv 3/2/2017 20:08:24'!
                     getUserResponse
	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."
	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."

	| w |
	w _ self world.
	w ifNil: [^ response].
	done _ false.
	textPane focusText.
	[done] whileFalse: [w doOneMinimalCycleNow].
	self delete.
	w doOneMinimalCycleNow.
	^ response
! !

!FillInTheBlankMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:48:53'!
                           drawOn: aCanvas

	Theme current roundWindowCorners
		ifTrue: [
			aCanvas
				roundRect: (`0@0` extent: extent)
				color: color
				radius: Theme current roundedWindowRadius ]
		ifFalse: [ super drawOn: aCanvas ]! !


FillInTheBlankMorph class
	instanceVariableNames: ''!

!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 3/3/2017 09:26:42'!
                   request: queryString initialAnswer: defaultAnswer centerAt: aPoint onCancelReturn: returnOnCancel acceptOnCR: acceptBoolean
	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts.   If the user cancels, answer returnOnCancel."
	"
	FillInTheBlankMorph
		request: 'Type something, then type [Return].'
		initialAnswer: 'yo ho ho!!'
	"

	| aFillInTheBlankMorph |
	aFillInTheBlankMorph _ self new
		setQuery: queryString
		initialAnswer: defaultAnswer
		acceptOnCR: acceptBoolean.
	aFillInTheBlankMorph responseUponCancel: returnOnCancel.
	self runningWorld addMorph: aFillInTheBlankMorph centeredNear: aPoint.
	^ aFillInTheBlankMorph getUserResponse! !

!FillInTheBlankMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:52:51'!
      categoryInNewMorphMenu
	^ 'Widgets'! !


ExceptionHandlingCondition subclass: #FilterExceptionHandlingCondition
	instanceVariableNames: 'handleCondition filterCondition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions Kernel'!

!FilterExceptionHandlingCondition methodsFor: 'accessing' stamp: 'HAW 3/28/2017 17:20:21'!
            filterCondition
	
	^filterCondition ! !

!FilterExceptionHandlingCondition methodsFor: 'accessing' stamp: 'HAW 3/28/2017 17:20:26'!
                            handleCondition
	
	^handleCondition ! !

!FilterExceptionHandlingCondition methodsFor: 'error handling' stamp: 'HAW 3/28/2017 17:20:41'!
                       handles: anException 
	
	^ (filterCondition handles: anException) not and: [ handleCondition handles: anException ]! !

!FilterExceptionHandlingCondition methodsFor: 'initialization' stamp: 'HAW 3/29/2017 13:45:21'!
        initializeHandling: aHandleCondition filtering: aFilterCondition 

	handleCondition _ aHandleCondition.
	filterCondition _ aFilterCondition ! !

!FilterExceptionHandlingCondition methodsFor: 'handling condition creation' stamp: 'HAW 3/29/2017 13:59:08'!
  , anExceptionHandlingCondition

	"See ExceptionHandlingCondition>>#- for an explanation of why double dispatch is used as implementation"
	
	^anExceptionHandlingCondition createOrConditionWithFilterCondition: self! !

!FilterExceptionHandlingCondition methodsFor: 'handling condition creation' stamp: 'HAW 3/29/2017 13:59:00'!
                         - anExceptionHandlingCondition

	"See ExceptionHandlingCondition>>#- for an explanation of why double dispatch is used as implementation"
	
	^anExceptionHandlingCondition createFilterConditionWithFilterCondition: self! !

!FilterExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 17:56:46'!
           createFilterConditionWithExceptionType: anExceptionType

	^self class 
		handling: anExceptionType, filterCondition 
		filtering: handleCondition ! !

!FilterExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 17:19:24'!
                  createFilterConditionWithFilterCondition: aFilterExceptionHandlingCondition 
	
	^aFilterExceptionHandlingCondition - handleCondition, filterCondition ! !

!FilterExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 17:19:48'!
              createFilterConditionWithOrCondition: anOrExceptionHandlingCondition 
	
	^anOrExceptionHandlingCondition, filterCondition - handleCondition ! !

!FilterExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/29/2017 17:59:55'!
                        createOrConditionWithExceptionType: anExceptionType

	^anExceptionType, handleCondition - filterCondition ! !

!FilterExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 17:20:04'!
                          createOrConditionWithFilterCondition: aFilterExceptionHandlingCondition 
	
	^aFilterExceptionHandlingCondition handleCondition,handleCondition - aFilterExceptionHandlingCondition filterCondition - filterCondition ! !

!FilterExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/29/2017 15:32:33'!
               createOrConditionWithOrCondition: anOrExceptionHandlingCondition 
	
	^anOrExceptionHandlingCondition, handleCondition - filterCondition ! !

!FilterExceptionHandlingCondition methodsFor: 'printing' stamp: 'HAW 3/28/2017 17:20:55'!
                         printOn: aStream

	aStream
		print: handleCondition ;
		nextPutAll: ' - ';
		print: filterCondition ! !


FilterExceptionHandlingCondition class
	instanceVariableNames: ''!

!FilterExceptionHandlingCondition class methodsFor: 'instance creation' stamp: 'HAW 3/28/2017 17:18:11'!
         handling: aHandleCondition filtering: aFilterCondition 
	
	^self new initializeHandling: aHandleCondition filtering: aFilterCondition 
! !


Number subclass: #Float
	instanceVariableNames: ''
	classVariableNames: 'E Epsilon Halfpi Infinity Ln10 Ln2 MaxVal MaxValLn MinValLogBase2 NaN NegativeInfinity NegativeZero Pi RadiansPerDegree Sqrt2 Twopi'
	poolDictionaries: ''
	category: 'Kernel-Numbers'!

!Float methodsFor: 'private' stamp: 'jmv 1/13/2017 09:57:46'!
                   replaceWordsFrom: start to: stop with: replacement startingAt: repStart
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	self primitiveFailed! !


ArrayedCollection variableWordSubclass: #Float64Array
	instanceVariableNames: ''
	classVariableNames: 'LastSaveOrder'
	poolDictionaries: ''
	category: 'Collections-Arrayed'!

!Float64Array methodsFor: 'accessing' stamp: 'jmv 12/27/2016 09:51:21'!
                          floatAt: index put: aNumber
	"Store the argument (e.g., 64 bit Float) at the given index
	Use the same internal representation as BoxedFloat64. I.e. a BoxedFloat64 and a Float64Array of size 1 hold the same bits.
	Allow subclasses to redefine #at:put:"

	"This breaks with SmallFloat64"
	"self replaceWordsFrom: index * 2 - 1 to: index * 2  with: aFloat asFloat startingAt: 1."

	"Float >>basicAt: acts as if Floats were stored in big endian format. Our instances are in platform endianess."
	| aFloat |
	aFloat _ aNumber asFloat.
	Smalltalk isLittleEndian
		ifTrue: [
			self basicAt: index * 2 - 1 put: (aFloat basicAt: 2).
			self basicAt: index * 2 put: (aFloat basicAt: 1) ]
		ifFalse: [
			self basicAt: index * 2 - 1 put: (aFloat basicAt: 1).
			self basicAt: index * 2 put: (aFloat basicAt: 2) ].
	^aFloat! !

!Float64Array methodsFor: 'private' stamp: 'jmv 1/13/2017 09:57:50'!
         replaceWordsFrom: start to: stop with: replacement startingAt: repStart
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	self primitiveFailed! !

!Float64Array methodsFor: 'testing' stamp: 'jmv 7/11/2017 14:04:20'!
             isLiteral
	"so that 
	#(1 #[1.0 2 3] 5)
	prints itself"
	^self class == Float64Array! !

!Float64Array methodsFor: 'printing' stamp: 'jmv 7/11/2017 14:10:44'!
 printOn: aStream

	self storeOn: aStream! !

!Float64Array methodsFor: 'printing' stamp: 'jmv 7/11/2017 14:10:41'!
             storeOn: aStream

	aStream nextPutAll: '#['.
	self
		do: [ :each | each storeOn: aStream ]
		separatedBy: [ aStream nextPut: $ ].
	aStream nextPut: $]! !

!Float64Array methodsFor: 'interpolating' stamp: 'jmv 9/28/2017 13:39:15'!
                          interpolateValues: valuesArray at: x
	"Interpret self as a domain and valuesArray as a function samples."
	
	^self
		findBinaryIndex: [ :arg | x - arg ]
		do: [ :i | valuesArray at: i ]
		ifNone: [ :i :j  |
			((valuesArray at: i) interpolateTo: (valuesArray at: j) at: (x - (self at: i)) / ((self at: j) - (self at: i)))]! !

!Float64Array methodsFor: 'interpolating' stamp: 'jmv 9/28/2017 13:39:12'!
              interpolatedValueAt: floatIndex
	"Do a linear interpolation.
	Gives usual error if argument outside bounds:
	#[ 4 5 ] asFloatArray interpolatedValueAt: 0.999
	#[ 4 5 ] asFloatArray interpolatedValueAt: 1.0
	#[ 4 5 ] asFloatArray interpolatedValueAt: 1.5
	#[ 4 5 ] asFloatArray interpolatedValueAt: 2.0
	#[ 4 5 ] asFloatArray interpolatedValueAt: 2.000001
	#[ 4 5 ] asFloatArray interpolatedValueAt: 3
	"
	| size index0 index1 weight0 weight1 |

	size _ self size.
	index0 _ floatIndex truncated. 		"Could be #floor. But as we only care for values >=1, it is the same. But faster."

	weight1 _ floatIndex - index0.
	weight0 _ 1.0 - weight1.

	index1 _ (index0 = size and: [ weight1 = 0.0 ]) 			"Avoid the invalid access if this was true, but don't make it slower the most common, general case."
		ifFalse: [ index0 + 1 ]
		ifTrue: [ index0 ].

	"/* perform interpolation */"
	^ (weight0 * (self at: index0)) + (weight1 * (self at: index1))! !


ArrayedCollection variableWordSubclass: #FloatArray
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Arrayed'!

!FloatArray methodsFor: 'comparing' stamp: 'jmv 6/18/2017 20:25:14'!
           = another 
	self == another ifTrue: [ ^ true ].
	self class == another class ifFalse: [ ^ false ].
	^self primitiveEqual: another! !

!FloatArray methodsFor: 'private' stamp: 'jmv 1/13/2017 09:58:24'!
                       replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !

!FloatArray methodsFor: 'interpolating' stamp: 'jmv 9/28/2017 13:36:31'!
                         interpolateValues: valuesArray at: x
	"Interpret self as a domain and valuesArray as a function samples."
	
	^self
		findBinaryIndex: [ :arg | x - arg ]
		do: [ :i | valuesArray at: i ]
		ifNone: [ :i :j  |
			((valuesArray at: i) interpolateTo: (valuesArray at: j) at: (x - (self at: i)) / ((self at: j) - (self at: i)))]! !


Object subclass: #Form
	instanceVariableNames: 'bits width height depth offset'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Display Objects'!

!Form methodsFor: 'accessing' stamp: 'jmv 6/19/2017 15:50:37'!
                   offset
	^offset ifNil:[`0@0`]! !

!Form methodsFor: 'analyzing' stamp: 'ar 5/17/2001 15:40'!
   dominantColor
	| tally max maxi |
	self depth > 16 ifTrue:
		[^(self asFormOfDepth: 16) dominantColor].
	tally _ self tallyPixelValues.
	max _ maxi _ 0.
	tally withIndexDo: [:n :i | n > max ifTrue: [max _ n. maxi _ i]].
	^ Color colorFromPixelValue: maxi - 1 depth: self depth! !

!Form methodsFor: 'analyzing' stamp: 'jmv 6/19/2017 15:51:14'!
        primCountBits
	"Count the non-zero pixels of this form."
	self depth > 8 ifTrue:
		[^(self asFormOfDepth: 8) primCountBits].
	^ (BitBlt toForm: self)
		fillColor: (Bitmap with: 0);
		destRect: (`0@0` extent: width@height);
		combinationRule: 32;
		copyBits! !

!Form methodsFor: 'analyzing' stamp: 'jmv 6/19/2017 15:51:36'!
                            tallyPixelValuesInRect: destRect into: valueTable
	"Tally the selected pixels of this Form into valueTable, a Bitmap of depth 2^depth similar to a color map. Answer valueTable."

	(BitBlt toForm: self)
		sourceForm: self;  "src must be given for color map ops"
		sourceOrigin: `0@0`;
		colorMap: valueTable;
		combinationRule: 33;
		destRect: destRect;
		copyBits.
	^ valueTable

"
Move a little rectangle around the screen and print its tallies...
 | r tallies nonZero |
Cursor blank showWhile: [
[Sensor isAnyButtonPressed] whileFalse:
	[r _ Sensor mousePoint extent: 10@10.
	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil.
	tallies _ (Display copy: r) tallyPixelValues.
	nonZero _ (1 to: tallies size) select: [:i | (tallies at: i) > 0]
			thenCollect: [:i | (tallies at: i) -> (i-1)].
	Display fill: (0@0 extent: Display width@20) fillColor: Color white.
	nonZero printString , '          ' displayAt: 0@0.
	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil]]
"! !

!Form methodsFor: 'analyzing' stamp: 'jmv 6/19/2017 15:51:54'!
  xTallyPixelValue: pv orNot: not
	"Return an array of the number of pixels with value pv by x-value.
	Note that if not is true, then this will tally those different from pv."
	| cm slice countBlt copyBlt |
	cm _ self newColorMap.		"Map all colors but pv to zero"
	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"
	cm at: pv+1 put: 1 - (cm at: pv+1).
	slice _ Form extent: 1@height.
	copyBlt _ (BitBlt destForm: slice sourceForm: self
				combinationRule: Form over
				destOrigin: `0@0` sourceOrigin: `0@0` extent: 1 @ slice height
				clipRect: slice boundingBox)
					colorMap: cm.
	countBlt _ (BitBlt toForm: slice)
				fillColor: (Bitmap with: 0);
				destRect: (`0@0` extent: slice extent);
				combinationRule: 32.
	^ (0 to: width-1) collect:
		[:x |
		copyBlt sourceOrigin: x@0; copyBits.
		countBlt copyBits]! !

!Form methodsFor: 'analyzing' stamp: 'jmv 6/19/2017 15:52:04'!
    yTallyPixelValue: pv orNot: not
	"Return an array of the number of pixels with value pv by y-value.
	Note that if not is true, then this will tally those different from pv."
	| cm slice copyBlt countBlt |
	cm _ self newColorMap.		"Map all colors but pv to zero"
	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"
	cm at: pv+1 put: 1 - (cm at: pv+1).
	slice _ Form extent: width@1.
	copyBlt _ (BitBlt destForm: slice sourceForm: self
				combinationRule: Form over
				destOrigin: `0@0` sourceOrigin: `0@0` extent: slice width @ 1
				clipRect: slice boundingBox)
					colorMap: cm.
	countBlt _ (BitBlt toForm: slice)
				fillColor: (Bitmap with: 0);
				destRect: (`0@0` extent: slice extent);
				combinationRule: 32.
	^ (0 to: height-1) collect:
		[:y |
		copyBlt sourceOrigin: 0@y; copyBits.
		countBlt copyBits]! !

!Form methodsFor: 'bordering' stamp: 'jmv 1/22/2015 10:22'!
        border: aRectangle width: borderWidth 
	"Paint a border whose rectangular area is defined by aRectangle. The 
	width of the border of each side is borderWidth. Uses black for 
	drawing the border."

	self border: aRectangle width: borderWidth fillColor: Color black! !

!Form methodsFor: 'bordering' stamp: 'jmv 9/29/2017 16:59:58'!
                   border: aRectangle width: borderWidth borderHeight: borderHeight fillColor: aColor
	"Paint a border whose rectangular area is defined by aRectangle. The 
	width of the border of each side is borderWidth@borderHeight. Uses aHalfTone for 
	drawing the border."

	self border: aRectangle
		widthRectangle: 
			(Rectangle
				left: borderWidth
				right: borderWidth
				top: borderHeight
				bottom: borderHeight)
		rule: Form over
		fillColor: aColor! !

!Form methodsFor: 'bordering' stamp: 'jmv 9/29/2017 16:59:43'!
                            borderWidth: borderWidth borderHeight: borderHeight fillColor: aColor
	self border: self boundingBox width: borderWidth borderHeight: borderHeight fillColor: aColor! !

!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:20'!
                            fillBlack
	"Set all bits in the receiver to black (ones)."

	self fill: self boundingBox fillColor: Color black! !

!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:20'!
                 fillBlack: aRectangle 
	"Set all bits in the receiver's area defined by aRectangle to black (ones)."

	self fill: aRectangle rule: Form over fillColor: Color black! !

!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:20'!
                             fillGray
	"Set all bits in the receiver to gray."

	self fill: self boundingBox fillColor: Color gray! !

!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:20'!
                           fillGray: aRectangle
	"Set all bits in the receiver's area defined by aRectangle to the gray mask."

	self fill: aRectangle rule: Form over fillColor: Color gray! !

!Form methodsFor: 'coloring' stamp: 'jmv 6/19/2017 15:50:16'!
                            fillShape: aShapeForm fillColor: aColor
	"Fill a region corresponding to 1 bits in aShapeForm with aColor"

	^ self fillShape: aShapeForm fillColor: aColor at: `0@0`! !

!Form methodsFor: 'coloring' stamp: 'jmv 6/19/2017 15:50:23'!
                        fillShape: aShapeForm fillColor: aColor at: location
	"Fill a region corresponding to 1 bits in aShapeForm with aColor"

	((BitBlt destForm: self sourceForm: aShapeForm fillColor: aColor
		combinationRule: Form paint
		destOrigin: location + aShapeForm offset sourceOrigin: `0@0`
		extent: self extent clipRect: self boundingBox)
		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF))
		copyBits! !

!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:21'!
                            fillWhite
	"Set all bits in the form to white."

	self fill: self boundingBox fillColor: Color white! !

!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:21'!
                            fillWhite: aRectangle
	"Set all bits in the receiver's area defined by aRectangle to white."

	self fill: aRectangle rule: Form over fillColor: Color white! !

!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:21'!
     reverse
	"Change all the bits in the receiver that are white to black, and the ones 
	that are black to white.
	Display reverse
	"

	self fill: self boundingBox rule: Form reverse fillColor: Color white! !

!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:21'!
                      reverse: aRectangle
	"Change all the bits in the receiver's area that intersects with aRectangle 
	that are white to black, and the ones that are black to white."

	self fill: aRectangle rule: Form reverse fillColor: Color white! !

!Form methodsFor: 'color mapping' stamp: 'ar 5/17/2001 15:42'!
                        colormapIfNeededForDepth: destDepth
	"Return a colormap for displaying the receiver at the given depth, or nil if no colormap is needed."

	self depth = destDepth ifTrue: [^ nil].  "not needed if depths are the same"
	^ Color colorMapIfNeededFrom: self depth to: destDepth
! !

!Form methodsFor: 'color mapping' stamp: 'jmv 5/12/2016 13:53'!
          colormapIfNeededForGray8bpp
	"Return a colormap for displaying the receiver at the given depth.
	Note: Uses 5 bits per color component. 32bit Forms will lose information!!"

	^ Color cachedColormapForGrayFrom: self depth! !

!Form methodsFor: 'color mapping' stamp: 'jmv 6/19/2017 15:50:33'!
                            mapColor: oldColor to: newColor
	"Make all pixels of the given color in this Form to the given new color."
	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."

	| map |
	map _ (Color cachedColormapFrom: self depth to: self depth) copy.
	map at: (oldColor indexInMap: map) put: (newColor pixelWordForDepth: self depth).
	(BitBlt toForm: self)
		sourceForm: self;
		sourceOrigin: `0@0`;
		combinationRule: Form over;
		destX: 0 destY: 0 width: width height: height;
		colorMap: map;
		copyBits.
! !

!Form methodsFor: 'color mapping' stamp: 'jmv 1/31/2011 09:21'!
                          maskingMap
	"Return a color map that maps all colors except transparent to words of all ones. Used to create a mask for a Form whose transparent pixel value is zero."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."
	^Color maskingMap: self depth! !

!Form methodsFor: 'converting' stamp: 'jm 11/12/97 19:28'!
                              as8BitColorForm
	"Simple conversion of zero pixels to transparent.  Force it to 8 bits."

	| f map |
	f _ ColorForm extent: self extent depth: 8.
	self displayOn: f at: self offset negated.
	map _ Color indexedColors copy.
	map at: 1 put: Color transparent.
	f colors: map.
	f offset: self offset.
	^ f
! !

!Form methodsFor: 'converting' stamp: 'jmv 6/19/2017 15:49:08'!
            asFormOfDepth: d
	| newForm source |
	d = depth ifTrue: [ ^self ].
	source _ (self depth = 32 and: [ d abs < 32 ])
		ifTrue: [ self copy convertAlphaToZeroValueTransparency ]
		ifFalse: [ self ].
	newForm _ Form extent: source extent depth: d.
	(BitBlt toForm: newForm)
		colorMap: (source colormapIfNeededFor: newForm);
		copy: source boundingBox
		from: `0@0` in: source
		fillColor: nil rule: Form over.
	"If we build a 32bpp from one of smaller depth,
	it will have zero in the alpha channel (until BitBlt is fixed!!)"
	(newForm depth = 32 and: [self depth < 32]) ifTrue: [
		newForm fixAlpha ].
	^newForm! !

!Form methodsFor: 'converting' stamp: 'jmv 6/19/2017 15:49:12'!
                          asGrayForm
	| answer map |

	"For lower bit depths, the 15 bit ColorMap loses no information,
	and answers the real #luminance of each pixel."
	self depth < 32 ifTrue: [
		answer _ GrayForm extent: width@height.
		map _ self colormapIfNeededForGray8bpp.
		(BitBlt toForm: answer)
			colorMap: map;
			copy: self boundingBox
			from: `0@0` in: self
			fillColor: nil rule: Form over.
		answer offset: self offset.
		^ answer ].

	"For 32bpp, the approach below would use just 5bits per component.
	Generally it is best to extract a component in full 8bpp and keep full dynamic range.
	Green usually is a good choice."
	^ self asGrayForm: 3! !

!Form methodsFor: 'converting' stamp: 'jmv 6/19/2017 15:49:19'!
                             asGrayForm: componentIndex
"Native depth"
	"Assume the receiver is a grayscale image. Return a GrayForm computed by extracting the brightness levels of one color component. This technique allows a 32-bit Form to be converted to an 8-bit GrayForm to save space while retaining a full 255 levels of gray. (The usual colormapping technique quantizes to 8, 16, or 32 levels, which loses information.)

	If component = 1, take the alpha component
	If component = 2, take the red component
	If component = 3, take the green component
	If component = 4, take the blue component
	"
	| f32 result map mask shift |
	self depth = 32 ifFalse: [
		f32 _ Form extent: width@height depth: 32.
		self displayOn: f32.
		^ f32 asGrayForm: componentIndex ].
	
	result _ GrayForm extent: width@height.
	shift _ #(-24 -16 -8 0) at: componentIndex.
	mask _ #(16rFF000000 16rFF0000 16rFF00 16rFF) at: componentIndex.
	map _ ColorMap masks: { mask. 0. 0. 0 } shifts: { shift. 0. 0. 0 }.
	(BitBlt toForm: result)
		sourceForm: self;
		combinationRule: Form over;
		colorMap: map;
		sourceRect: (`0@0` extent: width@height);
		destOrigin: `0@0`;
		copyBits.
	^ result! !

!Form methodsFor: 'converting' stamp: 'jmv 6/19/2017 15:49:38'!
      asGrayScaleAndTransparent: componentIndex
"Native depth"
	"Assume the receiver is a grayscale image. Return a grayscale ColorForm computed by extracting the brightness levels of one color component. This technique allows a 32-bit Form to be converted to an 8-bit ColorForm to save space while retaining a full 255 levels of gray. (The usual colormapping technique quantizes to 8, 16, or 32 levels, which loses information.)

	If component = 1, take the alpha component
	If component = 2, take the red component
	If component = 3, take the green component
	If component = 4, take the blue component
	"
	| f32 result map mask shift |
	self depth = 32 ifFalse: [
		f32 _ Form extent: width@height depth: 32.
		self displayOn: f32.
		^ f32 asGrayScaleAndTransparent: componentIndex ].

	result _ ColorForm grayScaleAndTransparentExtent: width@height.
	shift _ #(-24 -16 -8 0) at: componentIndex.
	mask _ #(16rFF000000 16rFF0000 16rFF00 16rFF) at: componentIndex.
	map _ ColorMap masks: { mask. 0. 0. 0 } shifts: { shift. 0. 0. 0 }.
	(BitBlt toForm: result)
		sourceForm: self;
		combinationRule: Form over;
		colorMap: map;
		sourceRect: (`0@0` extent: width@height);
		destOrigin: `0@0`;
		copyBits.

	"final BitBlt to zero-out pixels that were truely transparent in the original"
	map _ Bitmap new: 512.
	map at: 1 put: 16rFF.
	(BitBlt toForm: result)
		sourceForm: self;
		sourceRect: self boundingBox;
		destOrigin: `0@0`;
		combinationRule: Form erase;
		colorMap: map;
		copyBits.
	^ result! !

!Form methodsFor: 'converting' stamp: 'jmv 6/19/2017 16:04:17'!
       icon
	"Answer a 16 x 16 icon of myself"
	
	^self magnifyTo: `16 @ 16`! !

!Form methodsFor: 'copying' stamp: 'jmv 6/19/2017 15:49:47'!
                         contentsOfArea: aRect into: newForm
 	"Return a new form which derives from the portion of the original form delineated by aRect."
	^ newForm copyBits: aRect from: self at: `0@0`
		clippingBox: newForm boundingBox rule: Form over! !

!Form methodsFor: 'copying' stamp: 'jmv 6/19/2017 15:49:55'!
                         copy: aRect
 	"Return a new form which derives from the portion of the original form delineated by aRect."
	| newForm |
	newForm _ self class extent: aRect extent depth: depth.
	^ newForm copyBits: aRect from: self at: `0@0`
		clippingBox: newForm boundingBox rule: Form over! !

!Form methodsFor: 'copying' stamp: 'jmv 6/19/2017 15:50:02'!
           copyBits: sourceForm at: destOrigin translucent: factor
	"Make up a BitBlt table and copy the bits with the given colorMap."
	(BitBlt 
		destForm: self
		sourceForm: sourceForm
		combinationRule: 30
		destOrigin: destOrigin
		sourceOrigin: `0@0`
		extent: sourceForm extent
		clipRect: self boundingBox)
			copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)
"
 | f f2 f3 | f _ Form fromUser. f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 copy.
0.0 to: 1.0 by: 1.0/32 do:
	[:t | f3 _ f2 copy. f3 copyBits: f at: 0@0 translucent: t.
	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait].
"! !

!Form methodsFor: 'display box access' stamp: 'jmv 6/19/2017 16:04:01'!
               boundingBox
	^ Rectangle
		origin: `0 @ 0`
		corner: width @ height! !

!Form methodsFor: 'displaying' stamp: 'jmv 6/19/2017 15:51:05'!
                        paintBits: sourceForm at: destOrigin translucent: factor
	"Make up a BitBlt table and copy the bits with the given colorMap."
	(BitBlt destForm: self
		sourceForm: sourceForm
		combinationRule: 31
		destOrigin: destOrigin
		sourceOrigin: `0@0`
		extent: sourceForm extent
		clipRect: self boundingBox)
			copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)
"
 | f f2 f3 | f _ Form fromUser. f replaceColor: f dominantColor withColor: Color transparent.
f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 copy.
0.0 to: 1.0 by: 1.0/32 do:
	[:t | f3 _ f2 copy. f3 paintBits: f at: 0@0 translucent: t.
	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait].
"! !

!Form methodsFor: 'displaying-generic' stamp: 'jmv 6/19/2017 16:04:09'!
                  displayOn: aDisplayMedium
	"Simple default display in order to see the receiver in the upper left 
	corner of screen."

	self displayOn: aDisplayMedium at: `0 @ 0`! !

!Form methodsFor: 'fileIn/Out' stamp: 'len 8/1/2016 08:13'!
                            printOn: aStream
	aStream isText
		ifTrue:
			[aStream withAttribute: (TextAnchor new anchoredFormOrMorph: self) do: [aStream nextPut: $*].
			^ self].
	aStream
		nextPutAll: self class name;
		nextPut: $(; print: width;
		nextPut: $x; print: height;
		nextPut: $x; print: depth;
		nextPut: $)! !

!Form methodsFor: 'filling' stamp: 'jmv 6/19/2017 15:50:07'!
                         eraseShape: bwForm
	"use bwForm as a mask to clear all pixels where bwForm has 1's"
	((BitBlt destForm: self sourceForm: bwForm
		combinationRule: Form erase1bitShape	"Cut a hole in the picture with my mask"
		destOrigin: bwForm offset 
		sourceOrigin: `0@0`
		extent: self extent clipRect: self boundingBox)
		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF))
		copyBits.
! !

!Form methodsFor: 'filling' stamp: 'jmv 6/19/2017 15:50:12'!
             fill: aRectangle rule: anInteger fillColor: aForm 
	"Replace a rectangular area of the receiver with the pattern described by aForm 
	according to the rule anInteger."
	(BitBlt toForm: self)
		copy: aRectangle
		from: `0@0` in: nil
		fillColor: aForm rule: anInteger! !

!Form methodsFor: 'image manipulation' stamp: 'jmv 6/19/2017 15:51:26'!
         smear: dir distance: dist
	"Smear any black pixels in this form in the direction dir in Log N steps"
	| skew bb |
	bb _ BitBlt destForm: self sourceForm: self
		combinationRule: Form under destOrigin: `0@0` sourceOrigin: `0@0`
		extent: self extent clipRect: self boundingBox.
	skew _ 1.
	[skew < dist] whileTrue:
		[bb destOrigin: dir*skew; copyBits.
		skew _ skew+skew]! !

!Form methodsFor: 'pixel access' stamp: 'ar 5/17/2001 15:42'!
          colorAt: aPoint
	"Return the color in the pixel at the given point.  "

	^ Color 
		colorFromPixelValue: (self pixelValueAt: aPoint)
		depth: self depth
! !

!Form methodsFor: 'pixel access' stamp: 'jmv 11/4/2015 12:40'!
   colorInterpolatedAt: aPoint
	"Evaluate a bilinear (i.e. cheap) interpolation
	Like OpenCV's CV_INTER_LINEAR
	Answer Color transparent if outside image bounds.
	Copied almost verbatim from FloatImage.
	Answer Colors with float components. Will be rounded to be stored in, for example, a 32-bit Form."

	| x y w interpolated xWeight1 xWeight0 yWeight1 yWeight0 xIndex0 xIndex1 yIndex0 yIndex1 |
	x _ aPoint x.
	y _ aPoint y.
	x < 0.0 ifTrue: [ ^Color transparent ].
	xIndex0 _ x truncated. 		"Could be #floor. But as we only care for values >=0, it is the same. But faster."
	xIndex0 > (width-1) ifTrue: [ ^Color transparent ].
	(xIndex0 = (width-1) and: [ x > (width-1) ]) ifTrue: [ ^Color transparent ].
	xIndex1 _ xIndex0 = (width-1) 	"Avoid the invalid access if this was true, but don't make it slower the most common, general case."
		ifFalse: [ xIndex0 + 1 ]
		ifTrue: [ xIndex0 ].

	y < 0.0 ifTrue: [ ^Color transparent ].
	yIndex0 _ y truncated.			"Could be #floor. But as we only care for values >=0, it is the same. But faster."
	yIndex0 > (height-1) ifTrue: [ ^Color transparent ].
	(yIndex0 = (height-1) and: [ y > (height-1) ]) ifTrue: [ ^Color transparent ].
	yIndex1 _ yIndex0 = (height-1) 	"Avoid the invalid access if this was true, but don't make it slower the most common, general case."
		ifFalse: [ yIndex0 + 1 ]
		ifTrue: [ yIndex0 ].

	xWeight1 _ x - xIndex0.
	xWeight0 _ 1.0 - xWeight1.

	yWeight1 _ y - yIndex0.
	yWeight0 _ 1.0 - yWeight1.

	"/* perform interpolation */"
	w _ ((self colorAt: xIndex0 @ yIndex0) * xWeight0) +
		((self colorAt: xIndex1 @ yIndex0) * xWeight1).
	interpolated _ w * yWeight0.

	w _ ((self colorAt: xIndex0 @ yIndex1) * xWeight0) +
		((self colorAt: xIndex1 @ yIndex1) * xWeight1).
	interpolated _ w * yWeight1 + interpolated.

	^interpolated! !

!Form methodsFor: 'scaling, rotation' stamp: 'jmv 12/2/2016 15:47:08'!
                 flippedBy: direction
	"Return a copy of the receiver flipped either #vertical, #horizontal or #both. (#both is a 180 degrees rotation)
	Form lena display.
	(Form lena flippedBy: #vertical) display.
	(Form lena flippedBy: #horizontal) display.
	(Form lena flippedBy: #both) display.
	"
	| newForm quad |
	newForm _ self class extent: self extent depth: depth.
	quad _ self boundingBox innerCorners.
	quad _ (
		direction caseOf: {
			[ #vertical ] 		-> [#(2 1 4 3)].
			[ #horizontal ] 	-> [#(4 3 2 1)].
			[ #both ] 			-> [#(3 4 1 2)]})
		collect: [:i | quad at: i].
	(WarpBlt toForm: newForm)
		sourceForm: self;
		colorMap: (self colormapIfNeededFor: newForm);
		combinationRule: 3;
		copyQuad: quad toRect: newForm boundingBox.
"	newForm offset: (self offset flippedBy: direction centerAt: aPoint)."
	^ newForm
"
[Sensor isAnyButtonPressed] whileFalse:
	[((Form fromDisplay: (Sensor mousePoint extent: 130@66))
			flippedBy: #vertical centerAt: 0@0) display]
"
"Consistency test...
 | f f2 p |
[ Sensor isAnyButtonPressed ] whileFalse: [
	f _ Form fromDisplay: ((p _ Sensor mousePoint) extent: 31@41).
	Display fillBlack: (p extent: 31@41).
	f2 _ f flippedBy: #vertical centerAt: 0@0.
	(f2 flippedBy: #vertical centerAt: 0@0) displayAt: p ]
"! !

!Form methodsFor: 'transitions' stamp: 'jmv 6/19/2017 15:50:50'!
                             pageWarp: otherImage at: topLeft forward: forward
	"Produce a page-turning illusion that gradually reveals otherImage
	located at topLeft in this form.
	forward == true means turn pages toward you, else away. [ignored for now]"
	| pageRect oldPage nSteps buffer p leafRect sourceQuad warp oldBottom d |
	pageRect _ otherImage boundingBox.
	oldPage _ self copy: (pageRect translatedBy: topLeft).
	(forward ifTrue: [oldPage] ifFalse: [otherImage])
		border: pageRect
		widthRectangle: (Rectangle
				left: 0
				right: 2
				top: 1
				bottom: 1)
		rule: Form over
		fillColor: Color black.
	oldBottom _ self copy: ((pageRect bottomLeft + topLeft) extent: (pageRect width@(pageRect height//4))).
	nSteps _ 8.
	buffer _ Form extent: otherImage extent + (0@(pageRect height//4)) depth: self depth.
	d _ pageRect topLeft + (0@(pageRect height//4)) - pageRect topRight.
	1 to: nSteps-1 do:
		[:i | forward
			ifTrue: [buffer copy: pageRect from: otherImage to: `0@0` rule: Form over.
					p _ pageRect topRight + (d * i // nSteps)]
			ifFalse: [buffer copy: pageRect from: oldPage to: `0@0` rule: Form over.
					p _ pageRect topRight + (d * (nSteps-i) // nSteps)].
		buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
		leafRect _ pageRect topLeft corner: p x @ (pageRect bottom + p y).
		sourceQuad _ Array with: pageRect topLeft
			with: pageRect bottomLeft + (0@p y)
			with: pageRect bottomRight
			with: pageRect topRight - (0@p y).
		warp _ (WarpBlt toForm: buffer)
				clipRect: leafRect;
				sourceForm: (forward ifTrue: [oldPage] ifFalse: [otherImage]);
				combinationRule: Form paint.
		warp copyQuad: sourceQuad toRect: leafRect.
		self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
		Display forceToScreen.
		].

	buffer copy: pageRect from: otherImage to: `0@0` rule: Form over.
	buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
	self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
	Display forceToScreen.
"
1 to: 4 do: [:corner | Display pageWarp:
				(Form fromDisplay: (10@10 extent: 200@300)) reverse
			at: 10@10 forward: false]
"
! !

!Form methodsFor: 'private' stamp: 'jmv 6/19/2017 16:04:06'!
    copyFromByteArray: bigEndianByteArray
	"This method should work with either byte orderings.
	See comment at Bitmap>>#asByteArray
	Also see #copyFromByteArray2:to:"

	| myHack byteHack |
	myHack := Form new hackBits: bits.
	byteHack := Form new hackBits: bigEndianByteArray.
	"We are passing a ByteArray instead of a Words object. Will be accessed according to native endianness."
	Smalltalk isLittleEndian = self isLittleEndian ifFalse: [byteHack swapEndianness].
	byteHack displayOn: myHack at: `0 @ 0` rule: Form over! !

!Form methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:04:13'!
                fromDisplay: aRectangle 
	"Create a virtual bit map from a user specified rectangular area on the 
	display screen. Reallocates bitmap only if aRectangle ~= the receiver's 
	extent."

	(width = aRectangle width and: [height = aRectangle height])
		ifFalse: [self setExtent: aRectangle extent depth: depth].
	self
		copyBits: (aRectangle origin extent: self extent)
		from: Display
		at: `0 @ 0`
		clippingBox: self boundingBox
		rule: Form over! !

!Form methodsFor: 'encoding' stamp: 'jmv 6/19/2017 15:49:02'!
 addDeltasFrom: previousForm

	(BitBlt 
		destForm: self 
		sourceForm: previousForm 
		fillColor: nil 
		combinationRule: Form reverse
		destOrigin: `0@0`
		sourceOrigin: `0@0`
		extent: self extent 
		clipRect: self boundingBox) copyBits.
	^self! !


Form class
	instanceVariableNames: ''!

!Form class methodsFor: 'instance creation' stamp: 'jmv 6/19/2017 16:37:08'!
               dotOfSize: diameter
	"Create a form which contains a round black dot."
	| radius form bb rect centerX centerY centerYBias centerXBias radiusSquared xOverY maxy dx |
	radius _ diameter//2.
	form _ self extent: diameter@diameter offset: `0@0` - radius.
	bb _ (BitBlt toForm: form)
		sourceX: 0; sourceY: 0;
		combinationRule: Form over;
		fillColor: Color black.
	rect _ form boundingBox.
	centerX _ rect center x.
	centerY _ rect center y.
	centerYBias _ rect height odd ifTrue: [0] ifFalse: [1].
	centerXBias _ rect width odd ifTrue: [0] ifFalse: [1].
	radiusSquared _ (rect height asFloat / 2.0) squared - 0.01.
	xOverY _ rect width asFloat / rect height asFloat.
	maxy _ rect height - 1 // 2.

	"First do the inner fill, and collect x values"
	0 to: maxy do:
		[:dy |
		dx _ ((radiusSquared - (dy * dy) asFloat) sqrt * xOverY) truncated.
		bb	destX: centerX - centerXBias - dx
			destY: centerY - centerYBias - dy
			width: dx + dx + centerXBias + 1
			height: 1;
			copyBits.
		bb	destY: centerY + dy;
			copyBits].
	^ form
"
Time millisecondsToRun:
	[1 to: 20 do: [:i | (Form dotOfSize: i) displayAt: (i*20)@(i*20)]]
"! !

!Form class methodsFor: 'instance creation' stamp: 'pb 5/4/2016 17:43'!
                 fakeSphereAt: aPoint diameter: diameter color: aColor
	"Create a form which contains a round black dot."
	| bb rect d p |
	bb _ GrafPort toForm: Display.
	bb fillColor: aColor.
	bb combinationRule: Form blend.
	rect _ aPoint extent: diameter.
	bb fillOval: rect.
	p _ (diameter * 2 // 5) asPoint + aPoint.
	#(2 3 4 5 6 ) do: [ :i |
		"simulate facade by circles of gray"
		bb fillColor: (Color white alpha: 0.3).
		d _ i * diameter // 10.
		rect _ Rectangle
			center: p
			extent: d.
		bb fillOval: rect ].
	DisplayScreen screenUpdateRequired: nil.
"
	Form fakeSphereAt: 50@50 diameter: 30 color:  (Color red alpha: 0.5)
"! !

!Form class methodsFor: 'examples' stamp: 'jmv 6/19/2017 16:04:23'!
        toothpaste: diam	
	"
	Display restoreAfter: [Form toothpaste: 30]
	"
	"Not completely unlike the ST-80 implementation :)
	Original comment:
	Draws wormlike lines by laying down images of spheres.
	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.
	Draw with mouse button down; terminate by option-click."
	| point queue color q colors colr colr2 |
	colors _ Color red wheel: 12.
	color _ 8.
	[ true ] whileTrue: [
		queue _ OrderedCollection new: 32.
		16 timesRepeat: [queue addLast: `-40@-40`].
		Sensor waitButton.
		Sensor isMouseButton2Pressed ifTrue: [^ self].
		point _ Sensor mousePoint.
		colr _ colors atWrap: (color _ color + 5).  "choose increment relatively prime to colors size"
		colr2 _ colr alpha: 0.3.
		[Sensor isMouseButton1Pressed or: [queue size > 0]] whileTrue: [
			point _ point * 4 + Sensor mousePoint // 5.
			point _ point.
			Form fakeSphereAt: point diameter: diam color: colr.
			(q _ queue removeFirst) ifNil: [^ self].	"exit"
			Form fakeSphereAt: q diameter: diam color: colr2.
			Sensor isMouseButton1Pressed ifTrue: [queue addLast: point]]]! !

!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 5/15/2015 09:37'!
                bottomLeftCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form for the bottomLeft corner of a rounded rectangle"
	| f aaw topColor bottomColor l d c width dy |
	topColor _ Color white * gradientTopFactor.
	bottomColor _ Color white * gradientBottomFactor.
	width _ r.
	aaw _ 1.3.
	f _ Form
		extent: width @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: width - 1
				do: [ :x |
					dy _ height - r - y.
					dy > 0
						ifTrue: [ l _ 1.0 ]
						ifFalse: [
							d _ (width - 1 - x @ dy) r.
							l _ ((r - d max: 0.0) min: aaw) / aaw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !

!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 5/15/2015 09:47'!
                bottomLeftCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor borderWidth: bw
	"Create and answer a Form for the bottomLeft corner of a rounded rectangle"
	| f aaw topColor bottomColor l d c width dy l1 l2 |
	topColor _ Color white * gradientTopFactor.
	bottomColor _ Color white * gradientBottomFactor.
	width _ r.
	aaw _ 1.3.
	f _ Form
		extent: width @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: width - 1
				do: [ :x |
					dy _ height - r - y.
					dy > 0
						ifTrue: [ l _ 1.0 ]
						ifFalse: [
							d _ (width - 1 - x @ dy) r.
							l1 _ ((r - d-1+aaw max: 0.0) min: aaw) / aaw.
							l2 _ ((d - r+bw+aaw max: 0.0) min: aaw) / aaw.
							l _ l1 min: l2.
							].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !

!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 5/15/2015 09:38'!
                              bottomRightCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form for the bottomRight corner of a rounded rectangle"
	| f aaw topColor bottomColor l d c width dy |
	topColor _ Color white * gradientTopFactor.
	bottomColor _ Color white * gradientBottomFactor.
	width _ r.
	aaw _ 1.3.
	f _ Form
		extent: width @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: width - 1
				do: [ :x |
					dy _ height - r - y.
					dy > 0
						ifTrue: [ l _ 1.0 ]
						ifFalse: [
							d _ (x @ dy) r.
							l _ ((r - d max: 0.0) min: aaw) / aaw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !

!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 5/15/2015 09:41'!
                          bottomRightCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor borderWidth: bw
	"Create and answer a Form for the bottomLeft corner of a rounded rectangle"
	| f aaw topColor bottomColor l d c width dy l1 l2 |
	topColor _ Color white * gradientTopFactor.
	bottomColor _ Color white * gradientBottomFactor.
	width _ r.
	aaw _ 1.3.
	f _ Form
		extent: width @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: width - 1
				do: [ :x |
					dy _ height - r - y.
					dy > 0
						ifTrue: [ l _ 1.0 ]
						ifFalse: [
							d _ (x @ dy) r.
							l1 _ ((r - d-1+aaw max: 0.0) min: aaw) / aaw.
							l2 _ ((d - r+bw+aaw max: 0.0) min: aaw) / aaw.
							l _ l1 min: l2.
							].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !

!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 11/30/2010 10:34'!
        topLeftCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form with a vertical gray gradient as specified for the topLeft corner of a rounded rectangle"
	| f bw topColor bottomColor l d c w |
	topColor _ Color white * gradientTopFactor.
	bottomColor _ Color white * gradientBottomFactor.
	w _ r.
	bw _ 1.3.
	f _ Form
		extent: w @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: w - 1
				do: [ :x |
					l _ 1.0.
					y < r ifTrue: [
						d _ (w - 1 - x @ (w - 1 - y)) r.
						l _ ((r - d max: 0.0) min: bw) / bw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !

!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 11/30/2010 10:36'!
            topRightCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form with a vertical gray gradient as specified for the topRight corner of a rounded rectangle"
	| f bw topColor bottomColor l d c w |
	topColor _ Color white * gradientTopFactor.
	bottomColor _ Color white * gradientBottomFactor.
	w _ r.
	bw _ 1.3.
	f _ Form
		extent: w @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: w - 1
				do: [ :x |
					l _ 1.0.
					y < r ifTrue: [
						d _ (x @ (w - y - 1)) r.
						l _ ((r - d max: 0.0) min: bw) / bw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !


Number subclass: #Fraction
	instanceVariableNames: 'numerator denominator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Numbers'!

!Fraction methodsFor: 'mathematical functions' stamp: 'jmv 8/17/2017 21:38:55'!
                           nthRoot: aPositiveInteger
	"Answer the nth root of the receiver."
	| guess |
	guess _ (numerator nthRootTruncated: aPositiveInteger) /
				(denominator nthRootTruncated: aPositiveInteger).
	(guess raisedTo: aPositiveInteger) = self ifTrue: [
		^ guess ].
	"There is no exact nth root, so answer a Float approximation"
	^ (self abs ln / aPositiveInteger) exp * self sign! !

!Fraction methodsFor: 'mathematical functions' stamp: 'jmv 8/17/2017 21:37:35'!
                          raisedToFraction: aFraction
	| root |
	root _ (self numerator nthRootTruncated: aFraction denominator) /
			(self denominator nthRootTruncated: aFraction denominator).
	(root raisedToInteger: aFraction denominator) = self ifTrue: [
		^ root raisedToInteger: aFraction numerator ].
	^ super raisedToFraction: aFraction! !


BitBlt subclass: #GrafPort
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

!GrafPort methodsFor: 'text' stamp: 'jmv 6/1/2015 13:28'!
displayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font color: foregroundColor
	"If required, do a second pass with new rule and colorMap.
	Answer last affected pixel position
	Answer nil if nothing was done
	"

	| answer prevRule secondPassMap sourceDepth destDepth |

	"Slight optimization when there's nothing to do."
	clipHeight = 0 ifTrue: [^nil].
	clipWidth = 0 ifTrue: [^nil].

	self installStrikeFont: font foregroundColor: (foregroundColor alpha: 1).

	"If combinationRule is rgbMul, we might need the special two-pass technique for component alpha blending.
	If not, do it simply"
	combinationRule = 37 "rgbMul" ifFalse: [
		^self basicDisplayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font ].
	
	"We need to do a second pass. The colormap set is for use in the second pass."
	secondPassMap _ colorMap.
	sourceDepth _ sourceForm depth.
	destDepth _ destForm depth.
	colorMap _ sourceDepth ~= destDepth
		ifTrue: [ Color cachedColormapFrom: sourceDepth to: destDepth ].
	answer := self basicDisplayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font.
	colorMap := secondPassMap.
	secondPassMap ifNotNil: [
		prevRule := combinationRule.
		combinationRule := 20. "rgbAdd"
		self basicDisplayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font.
		combinationRule := prevRule ].
	^answer! !

!GrafPort methodsFor: 'private' stamp: 'jmv 5/12/2016 14:52'!
             cachedFontColormapFrom1BitTo: destDepth

	| map dstIndex |
	CachedFontColorMaps 
		ifNil: [CachedFontColorMaps _ Array new: 6].

	dstIndex _ destDepth highBit.
	(CachedFontColorMaps at: dstIndex) ifNotNil: [ :m | ^ m ].

	map _ (Color cachedColormapFrom: 1 to: destDepth) copy.
	CachedFontColorMaps at: dstIndex put: map.
	^ map! !

!GrafPort methodsFor: 'private' stamp: 'jmv 5/12/2016 14:55'!
                     colorConvertingMap: targetColor from: sourceDepth to: destDepth keepSubPixelAA: keepSubPix
	"Note: The color converting map for sourceDepth=16 and for sourceDepth=32 are the same"
	
	| srcIndex dstIndex map mapsForSource mapsForSourceAndDest |
	ColorConvertingMaps 
		ifNil: [ColorConvertingMaps _ (1 to: 6) collect: [:i | Array new: 6]].

	srcIndex _ sourceDepth highBit.
	sourceDepth > 8 ifTrue: [ srcIndex _ keepSubPix ifTrue: [5] ifFalse: [6] ].
	dstIndex _ destDepth highBit.
	
	mapsForSource _ ColorConvertingMaps at: srcIndex.
	(mapsForSourceAndDest _ mapsForSource at: dstIndex) ifNil: [
		mapsForSourceAndDest _ mapsForSource at: dstIndex put: Dictionary new ].
	
	map _ mapsForSourceAndDest at: targetColor ifAbsentPut: [
		Color 
			computeColorConvertingMap: targetColor 
			from: sourceDepth 
			to: destDepth 
			keepSubPixelAA: keepSubPix ].

	^ map! !

!GrafPort methodsFor: 'private' stamp: 'jmv 4/17/2014 16:57'!
                             setRuleAndMapFor: sourceDepth foregroundColor: foregroundColor

	| targetColor destDepth |
	destDepth _ destForm depth.
	halftoneForm _ nil.	"Don't use fillColor. Use a more powerful ColorMap"

	sourceDepth = 1 ifTrue: [
		self combinationRule: Form paint.
		"Set up color map for a different source depth (color font)"
		"Uses caching for reasonable efficiency"
		colorMap _ self cachedFontColormapFrom1BitTo: destDepth.
		colorMap at: 1 put: (destForm pixelValueFor: Color transparent).
		colorMap at: 2 put: (destForm pixelValueFor: foregroundColor) ]
	
	ifFalse: [
		"Enable subpixel rendering if requested, but never for translucent text:
		This technique always draws opaque text. This could be added, by using an extra colormap for the rgbMul phase...
		So far, no need arised for doing so."
		(sourceDepth > 8 and: [
			Preferences subPixelRenderFonts and: [ foregroundColor = Color black or: [ 
				Preferences subPixelRenderColorFonts and: [ foregroundColor isOpaque ]]]]) ifTrue: [
			destDepth > 8 ifTrue: [
				"rgbMul is equivalent to component alpha blend if text is black (only faster, hehe)"
				self combinationRule: 37.		"rgbMul"
				colorMap _ (foregroundColor ~= Color black or: [
						destDepth = 32 and: [ destForm ~~ Display or: [Preferences properDisplayAlphaForFonts] ]]) ifTrue: [
					"rgbMul / rgbAdd IS component alpha blend for any color of text (neat trick, eh!!)"
					"This colorMap is to be used on the second pass with rule 20 (rgbAdd)
					See #displayString:from:to:at:strikeFont:color:"
					"Note: In 32bpp, if we want the correct alpha in the result, we need the second pass, as the destination could have transparent pixels, 
					and we need to add to the alpha channel"
					self colorConvertingMap: foregroundColor from: sourceDepth to: destDepth keepSubPixelAA: true]]
			ifFalse: [
				self combinationRule: 25.		"Paint"
				targetColor _ foregroundColor = Color black ifFalse: [ foregroundColor ].
				colorMap _ self colorConvertingMap: targetColor from: sourceDepth to: destDepth keepSubPixelAA: true]]
		ifFalse: [
			"Do not use rule 34 for 16bpp display. TTCFont uses it, but it builds a glyphs cache for each color used!!"
			self combinationRule: (destDepth = 32 ifTrue: [34 "alphaBlendScaled"] ifFalse: [25 "Paint"]).
			colorMap _ self colorConvertingMap: foregroundColor from: sourceDepth to: destDepth keepSubPixelAA: false]]! !


Form subclass: #GrayForm
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Display Objects'!

!GrayForm methodsFor: 'pixel accessing' stamp: 'jmv 5/11/2016 19:57'!
                         grayAt: aPoint
	"Return the color of the pixel at aPoint."

	^Color gray: (self pixelValueAt: aPoint) asFloat / 255.0! !

!GrayForm methodsFor: 'color manipulation' stamp: 'jmv 5/12/2016 15:04'!
                             colormapIfNeededForDepth: destDepth
	"Return a colormap for displaying the receiver at the given depth, or nil if no colormap is needed."

	^ Color cachedColormapFromGrayTo: destDepth! !

!GrayForm methodsFor: 'copying' stamp: 'jmv 6/19/2017 15:52:16'!
   copy: aRect
 	"Return a new instance containing the portion of the receiver delineated by aRect."

	| newForm |
	newForm _ self class extent: aRect extent depth: depth.
	((BitBlt
		destForm: newForm
		sourceForm: self
		combinationRule: Form over
		destOrigin: `0@0`
		sourceOrigin: aRect origin
		extent: aRect extent
		clipRect: newForm boundingBox)
		colorMap: nil) copyBits.
	^ newForm! !


RectangleLikeMorph subclass: #HaloHandleMorph
	instanceVariableNames: 'mouseDownSelector mouseUpSelector mouseMoveSelector'
	classVariableNames: 'CircleForm'
	poolDictionaries: ''
	category: 'Morphic-Halos'!

!HaloHandleMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:52:21'!
                            drawOn: aCanvas

	aCanvas
		image: (self class circleForm: extent)
		multipliedBy: color
		at: `0@0`! !


HaloHandleMorph class
	instanceVariableNames: ''!

!HaloHandleMorph class methodsFor: 'accessing' stamp: 'jmv 11/18/2010 09:44'!
                     circleForm: extent
	"
	CircleForm _ nil
	"
	| r d l bw center |
	(CircleForm isNil or: [ CircleForm extent ~= extent ]) ifTrue: [
		center _ extent -1 * 0.5.
		r _ center r * 0.75.
		bw _ 1.3.
		CircleForm _ Form extent: extent depth: 32.
		0 to: extent y - 1 do: [ :y |
			0 to: extent x - 1 do: [ :x |
				d _ (x@y - center) r.
				l _ (r - d max: 0.0) min: bw.
				CircleForm
					colorAt: x @ y
					put: (Color white alpha: (l / bw))
					]].
		].
	^CircleForm! !

!HaloHandleMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:53:34'!
              categoryInNewMorphMenu
	^ 'Halos'! !


RectangleLikeMorph subclass: #HaloMorph
	instanceVariableNames: 'target positionOffset angleOffset growingOrRotating haloBox'
	classVariableNames: 'HandleSize Icons'
	poolDictionaries: ''
	category: 'Morphic-Halos'!

!HaloMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:28'!
                           defaultColor
	"answer the default color/fill style for the receiver"
	^ Color
		r: 0.6
		g: 0.8
		b: 1.0! !

!HaloMorph methodsFor: 'private' stamp: 'jmv 6/19/2017 15:52:25'!
                 addHandle: handleSpec
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."

	| handle aPoint colorToUse form icon |
	aPoint _ self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	colorToUse _ Color colorFrom: handleSpec color.
	handle _ HaloHandleMorph new color: colorToUse.
	self addMorph: handle.
	handle morphBoundsInWorld: (Rectangle center: aPoint extent: self class handleSize asPoint).
	handleSpec iconSymbol ifNotNil: [ :iconName |
			form _ self class icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				icon _ ImageMorph new
					image: form;
					color: colorToUse makeForegroundColor;
					lock.
				handle addMorphFront: icon position: `0@0` ]].
	handle mouseUpSelector: #endInteraction.
	handle setBalloonText: handleSpec hoverHelp.
	^handle! !

!HaloMorph methodsFor: 'private' stamp: 'jmv 7/4/2016 22:14'!
                       addNameString: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph namePosition nameBackground |
	nameBackground _ RectangleLikeMorph new
		color: ((target is: #SystemWindow) ifTrue: [target windowColor] ifFalse: [Color lightBlue alpha: 0.9]).
	nameMorph _ StringMorph contents: aString.
	nameMorph color: Color black.
	nameBackground morphExtent: nameMorph morphExtent + 4.
	namePosition _ haloBox width - nameMorph morphWidth // 2 @ (haloBox height).
	self addMorph: nameBackground position: namePosition - 2.
	self addMorph: nameMorph position: namePosition.
	^nameMorph! !

!HaloMorph methodsFor: 'private' stamp: 'jmv 6/19/2017 16:04:44'!
                            basicBox
	| aBox minSide anExtent w |
	minSide _ 4 * self class handleSize.
	anExtent _ ((extent x + self class handleSize + 8) max: minSide) @
				((extent y + self class handleSize + 8) max: minSide).
	aBox _ Rectangle center: self morphBoundsInWorld center extent: anExtent.
	w _ self world ifNil: [ target world ].
	^ w
		ifNil:
			[ aBox ]
		ifNotNil:
			[ aBox intersect: (w viewBox insetBy: `8@8`) ]! !

!HaloMorph methodsFor: 'private' stamp: 'jmv 9/22/2012 15:18'!
      doRot: evt with: rotHandle
	"Update the rotation of my target if it is rotatable.  Keep the relevant command object up to date."

	| degrees |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
	degrees _ (evt eventPosition - target referencePosition) degrees.
	degrees _ degrees - angleOffset degrees.
	degrees _ degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.
	degrees = 0.0
		ifTrue: [rotHandle color: Color lightBlue]
		ifFalse: [rotHandle color: Color blue].
	rotHandle submorphsDo:
		[:m | m color: rotHandle color makeForegroundColor].
	self removeAllHandlesBut: rotHandle.

	target rotationDegrees: degrees.

	rotHandle morphPositionInWorld: evt eventPosition - (rotHandle morphExtent // 2)! !

!HaloMorph methodsFor: 'private' stamp: 'jmv 9/20/2012 00:01'!
             setDismissColor: evt with: dismissHandle
	"Called on mouseStillDown in the dismiss handle; set the color appropriately."

	| colorToUse |
	evt hand obtainHalo: self.
	colorToUse _  (dismissHandle morphContainsPoint:  (dismissHandle internalizeFromWorld: evt eventPosition))
		ifFalse: [ Color red muchLighter ]
		ifTrue: [ Color lightGray ].
	dismissHandle color: colorToUse! !

!HaloMorph methodsFor: 'private' stamp: 'jmv 6/19/2017 15:52:32'!
   startGrow: evt with: growHandle
	"Initialize resizing of my target.  Launch a command representing it, to support Undo"

	| botRt |
	evt hand obtainHalo: self.	"Make sure the event's hand correlates with the receiver"
	self removeAllHandlesBut: growHandle.  "remove all other handles"
	botRt _ target morphPositionInWorld + target morphExtentInWorld.
	positionOffset _ (self world viewBox containsPoint: botRt)
		ifTrue: [evt eventPosition - botRt]
		ifFalse: [`0@0`]! !

!HaloMorph methodsFor: 'stepping' stamp: 'len 7/25/2016 21:39'!
        step
	(target isNil or: [target isInWorld not]) ifTrue: [self delete]! !

!HaloMorph methodsFor: 'stepping' stamp: 'len 7/25/2016 21:41'!
                      stepTime
	^ 100! !

!HaloMorph methodsFor: 'stepping' stamp: 'len 7/25/2016 21:38'!
            wantsSteps
	^ true! !


HaloMorph class
	instanceVariableNames: ''!

!HaloMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:53:26'!
     categoryInNewMorphMenu
	^ 'Halos'! !


RectangleLikeMorph subclass: #HandMorph
	instanceVariableNames: 'mouseFocus keyboardFocus mouseClickState mouseOverHandler lastMouseEvent damageRecorder hasChanged savedPatch lastEventBuffer lastKeyDownValue lastMouseEventTime prevFullBounds grabMorphData'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

!HandMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:52:36'!
          drawOn: aCanvas 
	"Draw the hand itself (i.e., the cursor)."
	"This method is only called when we are carrying morphs around..."
	 aCanvas
		stencil: Cursor move
		at: `0@0`
		color: Color black! !

!HandMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:52:45'!
                       savePatchFrom: aCanvas appendDamageTo: aStream
	"Save the part of the given canvas under this hand as a Form and return its bounding rectangle."

	"Details: The previously used patch Form is recycled when possible to reduce the burden on storage management."

	| fullBounds |
	fullBounds _ self morphFullBoundsInWorld.
	fullBounds ifNil: [ ^self ].

	fullBounds _ fullBounds intersect: (`0@0` extent: aCanvas extent).
	(savedPatch isNil or: [savedPatch extent ~= fullBounds extent]) 
		ifTrue: [
			"allocate new patch form if needed"
			savedPatch _ Form extent: fullBounds extent depth: aCanvas depth ].
	aCanvas
		contentsOfArea: fullBounds
		into: savedPatch.
	savedPatch offset: fullBounds topLeft.
	prevFullBounds
		ifNil: [ aStream nextPut: fullBounds ]
		ifNotNil: [ aStream nextPut: (fullBounds merge: prevFullBounds)].
	prevFullBounds _ fullBounds! !

!HandMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 15:52:41'!
                         initForEvents
	mouseOverHandler _ nil.
	lastMouseEvent _ MouseEvent new setType: #mouseMove position: `0@0` buttons: 0 hand: self.
	lastMouseEventTime _ Time localMillisecondClock.
	lastEventBuffer _ {1. 0. 0. 0. 0. 0. nil. nil}.
	self dontWaitForMoreClicks! !


EllipseMorph subclass: #HandleMorph
	instanceVariableNames: 'pointBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!HandleMorph methodsFor: 'events' stamp: 'jmv 6/19/2017 16:05:03'!
keyStroke: aKeyboardEvent
	"Check for cursor keys"
	| keyValue |
	(owner is: #HandMorph) ifFalse: [ ^self ].
	keyValue _ aKeyboardEvent keyValue.
	keyValue = 28 ifTrue: [ ^self morphPosition: self morphPosition - `1@0` ].
	keyValue = 29 ifTrue: [ ^self morphPosition: self morphPosition + `1@0` ].
	keyValue = 30 ifTrue: [ ^self morphPosition: self morphPosition - `0@1` ].
	keyValue = 31 ifTrue: [ ^self morphPosition: self morphPosition + `0@1` ].
	"Special case for return"
	aKeyboardEvent isReturnKey ifTrue:[
		"Drop the receiver and be done"
	self flag: #arNote. "Probably unnecessary"
		owner releaseKeyboardFocus: self.
		self delete ]! !

!HandleMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:04:48'!
             initialize
	"initialize the state of the receiver"
	super initialize.
	extent _ `12@12`! !


PluggableScrollPane subclass: #HierarchicalListMorph
	instanceVariableNames: 'selectedMorph getListSelector keystrokeActionSelector autoDeselect autoExpand sortingSelector getSelectionSelector setSelectionSelector menuGetter mainView highlightedMorph doubleClickSelector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!HierarchicalListMorph methodsFor: 'commands' stamp: 'pb 7/27/2017 14:24:23'!
                          toggleExpandedState: aMorph event: event

	"self setSelectedMorph: aMorph."
	((self autoExpand or: [event shiftPressed]) and: [aMorph isExpanded not])
		ifTrue: [aMorph beFullyExpanded]
		ifFalse: [aMorph toggleExpandedState].
	scroller adjustExtent.
	self setScrollDeltas! !

!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 12/29/2016 10:55:06'!
                             doubleClick: aMouseButtonEvent localPosition: localEventPosition

	doubleClickSelector ifNil: [ ^super doubleClick: aMouseButtonEvent localPosition: localEventPosition ].
	^ self model perform: doubleClickSelector! !

!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 12/29/2016 10:53:49'!
                        mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition

	| itemMorph |
	aMouseButtonEvent hand newKeyboardFocus: self.
	itemMorph _ self itemFromPoint: localEventPosition.
	itemMorph ifNil: [ ^super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition ].
	self highlightedMorph: itemMorph.
	(itemMorph inToggleArea: (itemMorph internalize: (scroller internalize: localEventPosition)))
		ifTrue: [ ^self toggleExpandedState: itemMorph event: aMouseButtonEvent ]. 
	aMouseButtonEvent hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self 
		event: aMouseButtonEvent 
		clkSel: #click:localPosition:
		clkNHalf: nil
		dblClkSel: (doubleClickSelector ifNotNil: [ #doubleClick:localPosition: ])
		dblClkNHalfSel: nil
		tripleClkSel: nil! !

!HierarchicalListMorph methodsFor: 'initialization' stamp: 'jmv 12/29/2016 10:55:42'!
       doubleClickSelector: aSymbol
	doubleClickSelector _ aSymbol! !

!HierarchicalListMorph methodsFor: 'keyboard navigation' stamp: 'pb 8/31/2017 05:46:22'!
       arrowKey: aChar
	"Handle a keyboard navigation character. Answer true if handled, false if not."
	| keyEvent answer nextSelection oldSelection |
	answer := false.
	keyEvent := aChar numericValue.
	oldSelection := self getSelectionIndex.
	nextSelection := oldSelection.
	keyEvent = 31 ifTrue: [
		"down"
		nextSelection := oldSelection + 1.
		nextSelection > self maximumSelection ifTrue: [ nextSelection := self minimumSelection ]].
	keyEvent = 30 ifTrue: [
		"up"
		nextSelection := oldSelection - 1.
		nextSelection < self minimumSelection ifTrue: [ nextSelection := self maximumSelection ]].
	keyEvent = 1 ifTrue: [ "home"
		nextSelection := 1 ].
	keyEvent = 4 ifTrue: [ "end"
		nextSelection := scroller submorphs size ].
	keyEvent = 11 ifTrue: [ "page up"
		nextSelection := oldSelection - self numSelectionsInView max: 1 ].
	keyEvent = 12 ifTrue: [ "page down"
		nextSelection := oldSelection + self numSelectionsInView ].
	keyEvent = 29 ifTrue: [
		"right"
		selectedMorph ifNotNil: [
			(selectedMorph canExpand and: [ selectedMorph isExpanded not ])
				ifTrue: [
					self toggleExpandedState: selectedMorph.
					answer := true ]
				ifFalse: [ nextSelection := oldSelection + 1 ]]].
	keyEvent = 28 ifTrue: [
		"left"
		selectedMorph ifNotNil: [
			selectedMorph isExpanded
				ifTrue: [
					self toggleExpandedState: selectedMorph.
					answer := true ]
				ifFalse: [ nextSelection := oldSelection - 1 max: 1 ]].
		^ true ].
	nextSelection = oldSelection ifFalse: [
		"Highlight the row to be selected, for immediate user feedback in case the model takes a while to update the view."
		self highlightedMorph: (self listMorphAt: nextSelection).
		"Update the model in next world cycle, so user gets the immediate feedback."
		WorldState addDeferredUIMessage: [ self setSelectionIndex: nextSelection ].
		answer := true ].
	^ answer.! !


RectangleLikeMorph subclass: #HoverHelpMorph
	instanceVariableNames: 'contents textComposition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!HoverHelpMorph methodsFor: 'initialization' stamp: 'jmv 9/25/2011 23:12'!
             defaultColor

	^Color r: 1.0 g: 1.0 b: 0.7! !

!HoverHelpMorph methodsFor: 'drawing' stamp: 'jmv 12/20/2014 15:09'!
            drawOn: aCanvas

	| r |
	r _ self morphLocalBounds.
	aCanvas roundRect: r color: self color radius: 4.
	aCanvas
		textComposition: textComposition
		bounds: (r insetBy: 4)
		color: Color black
		selectionColor: (Theme current textHighlightFocused: false)! !


HoverHelpMorph class
	instanceVariableNames: ''!

!HoverHelpMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:54:39'!
               categoryInNewMorphMenu
	^ 'Widgets'! !


RectangleLikeMorph subclass: #ImageMorph
	instanceVariableNames: 'image'
	classVariableNames: 'DefaultForm'
	poolDictionaries: ''
	category: 'Morphic-Basic'!

!ImageMorph methodsFor: 'accessing' stamp: 'jmv 3/14/2011 09:15'!
                      color: aColor
        super color: aColor.
        (image depth = 1 and: [aColor is: #Color]) ifTrue: [
                image colors: {Color transparent. aColor}.
                self redrawNeeded]! !

!ImageMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:52:49'!
                   drawOn: aCanvas

	aCanvas image: image at: `0@0`! !


ImageMorph class
	instanceVariableNames: ''!

!ImageMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:54:09'!
     categoryInNewMorphMenu
	^ 'Basic'! !


StringMorph subclass: #IndentingListItemMorph
	instanceVariableNames: 'indentLevel isExpanded complexContents firstChild container nextSibling isSelected icon isHighlighted'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!IndentingListItemMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:53:00'!
                 drawOn: aCanvas

	| tRect colorToUse sLeft aForm centeringOffset |
	isHighlighted ifTrue: [
		aCanvas
			fillRectangle: (`0@0` extent: extent)
			color: (Theme current
				listHighlightFocused: owner owner hasKeyboardFocus) duller ].
	isSelected ifTrue: [
		aCanvas
			fillRectangle: (`0@0` extent: extent)
			color: (Theme current
				listHighlightFocused: owner owner hasKeyboardFocus) ].
			
	tRect _ self toggleRectangle.
	aForm _ isExpanded 
		ifTrue: [ container expandedForm ]
		ifFalse: [ container notExpandedForm ].
	centeringOffset _ ((tRect height - aForm extent y) / 2.0) rounded.

	complexContents hasContents ifTrue: [
		aCanvas 
			image: aForm 
			at: (tRect topLeft translatedBy: 0 @ centeringOffset) ].

	icon isNil
	ifFalse: [
		 aCanvas 
			image: icon
			at:  (tRect topLeft translatedBy:  icon width  @ centeringOffset).
		sLeft _ indentLevel * 12 + 16 + (icon width + 2).
	]
	ifTrue: [
		sLeft _ indentLevel * 12 + 16.
	].
	colorToUse _ complexContents preferredColor ifNil: [ color ].

	aCanvas
		drawString: contents asString
		at: sLeft@0
		font: self fontToUse
		color: colorToUse! !


InnerPluggableMorph subclass: #InnerHierarchicalListMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!InnerHierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 6/19/2017 16:36:31'!
                  itemFromPoint: aPoint
	"Return the list element (morph) at the given point or nil if outside"
	| ptY last |
	self hasSubmorphs ifFalse: [ ^nil ].
	(aPoint > `0@0` and: [ aPoint < extent ]) ifFalse: [ ^nil ].
	ptY _ aPoint y.
	"note: following assumes that submorphs are vertical, non-overlapping, and ordered"
	self firstSubmorph morphPosition y > ptY ifTrue: [ ^nil ].
	last _ self lastSubmorph.
	last morphPosition y + last morphHeight < ptY ifTrue: [ ^nil ].
	"now use binary search"
	^self 
		findSubmorphBinary: [ :m |
			(m morphPosition y <= ptY and: [ m morphPosition y + m morphHeight >= ptY ])
				ifTrue: [ 0 ] "found"
				ifFalse: [ m morphPosition y + (m morphHeight // 2) > ptY ifTrue: [-1] ifFalse: [1]]]! !


InnerPluggableMorph subclass: #InnerListMorph
	instanceVariableNames: 'listItems font selectedRow highlightedRow'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!InnerListMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 15:21:44'!
initialize
	super initialize.
	self color: Color black.
	font _ Preferences standardListFont.
	listItems _ #().
	selectedRow _ nil.
	highlightedRow _ nil! !

!InnerListMorph methodsFor: 'list management' stamp: 'jmv 6/19/2017 15:21:40'!
                   listChanged
	"set newList to be the list of strings to display"
	listItems _ Array new: self getListSize withAll: nil.
	selectedRow _ nil.
	self adjustExtent! !

!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:53:10'!
                       drawBackgroundForMulti: row on: aCanvas
	| selectionDrawBounds c |
	"shade the background darker, if this row is selected"
	selectionDrawBounds _ self drawBoundsForRow: row.
	selectionDrawBounds _ selectionDrawBounds intersect: (`0@0` extent: extent).
	c _ (selectedRow notNil and: [ row = selectedRow])
		ifTrue: [ Theme current listHighlightFocused: owner hasKeyboardFocus ]
		ifFalse: [ Theme current listMultiHighlightFocused: owner hasKeyboardFocus ].
	aCanvas fillRectangle: selectionDrawBounds color: c! !

!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:53:15'!
                       drawHighlightOn: aCanvas
"Ademas, poner el mouse pointer de relojito si tarda... Detectarlo automaticamente, etc. Aunque no estoy seguro de como hacerlo... quizas colgar un cachito de codigo en un proceso de mayor prioridad, onda 'si pasa 1 segundo, y todavia no te resetee este flag, entonces pone el relojito'"
	| selectionDrawBounds |
	highlightedRow  ifNil: [ ^self ].
	highlightedRow = 0 ifTrue: [ ^self ].
	selectionDrawBounds _ self drawBoundsForRow: highlightedRow.
	selectionDrawBounds _ selectionDrawBounds intersect: (`0@0` extent: extent).
	aCanvas
		fillRectangle: selectionDrawBounds
		color: (Theme current listHighlightFocused: owner hasKeyboardFocus) duller! !

!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:53:20'!
                  drawSelectionOn: aCanvas
	| selectionDrawBounds |
	selectedRow ifNil: [ ^self ].
	selectedRow = 0 ifTrue: [ ^self ].
	selectionDrawBounds _ self drawBoundsForRow: selectedRow.
	selectionDrawBounds _ selectionDrawBounds intersect: (`0@0` extent: extent).
	aCanvas
		fillRectangle: selectionDrawBounds
		color: (Theme current listHighlightFocused: owner hasKeyboardFocus)! !

!InnerListMorph methodsFor: 'private' stamp: 'jmv 6/19/2017 15:21:48'!
   noSelection
	selectedRow _ nil.
	highlightedRow _ nil! !


InnerPluggableMorph subclass: #InnerTextMorph
	instanceVariableNames: 'model wrapFlag textComposition editor pauseBlinking acceptOnCR hasUnacceptedEdits hasEditingConflicts askBeforeDiscardingEdits styler autoCompleter mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 9/6/2017 10:01:59'!
                disableEditing
	self setProperty: #disablesEditing toValue: true.
	self stopBlinking! !

!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 9/6/2017 10:03:03'!
                               enableEditing
	
	self removeProperty: #disablesEditing! !

!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 10/16/2013 19:55'!
debugDrawLineRectsOn: aCanvas
	"Shows where text line rectangles are"

	self textComposition lines do: [ :line |
		aCanvas
			frameRectangle: line rectangle
			borderWidth: 1
			color: Color brown ]
! !

!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:53:24'!
             drawOn: aCanvas
	"Draw the receiver on a canvas"

	false ifTrue: [ self debugDrawLineRectsOn: aCanvas ].  "show line rects for debugging"

	aCanvas
		textComposition: self textComposition
		bounds: (`0@0` extent: extent)
		color: color
		selectionColor: (Theme current textHighlightFocused: self hasKeyboardFocus)! !

!InnerTextMorph methodsFor: 'editing' stamp: 'pb 7/6/2017 02:47:26'!
                             acceptContents
	"The message is sent when the user hits return or Cmd-S.
	Accept the current contents and end editing."
	"Inform the model of text to be accepted, and return true if OK."

	| accepted prevSelection prevScrollValue |
	
	prevSelection _ self editor selectionInterval copy.
	prevScrollValue _ owner verticalScrollBar scrollValue.
	
	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) ifTrue: [self flash. ^true].
	(self hasEditingConflicts and: [ self confirmAcceptAnyway not ]) ifTrue: [self flash. ^false].
	
	accepted _ model acceptContentsFrom: owner.
	"During the step for the browser, updatePaneIfNeeded is called, and 
		invariably resets the contents of the code-holding PluggableTextMorph
		at that time, resetting the cursor position and scroller in the process.
		The following line forces that update without waiting for the step,
 		then restores the cursor and scrollbar"
	
	"some implementors of acceptContentsFrom: answer self :("
	^accepted == true 
		ifTrue: [
			model refetch.
			self editor selectFrom: prevSelection first to: prevSelection last.
			WorldState addDeferredUIMessage: [
				self world ifNotNil: [ :w | w activeHand newKeyboardFocus: self ].
				owner verticalScrollBar internalScrollValue: prevScrollValue].
			true]
		ifFalse: [ false ]! !

!InnerTextMorph methodsFor: 'editing' stamp: 'HernanWilkinson 1/10/2017 15:56:51'!
                 confirmAcceptAnyway

	^ self confirm: 
'Caution!! Contents were saved
elsewhere since you started
editing them here.  Accept anyway?'! !

!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 8/26/2017 19:07:20'!
               hasUnacceptedEdits: aBoolean
	"Set the hasUnacceptedEdits flag to the given value. "
	aBoolean == hasUnacceptedEdits ifFalse: [
		hasUnacceptedEdits _ aBoolean.
		owner redrawNeeded].
	aBoolean ifFalse: [ hasEditingConflicts _ false].

	"shout:  re-style the text iff aBoolean is true
	Do not apply any formatting (i.e. changes to the characters in the text),
	just styling (i.e. TextAttributes)"
	aBoolean ifTrue: [
		self formatAndStyleIfNeeded ]! !

!InnerTextMorph methodsFor: 'event handling testing' stamp: 'jmv 9/6/2017 10:02:01'!
      disablesEditing

	^self hasProperty: #disablesEditing! !

!InnerTextMorph methodsFor: 'blinking cursor' stamp: 'jmv 9/6/2017 10:02:07'!
                        showsBlinkingCursor

	^self handlesKeyboard and: [ self disablesEditing not ]! !

!InnerTextMorph methodsFor: 'shout' stamp: 'jmv 8/26/2017 19:14:13'!
         formatAndStyleIfNeeded
	"Apply both formatting (changes to the characters in the text, such as
	preferred assignment operators), and styling (TextAttributes to make
	Smalltalk code easier to understand)"

	model formatAndStyleIfNeededWith: styler! !


Object subclass: #InputSensor
	instanceVariableNames: ''
	classVariableNames: 'ButtonDecodeTable InterruptSemaphore InterruptWatcherProcess'
	poolDictionaries: ''
	category: 'Kernel-Processes'!

!InputSensor methodsFor: 'keyboard' stamp: 'jmv 9/2/2016 11:08:09'!
                             kbdTest
	"
	Sensor kbdTest
	"
	"This test routine will print the unmodified character, its keycode,
	and the OR of all its modifier bits, until the character x is typed

Also useful:
	Sensor test
	"
	| char |
	char _ nil.
	[ char = $x ] whileFalse: [
		[ self keyboardPressed ] whileFalse.
		char _ self keyboard.
		Display fill: (5@5 extent: 400@20) fillColor: Color white.
		(String streamContents: [ :s |
			s
				nextPut: $-;
				nextPut: char;
				nextPut: $-;
				space;
				print: char numericValue;
				space.
			self isMouseButton3Pressed ifTrue: [ s nextPutAll: ' mouseButton3/blue/tertiary/halo ' ].
			self isMouseButton2Pressed ifTrue: [ s nextPutAll: ' mouseButton2/yellow/secondary/menu ' ].
			self isMouseButton1Pressed ifTrue: [ s nextPutAll: ' mouseButton1/red/primary ' ].
			self shiftPressed ifTrue: [ s nextPutAll: ' shift ' ].
			self controlKeyPressed ifTrue: [ s nextPutAll: ' control/ctrl ' ].
			(self primMouseButtons anyMask: 32) ifTrue: [ s nextPutAll: ' macOption ' ].
			self commandAltKeyPressed ifTrue: [ s nextPutAll: ' macCommand/winAlt ' ]])
		displayAt: 10 @ 10 ].! !

!InputSensor methodsFor: 'private' stamp: 'jmv 6/19/2017 15:53:29'!
        primMousePt
	"Primitive. Poll the mouse to find out its position. Return a Point. Fail if
	event-driven tracking is used instead of polling. Optional. See Object
	documentation whatIsAPrimitive."

	<primitive: 90>
	^ `0@0`! !


TextProvider subclass: #Inspector
	instanceVariableNames: 'acceptedContentsCache object selectionIndex context'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Inspector'!

!Inspector methodsFor: 'accessing' stamp: 'jmv 9/21/2009 15:16'!
                              selectedClassOrMetaClass

	^ self selectedClass	"I don't know any better"! !

!Inspector methodsFor: 'contents' stamp: 'jmv 9/6/2017 10:05:31'!
                acceptedStringOrText
	"We need our cache not to be modified by user changes"
	^acceptedContentsCache copy! !

!Inspector methodsFor: 'initialization' stamp: 'HAW 7/29/2017 15:28:27'!
         inspect: anObject 
	"Initialize the receiver so that it is inspecting anObject. There is no current selection.
	
	Normally the receiver will be of the correct class (as defined by anObject inspectorClass),
	because it will have just been created by sedning inspect to anObject.   However, the
	debugger uses two embedded inspectors, which are re-targetted on the current receiver
	each time the stack frame changes.  The left-hand inspector in the debugger has its
	class changed by the code here.  Care should be taken if this method is overridden to
	ensure that the overriding code calls 'super inspect: anObject', or otherwise ensures that 
	the class of these embedded inspectors are changed back."

	| c |
	c := anObject inspectorClass.
	self class ~= c ifTrue: [
		self class format = c format
			ifTrue: [self primitiveChangeClassTo: c basicNew]
			ifFalse: [self becomeForward: (c basicNew copyFrom: self)]].
	
	"Set 'object' before sending the initialize message, because some implementations
	of initialize (e.g., in DictionaryInspector) require 'object' to be non-nil."
	
	object := anObject. 
	self initialize! !

!Inspector methodsFor: 'user interface support' stamp: 'jmv 8/17/2017 16:28:29'!
        textStylerClassFor: textGetter

	^SHTextStylerST80! !

!Inspector methodsFor: 'user commands' stamp: 'jmv 12/29/2016 10:58:58'!
inspectSelection
	self selection inspect! !

!Inspector methodsFor: 'shout styling' stamp: 'jmv 8/17/2017 16:51:54'!
           bindingNamesDo: aBlock
	object class allInstVarNames do: aBlock! !

!Inspector methodsFor: 'shout styling' stamp: 'jmv 8/17/2017 16:52:08'!
                    hasBindingOf: aString
	^ object class allInstVarNames includes: aString! !

!Inspector methodsFor: 'shout styling' stamp: 'jmv 8/26/2017 19:42:36'!
            shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Answer true to allow styling to proceed, or false to veto the styling"

	anSHTextStyler workspace: self.
	^(text = self acceptedContents) not! !

!Inspector methodsFor: 'testing' stamp: 'jmv 8/18/2017 17:42:07'!
                        is: aSymbol
	^ aSymbol == #providesBindings or: [ super is: aSymbol ]! !


SystemWindow subclass: #InspectorWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!

!InspectorWindow methodsFor: 'GUI building' stamp: 'jmv 12/29/2016 11:00:06'!
                         buildMorphicWindow
	" Inspector openOn: SystemOrganization "
	| contentsText list upperRow evaluatorText label |
	"Build widgets. We'll assemble them below."
	list _ PluggableListMorph
			model: model 
			listGetter: #fieldList
			indexGetter: #selectionIndex
			indexSetter: #toggleIndex:
			mainView: self
			menuGetter: #fieldListMenu
			keystrokeAction: #inspectorKey:from:.
	list doubleClickSelector: #inspectSelection.
	contentsText _ TextModelMorph
			textProvider: model
			textGetter: #acceptedContents 
			textSetter: #accept:
			selectionGetter: #contentsSelection.
	evaluatorText _ (TextModelMorph textProvider: model)
			askBeforeDiscardingEdits: false.
	"Upper row has two widgets, side by side: the list of variables at the left side, and the variable contents pane at the right side."
	upperRow _ LayoutMorph newRow.
	upperRow
		addMorph: list proportionalWidth: 0.3;
		addAdjusterAndMorph: contentsText proportionalWidth: 0.7.
	"Inspector Window has two rows: At the top, the one we just bult. Below it, the evaluation pane."
	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.7;
		addAdjusterAndMorph: evaluatorText proportionalHeight: 0.3.
	"Set label"
	label _ [model object printStringLimitedTo: 64]
		on: UnhandledError
		do: [:ex | ex return: model object class printString, ' (printing failed)'].
	(label includesSubString: model object  class name)
		ifFalse: [label _ model object  class name, ': ', label].
	self setLabel: label! !

!InspectorWindow methodsFor: 'GUI building' stamp: 'jmv 6/19/2017 16:01:32'!
                     initialExtent

	^`600@325`! !


Number subclass: #Integer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Numbers'!

!Integer methodsFor: 'arithmetic' stamp: 'len 12/4/2016 13:11:44'!
                            reciprocalModulo2: n
	"Answer an integer x such that self * x \\ n = 1, with 0 < x < n, or nil if it doesn't exist."
	| xgcd |
	self == 0 ifTrue: [^ nil].
	self == 1 ifTrue: [^ 1].
	xgcd _ self xgcd: n.
	^ (xgcd at: 1) == 1 ifTrue: [^ (xgcd at: 2) \\ n]! !

!Integer methodsFor: 'arithmetic' stamp: 'len 12/4/2016 13:07:08'!
                           xgcd: anInteger
	"Extended Euclidean algorithm.
	Answer an array {x. u. v} where self * u + (anInteger * v) = x, and x = (self gcd: anInteger)."
	| a b s t sp tp r rp |
	a _ self. b _ anInteger.
	s _ 0. sp _ 1.
	t _ 1. tp _ 0.
	r _ a abs. rp _ b abs.
	[r == 0]
		whileFalse:
			[ | q temp |
			q _ rp // r.
			temp _ r. r _ rp - (q * r). rp _ temp.
			temp _ s. s _ sp - (q * s). sp _ temp.
			temp _ t. t _ tp - (q * t). tp _ temp].
	sp _ sp * b sign. tp _ tp * a sign.
	^ {rp. tp. sp}! !

!Integer methodsFor: 'benchmarks' stamp: 'jmv 9/19/2017 21:59:09'!
                  tinyBenchmarks
	"Report the results of running the two tiny Squeak benchmarks.
	ar 9/10/1999: Adjusted to run at least 1 sec to get more stable results
	0 tinyBenchmarks
		292 MHz G3 Mac: 				        			 22,727,272 bytecodes/sec; 			    984,169 sends/sec
		400 MHz PII/Win98:  			        			 18,028,169 bytecodes/sec; 			1,081,272 sends/sec

		RasPi2 - StackVM: 								 37,758,112 bytecodes/sec; 		       2,412,667 sends/sec
		RasPi2- CogSSpur: 							     157,441,574 bytecodes/sec; 		     10,946,039 sends/sec
		
		C.H.I.P. (*1) - StackVM: 							55,315,471 bytecodes/sec;  			3,348,667 sends/sec
		C.H.I.P. (*1) - CogSpur: 					 	    253,716,551 bytecodes/sec; 		    16,853,816 sends/sec
		
		RasPi3B - StackSpur 								44,107,512 bytecodes/sec; 			2,767,863 sends/sec
		RasPi3B - CogSpur 							    281,783,159 bytecodes/sec; 		    16,404,381 sends/sec

		1.66GHz Atom N450 - Cog: 					     244,274,809 bytecodes/sec; 		    28,795,277 sends/sec
		1.66GHz Atom N450 - CogSpur: 			     469,724,770 bytecodes/sec; 		    30,754,699 sends/sec

		1.33GHz Atom 3735G - Cog: 				     326,114,649 bytecodes/sec; 		    34,985,976 sends/sec
		1.33GHz Atom 3735G - CogSpur: 			     632,098,765 bytecodes/sec; 		    33,692,910 sends/sec

		1.5GHz AMD A4-5000 APU - Cog: 			    390,243,902 bytecodes/sec; 		    47,507,997 sends/sec
		1.5GHz AMD A4-5000 APU - CogSpur: 		    675,907,590 bytecodes/sec; 		    40,669,724 sends/sec
		1.5GHz AMD A4-5000 APU - CogSpur64:	    659,368,963 bytecodes/sec; 		    50,338,916 sends/sec

		2.3GHz Tegra (*2) - StackVM: 				    258,847,320 bytecodes/sec; 		    13,014,759 sends/sec	
		2.3GHz Tegra (*2) - CogSpur: 				1,083,024,854 bytecodes/sec; 		    64,289,750 sends/sec

		3.1GHz Core i3-2100 - Cog:  				1,203,290,246 bytecodes/sec; 		165,723,327 sends/sec
		3.1GHz Core i3-2100 - CogSpur:  			2,042,892,768 bytecodes/sec; 		127,837,794 sends/sec

		2.70GHz Core i5-6400 -CogSpur64 		3,162,934,362 bytecodes/sec; 		243,321,293 sends/sec
	
		(*1) C.H.I.P. $9 Computer [Next Thing Co], Allwinner R8 Single-Core ARM Cortex-A8 - 1 GHz
		(*2) ACER Chromebook CB5-311 - NVIDIA Tegra K1 Quad-Core ARM Cortex-A15 'r3'  - 2.3 GHz
		
	It is interesting to note that Spur for the first time brings ARM hardware (RasPi and C.H.I.P.) into a 'Morphic is confortable and nice to use' level of performance.
	"
	| t1 t2 r n1 n2 |
	n1 _ 1.
	[
		t1 _ Time millisecondsToRun: [n1 benchmark].
		t1 < 1000] 
			whileTrue: [n1 _ n1 * 2]. "Note: #benchmark's runtime is about O(n)"

	n2 _ 28.
	[
		t2 _ Time millisecondsToRun: [r _ n2 benchFib].
		t2 < 1000] 
			whileTrue: [n2 _ n2 + 1]. 
	"Note: #benchFib's runtime is about O(k^n),
		where k is the golden number = (1 + 5 sqrt) / 2 = 1.618...."

	^String streamContents: [ :strm |
		(n1 * 500000 * 1000) // t1 withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
			value printOn: strm fractionDigits: 2.
			strm
				space;
				nextPutAll: unitPrefixName;
				nextPutAll: 'Bytecodes/second; ' ].
		(r * 1000) // t2 withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
			value printOn: strm fractionDigits: 2.
			strm
				space;
				nextPutAll: unitPrefixName;
				nextPutAll: 'Sends/second' ]]! !

!Integer methodsFor: 'comparing' stamp: 'len 12/5/2016 09:46:00'!
                     hash
	"Hash is reimplemented because = is implemented.
	| s |
	s _ (1 to: 10000) asSet.
	[s includes: 123456] bench
	"

	^self hashMultiply! !

!Integer methodsFor: 'converting' stamp: 'ar 10/31/1998 23:04'!
                asColorOfDepth: d
	"Return a color value representing the receiver as color of the given depth"
	^Color colorFromPixelValue: self depth: d! !

!Integer methodsFor: 'mathematical functions' stamp: 'nice 1/16/2013 18:38'!
    raisedTo: n modulo: m
	"Answer the modular exponential.
	Note: this implementation is optimized for case of large integers raised to large powers."
	| a s mInv |
	n = 0 ifTrue: [^1].
	(self >= m or: [self < 0]) ifTrue: [^self \\ m raisedTo: n modulo: m].
	n < 0 ifTrue: [^(self reciprocalModulo: m) raisedTo: n negated modulo: m].
	(n < 4096 or: [m even])
		ifTrue:
			["Overhead of Montgomery method might cost more than naive divisions, use naive"
			^self slidingLeftRightRaisedTo: n modulo: m].
	
	mInv := self montgomeryDigitBase - ((m bitAnd: self montgomeryDigitMax) reciprocalModulo: self montgomeryDigitBase).
 
	"Initialize the result to R=self montgomeryDigitModulo raisedTo: m montgomeryNumberOfDigits"
	a := (1 bitShift: m montgomeryNumberOfDigits * m montgomeryDigitLength) \\ m.
	
	"Montgomerize self (multiply by R)"
	(s := self montgomeryTimes: (a*a \\ m) modulo: m mInvModB: mInv)
		ifNil:
			["No Montgomery primitive available ? fallback to naive divisions"
			^self slidingLeftRightRaisedTo: n modulo: m].

	"Exponentiate self*R"
	a := s montgomeryRaisedTo: n times: a modulo: m mInvModB: mInv.

	"Demontgomerize the result (divide by R)"
	^a montgomeryTimes: 1 modulo: m mInvModB: mInv! !

!Integer methodsFor: 'mathematical functions' stamp: 'jmv 8/17/2017 21:37:42'!
                     raisedToFraction: aFraction
	| root |
	root _ self nthRootTruncated: aFraction denominator.
	(root raisedToInteger: aFraction denominator) = self ifTrue: [
		^ root raisedToInteger: aFraction numerator ].
	^ super raisedToFraction: aFraction! !

!Integer methodsFor: 'printing' stamp: 'jmv 5/9/2017 19:45:38'!
          printOn: aStream length: minimum zeroPadded: zeroFlag
	"
	7 printOn: Transcript length: 4 padded: true. Transcript newLine.
	"
	self printOn: aStream base: 10 length: minimum padded: zeroFlag! !

!Integer methodsFor: 'printing' stamp: 'jmv 9/19/2017 21:42:27'!
                           printStringAsBytes
	"Answer a terse, easily-readable representation of this Integer reprsenting a number of bytes.  Useful for file-browsers.
	123 printStringAsBytes
	1024 printStringAsBytes
	(12*1024) printStringAsBytes
	(1024*1024) printStringAsBytes
	(1024*1024*1024) printStringAsBytes
	(1024*1024*1024*1024) printStringAsBytes
	(30 factorial) printStringAsBytes
	
	See https://en.wikipedia.org/wiki/Kibibyte
	See #printStringAsBytesDecimal
	"
	self withBinaryUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
		^String streamContents: [ :strm |
			value printOn: strm fractionDigits: 2.
			strm
				space;
				nextPutAll: unitPrefixSymbol;
				nextPut: $B]]! !

!Integer methodsFor: 'printing' stamp: 'jmv 9/19/2017 21:48:23'!
                    printStringAsBytesDecimal
	"Answer a terse, easily-readable representation of this Integer reprsenting a number of bytes.  Useful for file-browsers.
	123 printStringAsBytesDecimal
	(12*1000) printStringAsBytesDecimal
	(1000*1000) printStringAsBytesDecimal
	
	1024 printStringAsBytesDecimal
	(12*1024) printStringAsBytesDecimal
	(1024*1024) printStringAsBytesDecimal
	(1024*1024*1024) printStringAsBytesDecimal
	(1024*1024*1024*1024) printStringAsBytesDecimal
	(30 factorial) printStringAsBytesDecimal
	
	See https://en.wikipedia.org/wiki/Kibibyte
	See #printStringAsBytes
	"
	self withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
		^String streamContents: [ :strm |
			value printOn: strm fractionDigits: 2.
			strm
				space;
				nextPutAll: unitPrefixSymbol;
				nextPut: $B]]! !

!Integer methodsFor: 'testing' stamp: 'nice 11/14/2011 21:59'!
                      isProbablyPrime
	"See isProbablyPrimeWithK:andQ: for the algoritm description."
	
	| k q |
	self <= 1 ifTrue: [ ^false ].
	self even ifTrue: [ ^self = 2 ].
	"Factor self into (2 raisedTo: k) * q + 1, where q odd"
	q := self bitShift: -1.
	k := q lowBit.
	q := q bitShift: 1 - k.
	"Repeat the probabilistic until false (the probability of false negative is null) or until probability is very low."
	25 timesRepeat: [ (self isProbablyPrimeWithK: k andQ: q) ifFalse: [ ^false ] ].
	"The probability of false positive after 25 iterations is less than (1/4 raisedTo: 25) < 1.0e-15"
	^true! !

!Integer methodsFor: 'private' stamp: 'nice 11/15/2011 23:13'!
                     isProbablyPrimeWithK: k andQ: q 
	"Algorithm P, probabilistic primality test, from
	Knuth, Donald E. 'The Art of Computer Programming', Vol 2,
	Third Edition, section 4.5.4, page 395, P1-P5 refer to Knuth description..
	Note that this is a Miller Rabin test which may answer false positives (known as pseudoprimes) for at most 1/4 of the possible bases x."

	| x j y minusOne |
	"P1"
	x := (self - 2) atRandom + 1.
	"P2"
	j := 0.
	y := x raisedTo: q modulo: self.
	minusOne := self - 1.
	
	["P3"
	y = 1 ifTrue: [^j = 0].
	y = minusOne ifTrue: [^true].
	"P4"
	(j := j + 1) < k]
		whileTrue:
			[y := y squared \\ self].
	"P5"
	^false! !

!Integer methodsFor: 'private' stamp: 'nice 1/19/2013 03:13'!
     montgomeryDigitBase
	"Answer the base used by Montgomery algorithm."
	^1 << self montgomeryDigitLength! !

!Integer methodsFor: 'private' stamp: 'nice 1/19/2013 03:27'!
                       montgomeryDigitLength
	"Answer the number of bits composing a digit in Montgomery algorithm.
	Primitive use either 8 or 32 bits digits"
	<primitive: 'primMontgomeryDigitLength' module:'LargeIntegers'>
	^8 "Legacy plugin which did not have this primitive did use 8 bits digits"! !

!Integer methodsFor: 'private' stamp: 'nice 1/19/2013 03:14'!
         montgomeryDigitMax
	"Answer the maximum value of a digit used in Montgomery algorithm."
	
	^1 << self montgomeryDigitLength - 1! !

!Integer methodsFor: 'private' stamp: 'nice 1/19/2013 03:16'!
                              montgomeryNumberOfDigits
	"Answer the number of montgomery digits required to represent the receiver."
	^self digitLength * 8 + (self montgomeryDigitLength - 1) // self montgomeryDigitLength! !

!Integer methodsFor: 'private' stamp: 'nice 1/16/2013 18:40'!
                               montgomeryTimes: a modulo: m mInvModB: mInv
	"Answer the result of a Montgomery multiplication
	self * a * (b raisedTo: m montgomeryNumberOfDigits) inv \\ m
	NOTE: it is assumed that:
	self montgomeryNumberOfDigits <= m montgomeryNumberOfDigits
	a montgomeryNumberOfDigits <= m montgomeryNumberOfDigits
	mInv * m \\ b = (-1 \\ b) = (b-1) (this implies m odd)
	where b = self montgomeryDigitBase
	
	Answer nil in case of absent plugin or other failure."
	
	<primitive: 'primMontgomeryTimesModulo' module:'LargeIntegers'>
	^nil! !


Integer class
	instanceVariableNames: ''!

!Integer class methodsFor: 'instance creation' stamp: 'jmv 11/16/2016 15:37:15'!
                 readFrom: aStream base: base
	"Answer an instance of one of my concrete subclasses. Initial minus sign
	accepted, and bases > 10 use letters A-Z. Embedded radix specifiers not
	allowed--use Number readFrom: for that. Answer zero (not an error) if
	there are no digits."

	| digit value neg cc atLeastOneDigitRead |
	neg _ aStream peekFor: $-.
	neg ifFalse: [aStream peekFor: $+].
	value _ 0.
	atLeastOneDigitRead _ false.
	[ aStream atEnd ]
		whileFalse: [
			cc _ aStream next.
			digit _ cc digitValue.
			(digit < 0 or: [digit >= base])
				ifTrue: [
					aStream skip: -1.
					atLeastOneDigitRead ifFalse: [self error: 'At least one digit expected here'].
					^neg
						ifTrue: [value negated]
						ifFalse: [value]].
			value _ value * base + digit.
			atLeastOneDigitRead _ true ].
	neg ifTrue: [^ value negated].
	^ value! !

!Integer class methodsFor: 'prime numbers' stamp: 'jmv 7/17/2017 15:44:55'!
               verbosePrimesUpTo: max do: aBlock
	"Integer verbosePrimesUpTo: SmallInteger maxVal" "<- heh, heh"
	"Compute primes up to max, but be verbose about it"
	| lastTime |
	lastTime := Time localMillisecondClock.
	Utilities informUserDuring: [ :barBlock|
		barBlock value:'Computing primes...'.
		self primesUpTo: max do: [ :prime| | nowTime |
			aBlock value: prime.
			nowTime := Time localMillisecondClock.
			(nowTime - lastTime > 1000) ifTrue:[
				lastTime := nowTime.
				barBlock value: 'Last prime found: ', prime printString]]].! !


Interval class
	instanceVariableNames: ''!

!Interval class methodsFor: 'instance creation' stamp: 'jmv 7/9/2017 16:59:23'!
           newFrom: aCollection 
	"Answer an instance of me containing the same elements as aCollection."

    | newInterval n |

    (n := aCollection size) <= 1 ifTrue: [
		n = 0 ifTrue: [^self from: 1 to: 0].
		^self from: aCollection first to: aCollection last].
    	newInterval := self from: aCollection first to: aCollection last by: (aCollection last - aCollection first) // (n - 1).
	(newInterval hasEqualElements: aCollection)
		ifFalse: [ self error: 'The argument is not an arithmetic progression' ].
	^newInterval

"
	Interval newFrom: {1. 2. 3}
	{33. 5. -23} as: Interval
	{33. 5. -22} as: Interval.   ' (an error)'
	(-4 to: -12 by: -1) as: Interval
"! !


Integer variableByteSubclass: #LargePositiveInteger
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Numbers'!

!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'jmv 1/13/2017 09:39:07'!
                           bitXor: arg
	"Primitive 36 deals with only 64-bit values (up to 8 byte LargeIntegers).
	The inherited <primitive: 'primDigitBitXor' module:'LargeIntegers'> deals with 
	arbitrary sized large integers, but is much slower.
	This method gives a performance improvement for integers using 32 to 64 bits on 32 bit VMs,
	but only for 62 to 64 bits on 64 bits VMs.
	See http://forum.world.st/Integer-arithmetic-and-bit-operations-in-Squeak-and-Pharo-32bit-amp-64bit-tc4928994.html#none
	"

    <primitive:36>
    ^super bitXor: arg! !

!LargePositiveInteger methodsFor: 'system primitives' stamp: 'jmv 1/13/2017 09:58:53'!
                        replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !

!LargePositiveInteger methodsFor: 'testing' stamp: 'nice 8/31/2008 00:07'!
                       isLarge
	^true! !


RectangleLikeMorph subclass: #LayoutAdjustingMorph
	instanceVariableNames: 'hand'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!LayoutAdjustingMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:53:34'!
drawOn: aCanvas

	aCanvas
		fillRectangle: (`0@0` extent: extent)
		color: color! !


RectangleLikeMorph subclass: #LayoutMorph
	instanceVariableNames: 'direction separation padding cachedMinExtent doAdoptWidgetsColor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 12/1/2015 09:53'!
                     adoptWidgetsColor: paneColor
	super adoptWidgetsColor: paneColor.
	doAdoptWidgetsColor
		ifTrue: [ self color: (Theme current buttonColorFrom: paneColor) ]
		ifFalse: [ self color: Color transparent ]! !

!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 8/17/2014 21:38'!
           defaultColor
	^Color gray! !

!LayoutMorph methodsFor: 'layout' stamp: 'jmv 6/19/2017 15:53:38'!
                               layoutBounds
	"Return the bounds for laying out children of the receiver"

	^`0@0` extent: extent! !

!LayoutMorph methodsFor: 'layout' stamp: 'jmv 6/19/2017 16:05:36'!
                       layoutSubmorphsHorizontallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."
	| xSep ySep usableWidth sumOfFixed normalizationFactor availableForPropWidth 
		fractionalWidths integerWidths theLeft usableHeight boundsTop boundsRight theTop minWidth submorphsToLayout 
			nextMorph ht wd ls theRight boundsBottom theBottom alternativeWidths count diff i |
	
	boundsForLayout extent > `2@2` "self minimumExtent" 
		ifFalse: [ ^self ]. "Too small. Don't bother!!"

	submorphsToLayout := self submorphsToLayout.
	xSep := self xSeparation.
	ySep := self ySeparation.
	usableWidth := boundsForLayout width - ((submorphsToLayout size + 1) * xSep).
	sumOfFixed := submorphsToLayout sum: [ :m | m layoutSpec fixedWidth ].
	availableForPropWidth := usableWidth - sumOfFixed max: 0.
	normalizationFactor := self proportionalWidthNormalizationFactor.
	availableForPropWidth := availableForPropWidth * normalizationFactor.
	
	fractionalWidths := submorphsToLayout collect: [ :m | m layoutSpec widthFor: availableForPropWidth ].
	"Compute integer widths, mostly rounding but with occasional #floor or #ceiling as needed to keep sum"
	integerWidths _ fractionalWidths collect: [ :w | w rounded ].
	diff _ integerWidths sum - fractionalWidths sum rounded.
	alternativeWidths _ diff > 0 ifTrue: [ fractionalWidths collect: [ :w | w floor ]] ifFalse: [ fractionalWidths collect: [ :w | w ceiling ]].
	count _ diff abs.
	i _ 1.
	[ count > 0] whileTrue: [
		(integerWidths at: i) = (alternativeWidths at: i) ifFalse: [
			integerWidths at: i put: (alternativeWidths at: i).
			count _ count -1 ].
		i _ i + 1 ].
	minWidth := integerWidths sum.
	theLeft := ((usableWidth - minWidth) * (padding ifNil: [0]) max: 0) + boundsForLayout left + xSep.
	usableHeight := boundsForLayout height - (ySep * 2) max: 0.
	boundsTop    := boundsForLayout top + ySep.
	boundsRight  := boundsForLayout right - xSep.
	boundsBottom := boundsForLayout bottom - ySep.

	submorphsToLayout size to: 1 by: -1 do: [ :index |
		nextMorph := submorphsToLayout at: index.
		"major direction"
		wd := integerWidths at: index.
		"minor direction"
		ls := nextMorph layoutSpec.
		ht := (ls heightFor: usableHeight) min: usableHeight.
		theTop := ((usableHeight - ht) * ls minorDirectionPadding) floor + boundsTop.
		theBottom := (theTop + ht) ceiling min: boundsBottom.
		theRight := (theLeft + (wd min: minWidth)) "ceiling "min: boundsRight.
		"Set bounds and adjust major direction for next step"
		self flag: #jmvVer2.	"should extent be set in m's coordinate system? what if its scale is not 1?"
		ls usesMorphExtent
			ifTrue: [
				nextMorph morphPosition: theLeft floor @ theTop floor ]
			ifFalse: [
				nextMorph morphPosition: theLeft floor @ theTop floor extent: theRight - theLeft @ (theBottom - theTop) ].
		theLeft := theRight + xSep
	]! !

!LayoutMorph methodsFor: 'layout' stamp: 'jmv 6/19/2017 16:05:46'!
                 layoutSubmorphsVerticallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."
	| xSep ySep usableHeight sumOfFixed normalizationFactor availableForPropHeight 
		fractionalHeights integerHeights theTop usableWidth boundsLeft boundsBottom theLeft minHeight submorphsToLayout 
			nextMorph ht wd ls theBottom boundsRight theRight alternativeHeights count diff i |

	boundsForLayout extent > `2@2` "self minimumExtent" 
		ifFalse: [ ^self ]. "Too small. Don't bother!!"

	submorphsToLayout := self submorphsToLayout.
	xSep := self xSeparation.
	ySep := self ySeparation.
	usableHeight := boundsForLayout height - ((submorphsToLayout size + 1) * ySep).
	sumOfFixed := submorphsToLayout sum: [ :m | m layoutSpec fixedHeight ].
	availableForPropHeight := usableHeight - sumOfFixed max: 0.
	normalizationFactor := self proportionalHeightNormalizationFactor.
	availableForPropHeight := availableForPropHeight * normalizationFactor.
	
	fractionalHeights := submorphsToLayout collect: [ :m | m layoutSpec heightFor: availableForPropHeight ].
	"Compute integer widths, mostly rounding but with occasional #floor or #ceiling as needed to keep sum"
	integerHeights _ fractionalHeights collect: [ :w | w rounded ].
	diff _ integerHeights sum - fractionalHeights sum rounded.
	alternativeHeights _ diff > 0 ifTrue: [ fractionalHeights collect: [ :w | w floor ]] ifFalse: [ fractionalHeights collect: [ :w | w ceiling ]].
	count _ diff abs.
	i _ 1.
	[ count > 0] whileTrue: [
		(integerHeights at: i) = (alternativeHeights at: i) ifFalse: [
			integerHeights at: i put: (alternativeHeights at: i).
			count _ count -1 ].
		i _ i + 1 ].
	minHeight := integerHeights sum.
	theTop := ((usableHeight - minHeight) * (padding ifNil: [0]) max: 0) + boundsForLayout top + ySep.
	usableWidth     := boundsForLayout width - (xSep * 2) max: 0.
	boundsLeft      := boundsForLayout left + xSep.
	boundsBottom := boundsForLayout bottom - ySep.
	boundsRight := boundsForLayout right - xSep.
	
	submorphsToLayout size to: 1 by: -1 do: [ :index |
		nextMorph := submorphsToLayout at: index.
		"major direction"
		ht := integerHeights at: index.
		"minor direction"
		ls := nextMorph layoutSpec.
		wd := (ls widthFor: usableWidth) min: usableWidth.
		theLeft := ((usableWidth - wd) * ls minorDirectionPadding) floor + boundsLeft.
		theRight := (theLeft + wd) ceiling min: boundsRight.
		theBottom := (theTop + (ht min: minHeight)) "ceiling" min: boundsBottom.
		"Set bounds and adjust major direction for next step"
		self flag: #jmvVer2.	"should extent be set in m's coordinate system? what if its scale is not 1?"
		ls usesMorphExtent
			ifTrue: [
				nextMorph morphPosition: theLeft floor @ theTop floor ]
			ifFalse: [
				nextMorph morphPosition: theLeft floor @ theTop floor extent: theRight - theLeft @ (theBottom - theTop) ].
		theTop := theBottom + ySep
	]! !


LayoutMorph class
	instanceVariableNames: ''!

!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 4/3/2011 22:59'!
                   initializedInstance
	"Answer a row by default so the 'new morph' menu doesn't fail..."
	^self newRow color: (Color red alpha: 0.2)! !

!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/5/2015 10:57'!
                  example1
"
	self example1
"
| pane row |
pane _ (LayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row _ LayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSpec fixedWidth: 10); 
	addMorph: (BorderedRectMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSpec proportionalWidth: 0.15);
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 60).
pane morphPosition: 150@130 extent: 400@300.
pane openInWorld! !

!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/12/2015 16:42'!
     example10
"
	self example10 openInWorld
"
| pane row |
pane _ (LayoutMorph newColumn separation: 5)	name: #example10.
pane color: Color red.

row _ LayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 60).
^ pane! !

!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/5/2015 10:55'!
                              example11
"
	self example11
"
| pane row |
pane _ (LayoutMorph newColumn separation: 5)	name: #example11.
pane color: Color red.

row _ LayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 60).
pane morphPosition: 150@130 extent: 400@300.
pane openInWorld! !

!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/5/2015 11:08'!
                   example13
	"
	self example13
	"
	| pane row innerRow |
pane _ (LayoutMorph newColumn separation: 5)	name: #example13.
	pane color: Color red.
	row _ (LayoutMorph newRow separation: 5) name: #Row.
	innerRow _ (LayoutMorph newRow separation: 5) name: #InnerRow;
		color: Color red.
	innerRow
		addMorph: (BorderedRectMorph new name: #Box1)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (BorderedRectMorph new name: #Box2)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (BorderedRectMorph new name: #Bar)
		layoutSpec: (LayoutSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 30 				minorDirectionPadding: #center);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSpec fixedWidth: 5); 
		addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 40 				minorDirectionPadding: #top);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSpec fixedWidth: 5); 
		addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSpec proportionalHeight: 0.9).
	pane morphPosition: 250@130 extent: 400@300.
	pane openInWorld! !

!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 2/16/2016 13:27'!
           example1b
"
Based on #example1, but using some Morph instead of RectangleLikeMorph -> extent is not adjustable
	self example1b
"
| pane row |
pane _ (LayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row _ LayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSpec fixedWidth: 10); 
	addMorph: (Morph new name: #B);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSpec proportionalWidth: 0.15);
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (Morph new name: #G);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (Morph new name: #J);
	addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 60).
pane morphPosition: 150@130 extent: 400@300.
pane openInWorld! !

!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/5/2015 11:25'!
         example2
	"
	self example2
	"
	| pane row |
	pane _ (LayoutMorph newColumn separation: 5)	name: #example2.
	pane color: Color red.
	row _ (LayoutMorph newRow separation: 5) name: #Row.
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: (BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #A)
			layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8 minorDirectionPadding: #bottom);
		addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #B)
			layoutSpec: (LayoutSpec proportionalWidth: 0.8 fixedHeight: 40 minorDirectionPadding: #top);
		addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #C)
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 0.7 minorDirectionPadding: #center).
	pane addMorph: row layoutSpec: (LayoutSpec proportionalHeight: 0.9).
	pane morphPosition: 200@180 extent: 400@300.
	pane openInWorld! !

!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 11/18/2015 09:45'!
             example20
"
	self example20
"
| column |

column _ (LayoutMorph newColumn separation: 5) name: #Column.
column
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8 fixedHeight: 20);
	addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSpec fixedWidth: 40 proportionalHeight: 0.5);
	addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSpec proportionalWidth: 1.0 fixedHeight: 30).
column morphPosition: 150@130 extent: 400@300.
column openInWorld! !

!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/5/2015 11:13'!
                      example3
	"
	self example3
	"
	| pane row innerRow |
pane _ (LayoutMorph newColumn separation: 5)	name: #example3.
	pane color: Color red.
	row _ (LayoutMorph newRow separation: 5) name: #Row.
	innerRow _ (LayoutMorph newRow separation: 5) name: #InnerRow;
		color: Color red.
	innerRow
		addMorph: (BorderedRectMorph new name: #Box1)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (BorderedRectMorph new name: #Box2)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (BorderedRectMorph new name: #Bar)
		layoutSpec: (LayoutSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 30 				minorDirectionPadding: #center);
		addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 40 				minorDirectionPadding: #top);
		addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSpec proportionalHeight: 0.9).
	pane morphPosition: 250@130 extent: 400@300.
	pane openInWorld! !

!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/8/2014 20:03'!
           example6
	"
	Useful example contributed by Ken Dickey
	All these should look the same, right? (mmmh this should be a test...)
	self example6
	"
| pane rect1 rect2 |
pane _ LayoutMorph newRow separation: 5. "1"
pane addMorph: (StringMorph contents: '1').

rect1 := BorderedRectMorph new color: (Color lightOrange); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect1.
rect2 := BorderedRectMorph new color: (Color cyan); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect2.
pane
	color: Color lightGreen;
	morphPosition: 120 @ 50 extent: 180 @ 100;
	openInWorld.

pane _ LayoutMorph newRow separation: 5. "2"
pane addMorph: (StringMorph contents: '2').

rect1 := BorderedRectMorph new color: (Color lightOrange);
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane addMorph: rect1.
rect2 := BorderedRectMorph new color: (Color cyan).
pane addMorph: rect2
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane
	color: Color lightGreen;
	morphPosition: 320 @ 50 extent: 180 @ 100;
	openInWorld.


pane _ LayoutMorph newRow separation: 5. "3"
pane addMorph: (StringMorph contents: '3').

rect1 := BorderedRectMorph new color: (Color lightOrange).
pane addMorph: rect1 
         layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
rect2 := BorderedRectMorph new color: (Color cyan);
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane addMorph: rect2.
pane
	color: Color lightGreen;
	morphPosition: 520 @ 50 extent: 180 @ 100;
	openInWorld! !

!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 1/4/2013 13:42'!
                           launcherExample
	"
	self launcherExample
	"
	| b1 b2 b3 row b4 random buttons |
	random _ Random new.
	b1 _ PluggableButtonMorph model: [ Date today print ] action: #value label: 'Date'.
	b2 _ PluggableButtonMorph model: [ Time now print ] action: #value label: 'Time'.
	b3 _ PluggableButtonMorph model: [ SystemVersion current print ] action: #value label: 'Version'.
	b4 _ PluggableButtonMorph model: [ random next print ] action: #value label: 'Random'.
	buttons _ {b1. b2. b3. b4}.
	buttons do: [ :button |
		button color: Color lightRed ].
	row _ LayoutMorph newRow
		 color: Color red;
		 addMorphs: buttons;
		 morphExtent: 300 @ 40.
	^ row openInWorld! !

!LayoutMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:48:35'!
                categoryInNewMorphMenu
	^ 'Layouts'! !


LeafNode subclass: #LiteralNode
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-ParseNodes'!

!LiteralNode methodsFor: 'printing' stamp: 'pb 9/9/2017 03:06:57'!
        printOn: aStream indent: level
	key isVariableBinding
		ifTrue: [
			key key isNil
				ifTrue: [
					aStream
						nextPutAll: '###';
						nextPutAll: key value soleInstance name ]
				ifFalse: [
					aStream
						nextPutAll: '##';
						nextPutAll: key key ]]
		ifFalse: [
			key isLiteral
				ifTrue: [ | isComplex |
					isComplex := false.
					key isArray ifTrue: [
						isComplex := key anySatisfy: [ :ea |
							ea isArray ]].
					"Is it complex? (i.e. array of arrays)"
					isComplex
						ifTrue: [
							aStream
								nextPut: $#;
								nextPut: $(.
							key do: [ :ea |
								aStream newLineTab: (1 max: level + 1).
								ea storeOn: aStream ].
							aStream newLineTab: (1 max: level).
							aStream nextPut: $) ]
						ifFalse: [ key storeOn: aStream ]]
				ifFalse: [
					"Need to generate code for stuff that is in a CompiledMethod literal
					but is not understood as a literal by the Compiler.
					Well, then it is because it was generated using backticks!!"
					aStream nextPut: $`.
					key storeOn: aStream.
					aStream nextPut: $` ]].! !


Magnitude subclass: #LookupKey
	instanceVariableNames: 'key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Support'!

!LookupKey methodsFor: 'bindings' stamp: 'jmv 7/17/2017 15:45:04'!
                 recompileBindingsAnnouncing: aBool
	"Make the receiver (a global read-write binding) be a read-only binding"
	aBool ifTrue:[
		Utilities informUserDuring: [ :barBlock |
			(Smalltalk allCallsOn: self) do: [ :mref | 
				barBlock value: 'Recompiling ', mref stringVersion.
				mref actualClass recompile: mref methodSymbol ].
		].
	] ifFalse:[
		(Smalltalk allCallsOn: self) do: [ :mref |
			mref actualClass recompile: mref methodSymbol ]
	]! !


MenuMorph subclass: #MVCMenuMorph
	instanceVariableNames: 'done mvcSelection'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 3/2/2017 20:08:29'!
   invokeAt: aPoint allowKeyboard: aBoolean
	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."
	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 
	|actHand w oldFocus |
	self flag: #bob.		"is <aPoint> global or local?"
	self flag: #arNote.	"<aPoint> is local to aWorld"
	w _ self runningWorld.
	actHand _ w activeHand.
	oldFocus _ actHand keyboardFocus.
	w doOneMinimalCycleNow.
	self
		popUpAt: aPoint
		forHand: actHand
		allowKeyboard: aBoolean.
	done _ false.
	[ self isInWorld & done not ] whileTrue: [ w doOneMinimalCycleNow ].
	self delete.
	oldFocus ifNotNil: [ actHand newKeyboardFocus: oldFocus ].
	^ mvcSelection ! !


StringMorph subclass: #MenuItemMorph
	instanceVariableNames: 'isEnabled subMenu isSelected target selector arguments icon'
	classVariableNames: 'SubMenuMarker'
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 6/19/2017 16:06:04'!
                  contents: aString withMarkers: aBool inverse: inverse 
	"Set the menu item entry. If aBool is true, parse aString for embedded markers."

	| markerIndex marker |
	self contentString: nil.	"get rid of old"
	aBool ifFalse: [^super contents: aString].
	self removeAllMorphs.	"get rid of old markers if updating"
	self hasIcon ifTrue: [ self icon: nil ].
	(aString notEmpty and: [aString first = $<]) 
		ifFalse: [^super contents: aString].
	markerIndex := aString indexOf: $>.
	markerIndex = 0 ifTrue: [^super contents: aString].
	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.
	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 
		ifFalse: [^super contents: aString].
	self contentString: aString.	"remember actual string"
	marker := (marker = '<on>' or: [marker = '<yes>']) ~= inverse 
				ifTrue: [self onImage]
				ifFalse: [self offImage].
	super contents:  (aString copyFrom: markerIndex + 1 to: aString size).
	"And set the marker"
	marker := ImageMorph new image: marker.
	self addMorphFront: marker position: `0@2`! !

!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 3/13/2009 10:04'!
          isEnabled: aBoolean

	isEnabled = aBoolean ifTrue: [^ self].
	isEnabled _ aBoolean.
	self color: (aBoolean ifTrue: [Color black] ifFalse: [Color gray]).
! !

!MenuItemMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:53:42'!
                            drawOn: aCanvas 
	| stringColor leftEdge |

	stringColor _ color.
	isSelected & isEnabled
		ifTrue: [
			aCanvas fillRectangle: (`0@0` extent: extent) color: Theme current menuHighlight].
	leftEdge _ 0.

	self hasMarker ifTrue: [
		leftEdge _ leftEdge + submorphs first morphWidth + 8 ].

	self hasIcon
		ifTrue: [| iconForm | 
			iconForm _ isEnabled ifTrue: [ self icon ] ifFalse: [ self icon asGrayScaleAndTransparent ].
			aCanvas image: iconForm at: leftEdge+1 @ (extent y - iconForm height // 2).
			leftEdge _ leftEdge + iconForm width + self iconSeparation].

	aCanvas
		drawString: contents
		at: leftEdge @ 1
		font: self fontToUse
		color: stringColor.
	subMenu ifNotNil: [
		aCanvas
			image: self class subMenuMarker
			at: extent x - 8 @ (extent y - self class subMenuMarker height // 2) ]! !

!MenuItemMorph methodsFor: 'events' stamp: 'jmv 9/20/2012 00:14'!
                      activateOwnerMenu: evt
	"Activate our owner menu; e.g., pass control to it"
	owner ifNil: [ ^false ]. "not applicable"
	(owner morphContainsPoint: (owner internalizeFromWorld: evt eventPosition))
		ifFalse: [ ^false ].
	owner activate: evt.
	^true! !

!MenuItemMorph methodsFor: 'events' stamp: 'jmv 3/2/2017 10:45:33'!
mouseEnter: evt
	"The mouse entered the receiver"
	owner ifNil: [ ^self ].
	owner selectItem: self! !

!MenuItemMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:06:09'!
            initialize
	"initialize the state of the receiver"
	super initialize.
	""
	extent _ `10@10`.
	contents _ ''.
	isEnabled _ true.
	subMenu _ nil.
	isSelected _ false.
	target _ nil.
	selector _ nil.
	arguments _ nil.
	font _ Preferences standardMenuFont! !

!MenuItemMorph methodsFor: 'layout' stamp: 'jmv 6/19/2017 16:06:26'!
                           measureContents
	| e |
	e _ super measureContents.
	^e y > 12
		ifTrue: [e+`2@2`]
		ifFalse: [e+`2@1`]! !

!MenuItemMorph methodsFor: 'selecting' stamp: 'jmv 1/29/2014 23:46'!
                deselect

	self isSelected: false.
	subMenu ifNotNil: [
		owner ifNotNil:[ owner activeSubmenu: nil ].
		self removeAlarm: #deselectTimeOut ]! !

!MenuItemMorph methodsFor: 'selecting' stamp: 'jmv 6/19/2017 15:53:59'!
      select
	self isSelected: true.
	owner activeSubmenu: subMenu.
	subMenu ifNotNil: [
		subMenu delete.
		subMenu
			popUpAdjacentTo: (Array with: self morphBoundsInWorld topRight + `10@0`
											with: self morphBoundsInWorld topLeft)
			from: self.
		subMenu selectItem: nil ]! !

!MenuItemMorph methodsFor: 'private' stamp: 'jmv 9/9/2012 23:55'!
   offImage
	"Return the form to be used for indicating an '<off>' marker"
	| form |
	form _ Form extent: (self fontToUse ascent-2) asPoint depth: 16.
	form getCanvas
		frameAndFillRectangle: form boundingBox fillColor: (Color gray: 0.9) 
			borderWidth: 1 borderColor: Color black.
	^form! !

!MenuItemMorph methodsFor: 'private' stamp: 'jmv 9/9/2012 23:55'!
                           onImage
	"Return the form to be used for indicating an '<off>' marker"
	| form |
	form _ Form extent: (self fontToUse ascent-2) asPoint depth: 16.
	form getCanvas
		frameAndFillRectangle: form boundingBox fillColor: (Color gray: 0.8) 
			borderWidth: 1 borderColor: Color black;
		fillRectangle: (form boundingBox insetBy: 2) color: Color black.
	^form! !


MenuItemMorph class
	instanceVariableNames: ''!

!MenuItemMorph class methodsFor: 'cached state access' stamp: 'jmv 6/19/2017 16:06:33'!
                 subMenuMarker

	| f |
	SubMenuMarker ifNotNil: [ ^SubMenuMarker ].
	f _ Form
		extent: `5@9`
		fromArray: #(2147483648 3221225472 3758096384 4026531840 4160749568 4026531840 3758096384 3221225472 2147483648)
		offset: `0@0`.
	SubMenuMarker _ ColorForm mappingWhiteToTransparentFrom: f.
	^SubMenuMarker! !


RectangleLikeMorph subclass: #MenuLineMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!MenuLineMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:54:11'!
                     drawOn: aCanvas 
	| baseColor |
	baseColor _ owner color.
	aCanvas
		fillRectangle: (`0@0` corner: extent x @ (extent y / 2))
		color: baseColor twiceDarker.
			
	aCanvas
		fillRectangle: (0 @ (extent y / 2) corner: extent)
		color: baseColor twiceLighter! !

!MenuLineMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:06:38'!
               initialize
	super initialize.
	extent _ `50 @ 2`! !

!MenuLineMorph methodsFor: 'geometry' stamp: 'jmv 6/19/2017 16:07:43'!
    minimumExtent

	^`10@2`! !


BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp titleMorph activeSubMenu popUpOwner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!MenuMorph methodsFor: 'construction' stamp: 'len 11/16/2015 02:52'!
            addStayUpIcons
	| closeBox pinBox w |
	Preferences optionalButtons ifFalse: [ ^self ].
	(self valueOfProperty: #hasStayUpIcons ifAbsent: [ false ])
		ifTrue: [
		 	self removeProperty: #needsStayUpIcons.
			^self ].
	titleMorph ifNil: [
		"Title not yet there. Flag ourself, so this method is called again when adding title."
		self setProperty: #needsStayUpIcons toValue: true.
		^ self].
	closeBox _ PluggableButtonMorph model: self action: #delete.
	closeBox icon: Theme current closeIcon; color: Color transparent.
	pinBox _ PluggableButtonMorph model: self action: #stayUp.
	pinBox icon: Theme current pushPinIcon; color: Color transparent.
	w _ (titleMorph hasSubmorphs ifTrue: [ titleMorph firstSubmorph morphWidth ] ifFalse: [ 0 ]) + 60.
	self addMorphFront: 
		(LayoutMorph newRow
			"Make room for buttons"
			morphExtent: w @ (titleMorph morphHeight max: 19);
			color: Color transparent;
			addMorph: closeBox fixedWidth: 20;
			addMorph: (RectangleLikeMorph new color: Color transparent) fixedWidth: 4;
			addMorph: titleMorph proportionalWidth: 1;
			addMorph: (RectangleLikeMorph new color: Color transparent) fixedWidth: 4;
			addMorph: pinBox fixedWidth: 20).

	self setProperty: #hasStayUpIcons toValue: true.
	self removeProperty: #needsStayUpIcons! !

!MenuMorph methodsFor: 'construction' stamp: 'jmv 6/19/2017 16:07:49'!
 addTitle: aString
	"Add a title line at the top of this menu Make aString its initial 
	contents.  
	If aSelector is not nil, then periodically obtain fresh values for its 
	contents by sending aSelector to aTarget.."

	| s pp w |
	
	titleMorph _ RectangleLikeMorph new.
	titleMorph color: Theme current menuTitleBar.
	pp _ `8@2`.
	aString asString linesDo: [ :line |
		s _ StringMorph new
			contents: line;
			font: Preferences standardMenuFont bold.
		titleMorph addMorphBack: s position: pp.
		pp _ pp + (0@(s morphHeight+2)) ].
	w _ titleMorph submorphs inject: 0 into: [ :prev :each |
		prev max: each morphWidth ].
	titleMorph morphExtent: (w + 16) @ (pp y).
	self addMorphFront: titleMorph.
	
	(self hasProperty: #needsStayUpIcons) ifTrue: [ self addStayUpIcons ]! !

!MenuMorph methodsFor: 'control' stamp: 'ar 9/17/2000 20:38'!
                          activeSubmenu: aSubmenu
	activeSubMenu ifNotNil:[activeSubMenu delete].
	activeSubMenu _ aSubmenu.! !

!MenuMorph methodsFor: 'control' stamp: 'jmv 3/7/2017 14:37:43'!
                        deleteIfPopUp: evt
	"Remove this menu from the screen if stayUp is not true. If it is a submenu, also remove its owning menu."

	stayUp ifFalse: [ self delete ].
	popUpOwner ifNotNil: [
		popUpOwner isSelected: false.
		popUpOwner deleteIfPopUp: evt ].
	evt ifNotNil: [ evt hand ifNotNil: [ :h | h releaseMouseFocus: self ]]! !

!MenuMorph methodsFor: 'control' stamp: 'jmv 6/19/2017 16:37:20'!
                     popUpAdjacentTo: rightOrLeftPointInWorld from: sourceItem
	"Present this menu at the given point under control of the given hand.
	Used mostly for submenus."

	| delta tryToPlace selectedOffset |
	popUpOwner _ sourceItem.
	selectedOffset _ (selectedItem ifNil: [ self items first ]) morphPosition.
	sourceItem world addMorphFront: self.

	tryToPlace _ [ :where :mustFit |
		self morphPosition: where - selectedOffset.
		delta _ self morphFullBoundsInWorld
			amountToTranslateWithin: sourceItem world morphBoundsInWorld.
		(delta x = 0 | mustFit) ifTrue: [
			delta = `0@0` ifFalse: [ self morphPosition: self morphPosition + delta ].
			^ self]].
	tryToPlace 
		value: rightOrLeftPointInWorld first value: false;
		value: rightOrLeftPointInWorld last - (extent x @ 0) value: false;
		value: rightOrLeftPointInWorld first value: true! !

!MenuMorph methodsFor: 'control' stamp: 'jmv 6/19/2017 16:08:25'!
                        popUpAt: aPoint forHand: hand allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	| evt |
	self items isEmpty ifTrue: [^self].
	Theme current decorateMenu: self.
	(self submorphs select: [ :m | m is: #UpdatingMenuItemMorph ]) 
		do: [ :m | m updateContents].
	self runningWorld addMorphFront: self position: aPoint - `2 @ 8`.
	self fitInWorld.
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [ hand newKeyboardFocus: self ].
	evt _ hand lastMouseEvent.
	(evt isKeyboard or: [ evt isMouse and: [ evt anyButtonPressed not ]]) 
		ifTrue: [
			"Select first item if button not down"
			self moveSelectionDown: 1 event: evt ]! !

!MenuMorph methodsFor: 'control' stamp: 'jmv 6/19/2017 16:08:29'!
                     popUpAt: aPoint forHand: hand in: aWorld allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	self items isEmpty ifTrue: [ ^self ].
	Theme current decorateMenu: self.
	(self submorphs select: [ :m | m is: #UpdatingMenuItemMorph]) 
		do: [ :m | m updateContents].
	aWorld addMorphFront: self position: aPoint - `2 @ 8`.
	self fitInWorld.
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [ hand newKeyboardFocus: self ]! !

!MenuMorph methodsFor: 'control' stamp: 'jmv 1/22/2017 21:31:40'!
  popUpInWorld: aWorld
	"Present this menu under control of the given hand."
	"Needed if not the real world but an inner PasteUpMorph"
	| positionInWorld |
	positionInWorld _ aWorld internalizeFromWorld: aWorld activeHand morphPosition.
	^self
		popUpAt: positionInWorld
		forHand: aWorld activeHand
		in: aWorld
! !

!MenuMorph methodsFor: 'events' stamp: 'jmv 3/2/2017 10:47:45'!
    keyStroke: aKeyboardEvent 
	| matchString char asc selectable |
	char := aKeyboardEvent keyCharacter.
	asc := char numericValue.
	aKeyboardEvent isReturnKey
		ifTrue: [
			selectedItem ifNotNil: [
					selectedItem hasSubMenu 
						ifTrue: [
							aKeyboardEvent hand newMouseFocus: selectedItem subMenu.
							^aKeyboardEvent hand newKeyboardFocus: selectedItem subMenu]
						ifFalse: [
							"self delete."
							^selectedItem invokeWithEvent: aKeyboardEvent]].
			(selectable := self items) size = 1 
				ifTrue: [^selectable first invokeWithEvent: aKeyboardEvent].
			^self].
	asc = 27 
		ifTrue: [
			"escape key"
			self
				valueOfProperty: #matchString
				ifPresentDo: [ :str | 
					str isEmpty 
						ifFalse: [
							"If filtered, first ESC removes filter"
							self setProperty: #matchString toValue: String new.
							self selectItem: nil.
							^self displayFiltered: aKeyboardEvent]].
			"If a stand-alone menu, just delete it"
			^self delete].
	(asc = 28 or: [asc = 29]) 
		ifTrue: [
			"left or right arrow key"
			(selectedItem notNil and: [selectedItem hasSubMenu]) 
				ifTrue: [
					aKeyboardEvent hand newMouseFocus: selectedItem subMenu.
					selectedItem subMenu moveSelectionDown: 1 event: aKeyboardEvent.
					^aKeyboardEvent hand newKeyboardFocus: selectedItem subMenu]].
	asc = 30 ifTrue: [^self moveSelectionDown: -1 event: aKeyboardEvent].	"up arrow key"
	asc = 31 ifTrue: [^self moveSelectionDown: 1 event: aKeyboardEvent].	"down arrow key"
	asc = 11 ifTrue: [^self moveSelectionDown: -5 event: aKeyboardEvent].	"page up key"
	asc = 12 ifTrue: [^self moveSelectionDown: 5 event: aKeyboardEvent].	"page down key"
	matchString := self valueOfProperty: #matchString ifAbsent: [String new].
	matchString := char = Character backspace 
				ifTrue: [
					matchString isEmpty ifTrue: [matchString] ifFalse: [matchString allButLast]]
				ifFalse: [matchString copyWith: aKeyboardEvent keyCharacter].
	self setProperty: #matchString toValue: matchString.
	self displayFiltered: aKeyboardEvent! !

!MenuMorph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 17:50'!
     handleFocusEvent: aMorphicEvent
	"Handle focus events. Valid menu transitions are determined based on the menu currently holding the focus after the mouse went down on one of its children."
	| eventPositionInOurCoordinates |
	eventPositionInOurCoordinates _ self internalizeFromWorld: aMorphicEvent eventPosition.

	self dispatchEvent: aMorphicEvent localPosition: eventPositionInOurCoordinates.

	"Need to handle keyboard input if we have the focus."
	aMorphicEvent isKeyboard ifTrue: [ ^ aMorphicEvent sentTo: self localPosition: eventPositionInOurCoordinates].

	"We need to handle button clicks outside and transitions to local popUps so throw away everything else"
	(aMorphicEvent isMouseOver or: [aMorphicEvent isMouse not]) ifTrue: [ ^self ].
	"What remains are mouse buttons and moves"
	aMorphicEvent isMove ifFalse: [ ^ aMorphicEvent sentTo: self localPosition: eventPositionInOurCoordinates ]. "handle clicks outside by regular means"
	"Now it's getting tricky. On #mouseMove we might transfer control to *either* the currently active submenu or the pop up owner, if any. Since the active sub menu is always displayed upfront check it first."
	selectedItem ifNotNil:[(selectedItem activateSubmenu: aMorphicEvent) ifTrue: [^self]].
	"Note: The following does not traverse upwards but it's the best I can do for now"
	popUpOwner ifNotNil:[(popUpOwner activateOwnerMenu: aMorphicEvent) ifTrue: [^self]].! !

!MenuMorph methodsFor: 'initialization' stamp: 'ar 10/10/2000 01:57'!
                   delete
	activeSubMenu ifNotNil:[activeSubMenu delete].
	^super delete! !

!MenuMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:08:18'!
             initialize
	super initialize.
	extent _ `40@10`.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false.
	popUpOwner _ nil! !

!MenuMorph methodsFor: 'keyboard control' stamp: 'jmv 6/19/2017 16:08:04'!
                  displayFiltered: evt
	| matchStr allItems isMatch matches feedbackMorph |
	matchStr _ self valueOfProperty: #matchString.
	allItems _ self submorphs select: [ :m |
		m is: #MenuItemMorph ].
	matches _ allItems select: [ :m |
		isMatch _ matchStr isEmpty or: [
			m contents
				includesSubstring: matchStr
				caseSensitive: false ].
		m isEnabled: isMatch.
		isMatch ].
	feedbackMorph _ self valueOfProperty: #feedbackMorph.
	feedbackMorph ifNil: [
		feedbackMorph _ StringMorph new color: Color veryDarkGray.
		self addMorphBack: feedbackMorph lock position: `0@ -20`.
		self
			setProperty: #feedbackMorph
			toValue: feedbackMorph ].
	feedbackMorph contents: '<' , matchStr , '>'.
	matchStr isEmpty ifTrue: [
		feedbackMorph delete.
		self removeProperty: #feedbackMorph ].
	matches notEmpty ifTrue: [
		self selectItem: matches first ]! !

!MenuMorph methodsFor: 'keyboard control' stamp: 'len 6/11/2016 20:40'!
           keyboardFocusChange: aBoolean
	"Notify change due to green border for keyboard focus"

	aBoolean ifFalse: [self deleteIfPopUp: nil].
	self redrawNeeded! !

!MenuMorph methodsFor: 'modal control' stamp: 'jmv 3/2/2017 20:08:34'!
                             invokeModal: allowKeyboardControl
	"Invoke this menu and don't return until the user has chosen a value.  If the allowKeyboarControl boolean is true, permit keyboard control of the menu
	See senders of this method for finding out how to use modal menu morphs."
	| w oldFocus actHand |
	w _ self runningWorld.
	actHand _ w activeHand.
	oldFocus _ actHand keyboardFocus.
	w doOneMinimalCycleNow.
	self	
		popUpAt: actHand morphPosition
		forHand: actHand 
		allowKeyboard: allowKeyboardControl.
	self isModalInvokationDone: false.
	[ self isInWorld & self isModalInvokationDone not ] whileTrue: [ w doOneMinimalCycleNow ].
	self delete.
	oldFocus ifNotNil: [ actHand newKeyboardFocus: oldFocus ].
	^ self modalSelection! !

!MenuMorph methodsFor: 'private' stamp: 'jmv 6/19/2017 16:07:56'!
            adjustSubmorphsLayout
	"Enlarge the width of submorphs as needed
	so all of them are have the same width, and no less than #minWidth.
	Also adjust their vertical position.
	Finally, set our own extent."
	
	| w p h |
	
	submorphs isEmpty ifTrue: [ ^self ].
	w _ submorphs inject: 0 into: [ :prev :each |
		prev max: each minItemWidth].

	w _ w + 1.
	p _ `5 @ 5`.
	submorphs do: [ :m |
		h _ m morphHeight.
		m morphPosition: p extent: w@h.
		p _ p + (0@(h + 1)) ].

	self morphExtent: w+4 @ p y + 5! !

!MenuMorph methodsFor: 'private' stamp: 'jmv 6/19/2017 16:08:14'!
        fitInWorld
	"Note: items may not be laid out yet (I found them all to be at 0@0),  
	so we have to add up heights of items above the selected item."

	| delta |
	"If it doesn't fit, show it to the left, not to the right of the hand."
	self morphBoundsInWorld right > owner world morphBoundsInWorld right
		ifTrue: [
			self morphPosition: ((self morphPosition x + 10 - extent x) @ self morphPosition y) ].

	"Make sure that the menu fits in the world."
	delta _ self morphBoundsInWorld amountToTranslateWithin:
		(owner world morphBoundsInWorld withHeight:
			((owner world morphExtentInWorld y) max: (self morphPosition y) + 1)).
	delta = `0 @ 0` ifFalse: [ self morphPosition: self morphPosition + delta ]! !

!MenuMorph commentStamp: '<historical>' prior: 0!
      Instance variables:
	defaultTarget 		<Object>					The default target for creating menu items
	selectedItem			<MenuItemMorph> 		The currently selected item in the receiver
	stayUp 				<Boolean>				True if the receiver should stay up after clicks!

Object subclass: #Message
	instanceVariableNames: 'selector args lookupClass'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Methods'!

!Message methodsFor: 'stub creation' stamp: 'HAW 8/22/2017 11:23:03'!
         addGetterCodeOn: stream

	stream
		newLine; tab;
		nextPut: $^;
		nextPutAll: selector ! !

!Message methodsFor: 'stub creation' stamp: 'HAW 8/22/2017 11:23:07'!
                              addSetterCodeOn: stream with: argumentName
						
	stream
		newLine; tab;
		nextPutAll: selector allButLast;
		nextPutAll: ' := ';
		nextPutAll: argumentName ! !

!Message methodsFor: 'stub creation' stamp: 'HAW 8/22/2017 11:22:53'!
                       createStubMethodFor: aClass

	| argNames argName arg  |

	argNames _ Set new.
	^ String streamContents: [ :s |
		self selector keywords withIndexDo: [ :key :i |
			s nextPutAll: key.
			((key last = $:) or: [self selector isInfix]) ifTrue: [
				arg _ self arguments at: i.
				argName _ arg argumentName.
				[argNames includes: argName] whileTrue: [argName _ argName, i asString].
				argNames add: argName.
				s nextPutAll: ' '; nextPutAll: argName; space
			].
		].
	
		s newLine; tab.
		self writeShouldBeImplementedOn: s.
		(self isGetterFor: aClass) ifTrue: [ self addGetterCodeOn: s ].
		(self isSetterFor: aClass) ifTrue: [ self addSetterCodeOn: s with: argName ].
	]! !

!Message methodsFor: 'stub creation' stamp: 'HAW 8/22/2017 11:23:11'!
                writeShouldBeImplementedOn: stream.

	stream				
		nextPutAll: 'self ';
		nextPutAll: #shouldBeImplemented;
		nextPut: $.! !

!Message methodsFor: 'testing' stamp: 'HAW 8/22/2017 11:22:40'!
  isGetterFor: aClass

	^selector isUnary and: [ aClass instVarNames includes: selector  ]! !

!Message methodsFor: 'testing' stamp: 'HAW 8/22/2017 11:22:43'!
   isSetterFor: aClass

	^selector isKeyword and: [ self numArgs = 1 and: [ aClass instVarNames includes: selector allButLast ]]! !


Browser subclass: #MessageSet
	instanceVariableNames: 'messageList autoSelectString'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Browser'!

!MessageSet methodsFor: 'private' stamp: 'jmv 8/28/2017 17:05:18'!
                          initializeMessageList: anArray

	messageList _ anArray.
	messageList isEmpty
		ifTrue: [ selectedMessage _ nil ]
		ifFalse: [
			selectedMessage _ messageList first.
			self editSelection: #editMessage ]! !

!MessageSet methodsFor: 'shout styling' stamp: 'jmv 8/26/2017 19:21:44'!
       shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Set the classOrMetaClass in anSHTextStyler, so that identifiers
	will be resolved correctly.
	Answer true to allow styling to proceed, or false to veto the styling"
	
	self isModeStyleable ifFalse: [^false].
	anSHTextStyler classOrMetaClass: self selectedClassOrMetaClass.
	^true! !


MessageSetWindow class
	instanceVariableNames: ''!

!MessageSetWindow class methodsFor: 'instance creation' stamp: 'jmv 6/7/2017 10:49:13'!
   openMessageList: anArray label: aString
	"Create a standard system view for the message set on the list, anArray. 
	The label of the view is aString."

	^self open: (MessageSet messageList: anArray) label: aString! !


ClassDescription subclass: #Metaclass
	instanceVariableNames: 'thisClass'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Classes'!

!Metaclass methodsFor: 'tdd' stamp: 'HAW 2/7/2017 11:56:51'!
                  testCaseClass

	^self soleInstance testCaseClass ! !


Object subclass: #MethodReference
	instanceVariableNames: 'classSymbol classIsMeta methodSymbol stringVersion'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Browser'!

!MethodReference methodsFor: 'queries' stamp: 'jmv 6/20/2017 13:30:02'!
       printOn: aStream
	"Print the receiver on a stream"

	super printOn: aStream.
	aStream
		space;
		nextPutAll: classSymbol.
	classIsMeta ifTrue: [ aStream nextPutAll: ' class' ].
	aStream
		nextPutAll: ' >> ';
		nextPutAll: methodSymbol! !


Timespan subclass: #Month
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Chronology'!

!Month methodsFor: 'double dispatching' stamp: 'jmv 9/18/2017 18:26:57'!
   subtractFrom: aTimespan

	^ aTimespan subtractMonth: self! !

!Month methodsFor: 'double dispatching' stamp: 'jmv 9/18/2017 18:26:44'!
                         subtractMonth: aMonth
	"Months can be subtracted even they have different length."

	^self start subtractDateAndtime: aMonth start! !


Month class
	instanceVariableNames: ''!

!Month class methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 16:48:55'!
   includingDateAndTime: aDateAndTime
	"Months start at day 1"
	| monthStart days |
	monthStart _ DateAndTime
				year: aDateAndTime yearNumber
				month: aDateAndTime monthIndex
				day: 1.
	days _ self daysInMonth: monthStart monthIndex forYear: monthStart yearNumber.
	^ self basicNew
 		start: monthStart;
		duration: (Duration days: days);
		yourself! !

!Month class methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 11:28:03'!
               readFrom: aStream 
	"Read a Month from the stream in any of the forms:  
		<month> <year>			(April 1982; APR-82; 4.82; APR82)  
		<month> <year>			(April, 1982; 4/82)
		<year>-<month>			(1982-04) (ISO8601)"
	"
	Month readFrom: 'July 1998' readStream
	"
	| month year firstAsNumber firstAsNumberSign |
	firstAsNumberSign := aStream peek = $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	aStream peek isDigit ifTrue: [
		firstAsNumber := (Integer readFrom: aStream) * firstAsNumberSign.
		(firstAsNumber < 0 or: [firstAsNumber > 12])
			ifTrue: [year := firstAsNumber]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	aStream peek isLetter
		ifTrue: ["MonthName-YY or YY-MonthName"
			month _ String streamContents: [ :strm |
				[ aStream peek isLetter ] whileTrue: [ strm nextPut: aStream next ]].
			[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1]]
		ifFalse: ["MM-YY or YY-MM"
			month _ year 
				ifNil: ["MM-YY"
					Month nameOfMonth: firstAsNumber ]
				ifNotNil: ["YY-MM"
					Month nameOfMonth: (Integer readFrom: aStream)]].

	year ifNil: [
		[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
		year := Integer readFrom: aStream].
	(year < 100 and: [year >= 0])  ifTrue: [
		year _ year < 69 
			ifTrue: [2000 + year]
			ifFalse: [1900 + year]].

	^ self month: month year: year! !


Object subclass: #Morph
	instanceVariableNames: 'owner submorphs location layoutNeeded layoutSpec properties'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

!Morph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 20:40'!
       color

	^ Color blue! !

!Morph methodsFor: 'accessing' stamp: 'jmv 1/15/2017 18:06:45'!
       taskbar
	^self world ifNotNil: [ :w | w taskbar ]! !

!Morph methodsFor: 'drawing' stamp: 'jmv 4/14/2015 08:53'!
               drawOn: aCanvas
	"A canvas is already set with a proper transformation from our coordinates to those of the Canvas target."
	aCanvas
		fillRectangle: self morphLocalBounds
		color: Color blue! !

!Morph methodsFor: 'drawing' stamp: 'jmv 1/15/2017 18:24:25'!
                              visible: aBoolean
	"set the 'visible' attribute of the receiver to aBoolean"

	self visible == aBoolean
		ifTrue: [ ^ self ].
	aBoolean ifFalse: [
		self redrawNeeded ].
	self setProperty: #visible toValue: aBoolean.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].
	aBoolean ifTrue: [
		self redrawNeeded.
		self taskbar ifNotNil: [ :tb |
			tb wasMadeVisible: self ]]! !

!Morph methodsFor: 'events' stamp: 'pb 7/16/2017 15:06:53'!
                               mouseHover: aMouseMoveEvent localPosition: localEventPosition
	"Handle a mouse move event.
	This message will only be sent to Morphs that answer true to #handlesMouseHover for events that have not been previously handled.
	We can query aMouseMoveEvent to know about pressed mouse buttons."
	"Allow instances to dynamically use properties for handling common events."
	self
		valueOfProperty: #mouseHover:localPosition:
		ifPresentDo: [ :handler |
			handler
				value: aMouseMoveEvent
				value: localEventPosition ].! !

!Morph methodsFor: 'event handling testing' stamp: 'pb 7/16/2017 15:00:51'!
          handlesMouseHover
	"Do I want to receive unhandled mouseMove events when the button is up and the hand is empty?  The default response is false."
	"Use a property test to allow individual instances to specify this."
	^ self hasProperty: #handlesMouseHover.! !

!Morph methodsFor: 'events-processing' stamp: 'pb 7/16/2017 15:31:38'!
                    processMouseOver: aMouseEvent localPosition: localEventPosition
	"System level event handling."
	 self hasMouseFocus ifTrue: [
		"Got this directly through #handleFocusEvent: so check explicitly"
		(self containsPoint: localEventPosition event: aMouseEvent) ifFalse: [
			^self ]].
	aMouseEvent hand noticeMouseOver: self event: aMouseEvent.
	"Open question: should any unhandled mouse move events be filtered out? (i.e. should mouseHover:localPosition: be called when a mouse button is pressed but the morph doesn't have mouse button handlers?  Essentially, what are the limits of what is considered 'hovering'?"
	(self handlesMouseHover and: [aMouseEvent wasHandled not]) ifTrue: [
		self
			mouseHover: aMouseEvent
			localPosition: localEventPosition ].! !

!Morph methodsFor: 'events-processing' stamp: 'jmv 6/19/2017 15:54:30'!
                              processUnknownEvent: aMorphicEvent localPosition: localEventPosition
	"An event of an unknown type was sent to the receiver. What shall we do?!!"

	Smalltalk beep. 
	aMorphicEvent printString displayAt: `0@0`.
	aMorphicEvent wasHandled: true! !

!Morph methodsFor: 'geometry' stamp: 'jmv 6/19/2017 16:08:34'!
           minimumExtent
	"This returns the minimum extent that the morph may be shrunk to.  Not honored in too many places yet, but respected by the resizeToFit feature, at least"

	self flag: #jmvVer2.	"in owner's coordinates?"
	^self valueOfProperty: #minimumExtent ifAbsent: [`1@1`]! !

!Morph methodsFor: 'geometry' stamp: 'jmv 6/19/2017 16:08:41'!
         morphExtent
	"In our own coordinates!!"
"Quizas eventualmente borrar este tambien? (no se usa mucho...)"
	self flag: #jmvVer2.
	^`50 @ 40`! !

!Morph methodsFor: 'geometry' stamp: 'jmv 6/19/2017 15:54:22'!
                  morphPositionInWorld

	self flag: #jmvVer2.
	"Most likely we don't want to use global coordinates...
	In fact, we could be in many frames of reference at the same time...
	This method makes no sense at all!!"

	^self externalizeToWorld: `0@0`! !

!Morph methodsFor: 'geometry' stamp: 'jmv 6/19/2017 15:54:26'!
          morphTopLeft
	"By default, morphs occupy a rectangle specified by #morphTopLef and #morphExtent"
	^`0@0`! !

!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 1/15/2017 14:58:58'!
      comeToFrontAndAddHalo
	self show.
	self comeToFront.
	self addHalo! !

!Morph methodsFor: 'halos and balloon help' stamp: 'pb 6/9/2017 00:52:09'!
              wantsHaloHandleWithSelector: aSelector inHalo: aHaloMorph
	"Answer whether the receiver would like to offer the halo handle with the given selector (e.g. #addCollapseHandle:)"

	(#(addRotateHandle: addRecolorHandle:) statePointsTo: aSelector)
		ifTrue: ["FIXME - hack to disable for non-functional halo items"
			^ false].

	Preferences selectiveHalos ifFalse: [
		^true ].

	(#(#addDismissHandle: ) includes: aSelector)
		ifTrue: [ ^ self resistsRemoval not ].
	(#(#addDragHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToBrownDragEasily ].
	(#(#addGrowHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToResizeEasily ].
	(#(#addRotateHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToRotateEasily ].
	(#(#addRecolorHandle: ) includes: aSelector)
		ifTrue: [ ^ self wantsRecolorHandle ].
	^ true! !

!Morph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:08:46'!
         openInWorld: aWorld
	"Add this morph to the requested World."
	(location = MorphicTranslation new)
		ifTrue: [ aWorld addMorph: self position: `50@50` ]
		ifFalse: [ aWorld addMorph: self ]! !

!Morph methodsFor: 'macpal' stamp: 'HernanWilkinson 1/10/2017 18:49:44'!
                     flashWith: aColor

	self morphBoundsInWorld ifNotNil: [ :r | Display flash: r with: aColor ]! !

!Morph methodsFor: 'menus' stamp: 'jmv 1/15/2017 14:59:12'!
   expand
	
	self show.
	self comeToFront! !

!Morph methodsFor: 'printing' stamp: 'jmv 12/5/2016 08:16:19'!
                      printOn: aStream 
	"Add the identity of the receiver to a stream"
	aStream isText
		ifTrue: [
			aStream
				withAttribute: (TextAnchor new anchoredFormOrMorph: (owner ifNil: [self] ifNotNil: [self imageForm:32]))
				do: [ aStream nextPut: $* ].
			^ self].
	super printOn: aStream. "a(n) className"
	aStream 
		nextPut: $(;
		print: self identityHash;
		nextPut: $).
	self valueOfProperty: #morphName ifPresentDo: [ :x | aStream nextPutAll: x asString]! !

!Morph methodsFor: 'testing' stamp: 'jmv 1/15/2017 15:04:18'!
                       isCollapsed

	^ self visible not! !

!Morph methodsFor: 'user interface' stamp: 'jmv 3/30/2017 08:55:31'!
                      collapse
	"If taskbar not visible, just hide."

	self taskbar
		ifNotNil: [ :tb | tb aboutToCollapse: self ].
	self hide! !

!Morph methodsFor: 'user interface' stamp: 'jmv 3/30/2017 08:38:12'!
                              showAndComeToFront
	"Make me visible if not, set me on top of all other sibling morphs."
	self show; comeToFront! !

!Morph methodsFor: 'user interface' stamp: 'jmv 3/30/2017 08:41:08'!
      toggleCollapseOrShow
	"If collapsed, show me.
	If visible, collapse me."

	self visible
		ifTrue:  [ self collapse ]
		ifFalse: [ self showAndComeToFront ]! !


Object subclass: #MorphicCanvas
	instanceVariableNames: 'form clipLeft clipTop clipRight clipBottom shadowColor transformations currentTransformation cti currentMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

!MorphicCanvas methodsFor: 'accessing' stamp: 'jmv 6/19/2017 15:54:34'!
  newClipRect: aRectangleOrNil
	"aRectangle is in world coordinates.
	But ivar clipRect is relative to the form,
	For example, if we had previously been built like
		aCanvas on: someForm over: (100@100 extent 200@100)
	then our origin would be -100 @ -100.
	Then, a clipRect argument like (120@120 extent: 40@30) would mean affecting
	only (20@20 extent: 40@30) in our form"

	self setClipRect: (aRectangleOrNil
		ifNil: [ `0@0` corner: form extent ]
		ifNotNil: [ aRectangleOrNil translatedBy: self canvasOrigin ])! !

!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 6/19/2017 16:08:51'!
                    drawCurrentAsError
	"The morph (or one of its submorphs) had an error in its drawing method."
	| r w |
	r _ currentMorph morphLocalBounds.
	w _ r extent > `50@50`
		ifTrue: [ 6 ]
		ifFalse: [ 2 ].
	self
		frameAndFillRectangle: r
		fillColor: Color red
		borderWidth: w
		borderColor: Color yellow.
	self line: r topLeft to: r bottomRight-w width: w color: Color yellow.
	self line: r topRight -(w@0) to: r bottomLeft -(0@w)width: w color: Color yellow! !

!MorphicCanvas methodsFor: 'drawing-text' stamp: 'jmv 6/19/2017 16:09:00'!
            drawStringEmbossed: aString from: firstIndex to: lastIndex at: aPoint font: fontOrNil color: aColor
	"Answer last affected pixel position
	Answer nil if nothing was done"

	aColor = Color black ifFalse: [ | topColor |
		topColor _ aColor alphaMixed: 0.25 with: Color black.
		self
			drawString: aString
			from: firstIndex
			to: lastIndex
			at: aPoint
			font: fontOrNil
			color: topColor ].
	aColor = Color white ifFalse: [ | bottomColor |
		bottomColor _ aColor alphaMixed: 0.22 with: Color white.
		self
			drawString: aString
			from: firstIndex
			to: lastIndex
			at: aPoint  + `0@2`
			font: fontOrNil
			color: bottomColor ].
	^self
		drawString: aString
		from: firstIndex
		to: lastIndex
		at: aPoint  + `0@1`
		font: fontOrNil
		color: aColor! !

!MorphicCanvas methodsFor: 'drawing-text' stamp: 'jmv 6/19/2017 15:54:38'!
                           textComposition: aTextComposition bounds: boundsRect color: c selectionColor: sc
	| displayScanner leftInRun line boundsInWorld tl |

	tl _ boundsRect topLeft.
	boundsInWorld _ currentTransformation displayBoundsOfTransformOf: boundsRect.

	displayScanner _ MorphicScanner new
		defaultFont: aTextComposition defaultFont;
		text: aTextComposition textComposed
		foreground: c.
	displayScanner canvas: self.

	leftInRun _ 0.
	"Take clipRect into account. Extrememly fast scrolls and redraws of huge files (like .sources)"
	(aTextComposition lineIndexForPoint: (`0@0` max: (clipLeft@clipTop)- boundsInWorld origin))
		to: (aTextComposition lineIndexForPoint: (boundsInWorld extent min: (clipRight@clipBottom+1) - boundsInWorld origin))
		do: [ :i |
			line _ aTextComposition lines at: i.
			aTextComposition
				displaySelectionInLine: line
				on: self
				textTopLeft: tl
				selectionColor: sc.
			leftInRun _ displayScanner displayLine: line textTopLeft: tl leftInRun: leftInRun  ]! !


MorphicCanvas class
	instanceVariableNames: ''!

!MorphicCanvas class methodsFor: 'instance creation' stamp: 'jmv 6/19/2017 15:54:43'!
                           onForm: aForm

	^ self basicNew
		initializeWith: aForm origin: `0@0`! !


Object subclass: #MorphicEvent
	instanceVariableNames: 'timeStamp source'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

!MorphicEvent methodsFor: 'dispatching' stamp: 'jmv 6/19/2017 15:54:47'!
                      startDispatchFrom: aHand
	"double dispatch the event dispatch"
	"An event of an unknown type was sent. What shall we do?!!"

	Smalltalk beep. 
	self printString displayAt: `0@0`.
	self wasHandled: true! !


CharacterScanner subclass: #MorphicScanner
	instanceVariableNames: 'canvas lineY foregroundColor defaultColor topLeft backgroundColor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Text'!

!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 9/17/2017 21:27:43'!
                       displayLine: textLine textTopLeft: textTopLeft leftInRun: leftInRun
	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."

	"textTopLeft is relative to the morph currently being drawn"
	| stopCondition nowLeftInRun startIndex string lastPos x1 |

	topLeft _ textTopLeft.
	line _ textLine.
	lineY _ line top + textTopLeft y.
	rightMargin _ line rightMargin + textTopLeft x.
	lastIndex _ line first.
	leftInRun <= 0 ifTrue: [
		self setFont.
		self setStopConditions ].
	leftMargin _ (line leftMarginForAlignment: alignment) + textTopLeft x.
	destX _ leftMargin.
	destY _ lineY + line baseline - font ascent.

	textLine isEmptyLine ifTrue: [
		textLine paragraphStyle ifNotNil: [ :ps |
			ps = paragraphStyle ifFalse: [
				foregroundColor _ defaultColor.
				self setActualFont: ps font.
				ps color ifNotNil: [ :color | self textColor: color ].
				alignment _ ps alignment.
				paragraphStyle _ ps.
				spaceWidth _ font widthOf: Character space.
				tabWidth _ (font widthOf: $a) * 3.
				xTable _ font xTable.
				map _ font characterToGlyphMap.
				self setStopConditions.
				text ifNotNil: [ destY _ lineY + line baseline - font ascent ]]].
		self displayBulletIfAppropriateFor: textLine textLeft: textTopLeft x.
		^leftInRun ].

	self displayBulletIfAppropriateFor: textLine textLeft: textTopLeft x.

	lastIndex _ line first.
	leftInRun <= 0
		ifTrue: [nowLeftInRun _ text runLengthFor: lastIndex]
		ifFalse: [nowLeftInRun _ leftInRun].
	runStopIndex _ lastIndex + (nowLeftInRun - 1) min: line last.
	spaceCount _ 0.
	string _ text string.

	self placeEmbeddedObject.
	[
		startIndex _ lastIndex.
		lastPos _ destX@destY.
		stopCondition _ self
			scanCharactersFrom: lastIndex to: runStopIndex
			in: string rightX: rightMargin stopConditions: stopConditions
			kern: font baseKern.
		backgroundColor ifNotNil: [
			x1 _ destX.
			(Preferences backgroundColorFillsAllBackground and: [startIndex > line last]) ifTrue: [
				x1 _ rightMargin ].
			canvas
				fillRectangle: (lastPos corner: x1 @ (line bottom + textTopLeft y))
				color: backgroundColor.
			(Preferences backgroundColorFillsAllBackground and: [stopCondition = #tab]) ifTrue: [
				canvas
					fillRectangle: (destX @ lastPos y corner: self tabDestX @ (line bottom + textTopLeft y))
					color: backgroundColor ]].
		lastIndex >= startIndex ifTrue: [
			canvas  
				drawString: string
				from: startIndex
				to: lastIndex
				at: lastPos
				font: font
				color: foregroundColor ].
		"see setStopConditions for stopping conditions for displaying."
		(self perform: stopCondition) ifTrue: [
			"Number of characters remaining in the current run"
			^ runStopIndex - lastIndex ]
	] repeat! !

!MorphicScanner methodsFor: 'private' stamp: 'jmv 9/7/2017 16:56:38'!
                  backgroundColor: aColor
	backgroundColor _ aColor! !


Magnitude subclass: #Number
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Numbers'!

!Number methodsFor: 'intervals' stamp: 'jmv 8/3/2017 11:57:08'!
      to: stop do: elementBlock separatedBy: separatorBlock
	"
	String streamContents: [ :strm |
		1 to: 10 do: [ :i | i printOn: strm ] separatedBy: [ strm nextPutAll: ' -- ' ]]
	"
	| beforeFirst | 
	"Evaluate the elementBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	beforeFirst _ true.
	self to: stop do: [ :element |
		beforeFirst
			ifTrue: [beforeFirst _ false]
			ifFalse: [separatorBlock value].
		elementBlock value: element]! !

!Number methodsFor: 'mathematical functions' stamp: 'jmv 8/17/2017 21:44:25'!
                           raisedTo: aNumber 
	"Answer the receiver raised to aNumber."

	aNumber isInteger ifTrue: [
		"Do the special case of integer power"
		^ self raisedToInteger: aNumber].
	aNumber isFraction ifTrue: [
		"Special case for fraction power by Nicolas Cellier:
		If aNumber is a fraction, but result must be a Float, learn it as quickly as possible, and give quick Float answer
		Allows evaluating:
		(2009/2000) raisedTo: (3958333/100000)
		"
		^ self raisedToFraction: aNumber].
	self < 0 ifTrue: [
		^ ArithmeticError signal: 'Negative numbers can''t be raised to float powers.' ].
	0 = aNumber ifTrue: [^ self class one].	"Special case of exponent=0"
	1 = aNumber ifTrue: [^ self].	"Special case of exponent=1"
	0 = self ifTrue: [				"Special case of self = 0"
		aNumber < 0
			ifTrue: [^ (ZeroDivide dividend: self) signal]
			ifFalse: [^ self]].
	^ (aNumber * self ln) exp		"Otherwise use logarithms"! !

!Number methodsFor: 'mathematical functions' stamp: 'jmv 8/17/2017 21:37:11'!
           raisedToFraction: aFraction
	self isZero ifTrue: [
		aFraction negative ifTrue: [
			^ (ZeroDivide dividend: 1) signal ].
		^ self ].
	self negative ifFalse: [
		^ (self ln * aFraction) exp ].
	aFraction denominator even ifTrue: [
		^ ArithmeticError signal: 'nth root only defined for positive Integer n.' ].
	^ (self negated ln * aFraction) exp negated! !

!Number methodsFor: 'printing' stamp: 'jmv 9/19/2017 21:48:57'!
                         withBinaryUnitPrefixAndValue: aBlock
	"
	As in https://en.wikipedia.org/wiki/Binary_prefix
	{ 0.123456. 1.23456. 12.3456. 123.456. 1234.56. 12345.6. 123456. 1234560. 12345600 } do: [ :n | n withBinaryUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName | {value printString, ' ', unitPrefixSymbol. unitPrefixName} print]]
	"
	| prefixIndex factor nameAndSymbol |
	prefixIndex _ self log floor // 3.
	prefixIndex _ prefixIndex min: 8 max: 0.
	factor _ 1024 raisedToInteger: prefixIndex.
	nameAndSymbol _ {
		{''. ''}.
		{'kibi'.		'Ki'}.
		{'mebi'.	'Mi'}.
		{'gibi'.		'Gi'}.
		{'tebi'.		'Ti'}.
		{'pebi'.	'Pi'}.
		{'exbi'.	'Ei'}.
		{'zebi'.	'Zi'}.
		{'yobi'.	'Yi'}
	} at: prefixIndex+1.
	aBlock value: (self / factor) asIntegerOrFloat value: nameAndSymbol second value: nameAndSymbol first! !

!Number methodsFor: 'printing' stamp: 'jmv 9/19/2017 21:48:12'!
                             withDecimalUnitPrefixAndValue: aBlock
	"
	As in https://en.wikipedia.org/wiki/Metric_prefix
	{ 0.00000123456. 0.0000123456. 0.000123456. 0.00123456. 0.0123456. 0.123456. 1.23456. 12.3456. 123.456. 1234.56. 12345.6. 123456. 1234560. 12345600 } do: [ :n | n withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName | {value printString, ' ', unitPrefixSymbol. unitPrefixName} print]]
	"
	| prefixIndex factor nameAndSymbol |
	prefixIndex _ self log floor // 3.
	prefixIndex _ prefixIndex min: 6 max: -6.
	factor _ 1000 raisedToInteger: prefixIndex.
	nameAndSymbol _ {
		{'atto'.	'a'}.
		{'femto'.	'f'}.
		{'pico'.	'p'}.
		{'nano'.	'n'}.
		{'micro'.	''}.
		{'milli'.		'm'}.
		{''. ''}.
		{'kilo'.		'k'}.
		{'mega'.	'M'}.
		{'giga'.	'G'}.
		{'tera'.	'T'}.
		{'peta'.	'P'}.
		{'exa'.		'E'}
	} at: prefixIndex+7.
	aBlock value: self asFloat / factor value: nameAndSymbol second value: nameAndSymbol first! !


OMeta2 subclass: #O2SqueakRecognizer
	instanceVariableNames: ''
	classVariableNames: 'TypeTable'
	poolDictionaries: ''
	category: 'OMeta2'!

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 00:43'!
                 arrayConstr =

	"{" expr ("." expr)* ("." | empty) "}"
|	"{" "}"! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 00:57'!
                    arrayLit =

	"#" "(" (literal | arrayLit | spaces tsArraySymbol)* ")"! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 00:57'!
               binary =

	spaces tsBinary! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 00:58'!
                          binaryExpr =

	binaryExpr binaryMsg
|	unaryExpr! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 00:58'!
     binaryMsg =

	binary unaryExpr! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 01:08'!
                      block =

	"["
		(	(":" identifier)+ "|"
		|	empty
		)

		(	"|" identifier* "|"
		|	empty
		)

		(	expr ("." expr)* ("." "^" expr | empty)
		|	"^" expr
		|	empty
		)

		(	"."
		|	empty
		)

	"]"! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 00:58'!
                   cascade =

	identifier
|	binaryMsg
|	keywordMsg! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 00:59'!
     expr =

	identifier (":=" | "_") expr
|	msgExpr! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 01:18'!
     identifier =

	spaces tsIdentifier ~$:! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 01:19'!
              keyword =

	spaces tsKeyword! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 01:19'!
                        keywordExpr =

	binaryExpr keywordMsg! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 01:19'!
               keywordMsg =

	keywordMsg keywordMsgPart
|	keywordMsgPart! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 01:20'!
                           keywordMsgPart =

	keyword binaryExpr! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 01:20'!
               literal =

	spaces	(	tsNumber
			|	tsCharacter
			|	tsString
			|	tsSymbol
			)
! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 01:21'!
    msgExpr =

	(keywordExpr | binaryExpr) (";" cascade)*! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 01:23'!
                               symbol =

	"#" spaces
		(	tsString
		|	tsKeyword (tsIdentifier | empty)
		)! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 01:23'!
         tcBinaryChar =

	char:x ?[(TypeTable at: x asciiValue) == #xBinary]! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 01:25'!
                 tsArraySymbol =

	tsKeyword+ (tsIdentifier | empty)
|	tsIdentifier! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 01:25'!
                  tsBinary =

	($| | tcBinaryChar) tcBinaryChar*! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 01:25'!
      tsCharacter =

	$$ char! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 01:26'!
                             tsIdentifier =

	letter (letter | digit)*! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 01:31'!
           tsKeyword =

	tsIdentifier $:! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 01:26'!
                       tsNatural =

	digit+! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 01:27'!
tsNumber =

	($+ | $- | empty) tsNatural! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 01:28'!
            tsString =

	$' ($' $' | ~$' char)* $'! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 01:28'!
              tsSymbol =

	$# spaces (tsString | tsArraySymbol)! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 01:28'!
   unaryExpr =

	unit identifier*! !

!O2SqueakRecognizer methodsFor: 'private' stamp: 'aw 2/20/2009 01:29'!
                      unit =

	literal
|	identifier
|	arrayLit
|	arrayConstr
|	block
|	"(" expr ")"
! !

!O2SqueakRecognizer methodsFor: 'grammar root' stamp: 'aw 2/20/2009 01:30'!
 squeakExpr =

	<expr>! !

!O2SqueakRecognizer commentStamp: '<historical>' prior: 0!
           OMeta implementation!

O2SqueakRecognizer class
	instanceVariableNames: ''!

!O2SqueakRecognizer class methodsFor: 'class initialization' stamp: 'aw 2/20/2009 02:04'!
                         initialize

	TypeTable := #(#xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xDelimiter #xDelimiter #xBinary #xDelimiter #xDelimiter #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #doIt #xBinary #xDelimiter #xBinary #xDoubleQuote #xLitQuote #xDollar #xBinary #xBinary #xSingleQuote #leftParenthesis #rightParenthesis #xBinary #xBinary #xBinary #xBinary #period #xBinary #xDigit #xDigit #xDigit #xDigit #xDigit #xDigit #xDigit #xDigit #xDigit #xDigit #xColon #semicolon #xBinary #xBinary #xBinary #xBinary #xBinary #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #leftBracket #xBinary #rightBracket #upArrow #leftArrow #xBinary #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #leftBrace #verticalBar #rightBrace #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xLetter #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xLetter #xBinary #xBinary #xBinary #xBinary #xLetter #xBinary #xBinary #xBinary #xBinary #xBinary #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xBinary #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xBinary #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xBinary)! !


OM2Stream subclass: #OM2EndOfStream
	instanceVariableNames: 'stream pos'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!

!OM2EndOfStream methodsFor: 'private-ometa2preload' stamp: 'aw 2/25/2009 11:29'!
      head

	OM2Fail signal! !

!OM2EndOfStream methodsFor: 'private-ometa2preload' stamp: 'aw 2/20/2009 14:50'!
                     initStream: s pos: p

	stream := s.
	pos := p! !

!OM2EndOfStream methodsFor: 'private-ometa2preload' stamp: 'aw 2/19/2009 23:14'!
                             inputSpecies

	^ stream originalContents species! !

!OM2EndOfStream methodsFor: 'private-ometa2preload' stamp: 'aw 2/20/2009 14:49'!
                          pos

	^ pos! !

!OM2EndOfStream methodsFor: 'private-ometa2preload' stamp: 'aw 2/25/2009 11:29'!
                               tail

	OM2Fail signal! !


Exception subclass: #OM2Fail
	instanceVariableNames: 'parserFailedAt'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!

!OM2Fail methodsFor: 'exceptionDescription' stamp: 'aw 2/26/2009 11:03'!
           defaultAction

	self error: 'match failed'! !

!OM2Fail methodsFor: 'accessing' stamp: 'pb 9/5/2017 13:01'!
                    parserFailedAt
	^ parserFailedAt.! !

!OM2Fail methodsFor: 'private' stamp: 'pb 9/5/2017 13:01'!
                               privateParserFailedAt: pos
	parserFailedAt := pos.! !


OM2Fail class
	instanceVariableNames: ''!

!OM2Fail class methodsFor: 'exceptionInstantiator' stamp: 'pb 9/5/2017 13:01'!
              parserFailedAt: positionInStream
	^ self new
		privateParserFailedAt: positionInStream;
		signal.! !


Object subclass: #OM2Failer
	instanceVariableNames: 'used'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!

!OM2Failer methodsFor: 'initialization' stamp: 'aw 2/16/2009 14:23'!
              initialize

	used := false! !

!OM2Failer methodsFor: 'initialization' stamp: 'aw 2/27/2009 13:44'!
                            used

	^ used! !

!OM2Failer methodsFor: 'evaluating' stamp: 'aw 2/27/2009 13:42'!
             value

	used := true.
	OM2Fail signal! !


OM2Stream subclass: #OM2LazyStream
	instanceVariableNames: 'stream pos'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!

!OM2LazyStream methodsFor: 'private-ometa2preload' stamp: 'aw 2/20/2009 14:50'!
                  initHead: h stream: s pos: p

	head := h.
	stream := s.
	pos := p! !

!OM2LazyStream methodsFor: 'private-ometa2preload' stamp: 'aw 2/19/2009 23:15'!
          inputSpecies

	^ stream originalContents species! !

!OM2LazyStream methodsFor: 'private-ometa2preload' stamp: 'aw 2/20/2009 14:43'!
                           pos

	^ pos! !

!OM2LazyStream methodsFor: 'private-ometa2preload' stamp: 'aw 2/20/2009 14:42'!
tail

	tail ifNil: [tail := OM2LazyStream for: stream withPos: pos + 1].
	^ tail! !


OM2LazyStream class
	instanceVariableNames: ''!

!OM2LazyStream class methodsFor: 'private-ometa2preload' stamp: 'aw 2/20/2009 14:44'!
   for: aReadStream withPos: pos

	^ aReadStream atEnd
		ifTrue: [OM2EndOfStream new initStream: aReadStream pos: pos]
		ifFalse: [self new initHead: aReadStream next stream: aReadStream pos: pos]! !


Object subclass: #OM2Stream
	instanceVariableNames: 'head tail memo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'aw 2/26/2009 11:04'!
                             basicTail

	^ tail! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'aw 2/26/2009 11:38'!
                             forgetEverything

	memo := IdentityDictionary new! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'aw 2/16/2009 11:35'!
                              head

	^ head! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'aw 2/16/2009 13:38'!
  initHead: h tail: t

	head := h.
	tail := t! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'aw 2/19/2009 23:13'!
    inputSpecies

	^ Array! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'aw 2/16/2009 14:13'!
                         memo

	^ memo! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'aw 2/20/2009 14:51'!
  pos

	^ -1! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'aw 2/16/2009 11:35'!
     tail

	^ tail! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'aw 2/26/2009 11:40'!
  transitiveForgetEverything

	| curr |
	curr := self.
	[curr notNil] whileTrue: [
		curr forgetEverything.
		curr := curr basicTail
	]! !

!OM2Stream methodsFor: 'initialization' stamp: 'aw 2/16/2009 11:34'!
                 initialize

	memo := IdentityDictionary new! !

!OM2Stream methodsFor: 'printing' stamp: 'aw 2/26/2009 11:05'!
                 printOn: aStream

	| inputIsString curr |
	inputIsString := (self inputSpecies inheritsFrom: String) and: [(self inputSpecies inheritsFrom: Symbol) not].
	curr := self.
	aStream
		nextPutAll: 'an ';
		nextPutAll: self class name;
		nextPut: $(.
	[curr notNil] whileTrue: [
		(curr isKindOf: OM2EndOfStream) ifTrue: [
			aStream nextPut: $).
			^ self
		].
		inputIsString
			ifTrue: [aStream nextPut: curr head]
			ifFalse: [
				curr head printOn: aStream.
				aStream space
			].
		curr := curr basicTail.
	].
	aStream nextPutAll: '...)'! !


OM2Stream subclass: #OM2StreamDebugger
	instanceVariableNames: 'om2stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!

!OM2StreamDebugger methodsFor: 'private-ometa2preload' stamp: 'aw 2/27/2009 13:28'!
                     forgetEverything

	om2stream forgetEverything! !

!OM2StreamDebugger methodsFor: 'private-ometa2preload' stamp: 'aw 2/26/2009 13:40'!
                          head

	^ om2stream head! !

!OM2StreamDebugger methodsFor: 'private-ometa2preload' stamp: 'aw 2/26/2009 15:26'!
                initOm2stream: anOM2Stream

	om2stream := anOM2Stream! !

!OM2StreamDebugger methodsFor: 'private-ometa2preload' stamp: 'aw 2/27/2009 13:27'!
                  memo

	^ om2stream memo! !

!OM2StreamDebugger methodsFor: 'private-ometa2preload' stamp: 'aw 2/26/2009 13:40'!
                tail

	^ om2stream tail! !

!OM2StreamDebugger methodsFor: 'private-ometa2preload' stamp: 'aw 2/27/2009 13:29'!
                transitiveForgetEverything

	om2stream transitiveForgetEverything! !

!OM2StreamDebugger methodsFor: 'printing' stamp: 'aw 2/26/2009 15:57'!
                   printOn: aStream

	aStream nextPutAll: 'an OM2StreamDebugger('.
	om2stream printOn: aStream.
	aStream nextPut: $)! !


OM2StreamDebugger class
	instanceVariableNames: ''!

!OM2StreamDebugger class methodsFor: 'private-ometa2preload' stamp: 'aw 2/26/2009 15:28'!
                          for: anOM2Stream

	^ self new initOm2stream: anOM2Stream! !


OM2Stream subclass: #OM2StreamProxy
	instanceVariableNames: 'target'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!

!OM2StreamProxy methodsFor: 'private-ometa2preload' stamp: 'aw 2/26/2009 11:05'!
 basicTail

	^ target basicTail! !

!OM2StreamProxy methodsFor: 'private-ometa2preload' stamp: 'aw 2/16/2009 12:08'!
            head

	head ifNil: [head := target head].
	^ head
! !

!OM2StreamProxy methodsFor: 'private-ometa2preload' stamp: 'aw 2/19/2009 23:45'!
                        initTarget: anOM2Stream

	target := anOM2Stream! !

!OM2StreamProxy methodsFor: 'private-ometa2preload' stamp: 'aw 2/19/2009 23:13'!
                           inputSpecies

	^ target inputSpecies! !

!OM2StreamProxy methodsFor: 'private-ometa2preload' stamp: 'aw 2/20/2009 14:51'!
      pos

	^ target pos! !

!OM2StreamProxy methodsFor: 'private-ometa2preload' stamp: 'aw 2/16/2009 12:07'!
                        tail

	tail ifNil: [tail := OM2StreamProxy for: target tail].
	^ tail! !

!OM2StreamProxy methodsFor: 'private-ometa2preload' stamp: 'aw 2/16/2009 14:10'!
     target

	^ target! !


OM2StreamProxy class
	instanceVariableNames: ''!

!OM2StreamProxy class methodsFor: 'private-ometa2preload' stamp: 'aw 2/19/2009 23:44'!
for: anOM2Stream

	^ self new initTarget: anOM2Stream! !


OMeta2Base subclass: #OMeta2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2'!

!OMeta2 methodsFor: 'ometa grammar - text' stamp: 'pb 5/22/2015 18:23'!
 char =

	anything:x ?[x isKindOf: Character] -> [x]! !

!OMeta2 methodsFor: 'ometa grammar - text' stamp: 'pb 5/22/2015 18:24'!
digit =

	char:x ?[x isDigit] -> [x]! !

!OMeta2 methodsFor: 'ometa grammar - text' stamp: 'pb 6/11/2015 02:12'!
               fromToEnd :from =
	// fixme - broken
	/* Match the sequence :from to either the end of line or the input stream.  Example to match a comment: fromToEnd("//"):commentText
	fixme - if 2nd param could be made optional and default to lf, this rule would be usable by any type of object */
	//[Character newLineCharacter asString]:eol seq(from) (~seq(eol) anything)*:t (seq(eol) | end) -> [t]
	[Character newLineCharacter asString]:to fromToOrEnd(from. to)! !

!OMeta2 methodsFor: 'ometa grammar - text' stamp: 'pb 6/11/2015 02:11'!
                fromToEndOld :from =
	/* Match the sequence :from to either the end of line or the input stream.  Example to match a comment: fromToEnd("//"):commentText
	fixme - if 2nd param could be made optional and default to lf, this rule would be usable by any type of object */
	[Character newLineCharacter asString]:eol seq(from) (~seq(eol) anything)*:t (seq(eol) | end) -> [t]! !

!OMeta2 methodsFor: 'ometa grammar - text' stamp: 'pb 5/22/2015 18:28'!
  letter =

	char:x ?[x isLetter] -> [x]! !

!OMeta2 methodsFor: 'ometa grammar - text' stamp: 'pb 5/22/2015 18:28'!
             letterOrDigit =

	char:x ?[x isAlphaNumeric] -> [x]! !

!OMeta2 methodsFor: 'ometa grammar - text' stamp: 'pb 5/22/2015 18:30'!
lower =

	char:x ?[x isLowercase] -> [x]! !

!OMeta2 methodsFor: 'ometa grammar - text' stamp: 'pb 5/22/2015 18:32'!
           space =

	char:x ?[x asciiValue <= 32] -> [x]! !

!OMeta2 methodsFor: 'ometa grammar - text' stamp: 'pb 5/22/2015 18:33'!
      spaces =

	space*! !

!OMeta2 methodsFor: 'ometa grammar - text' stamp: 'pb 5/22/2015 18:34'!
  string =

	anything:x ?[x isString] -> [x]! !

!OMeta2 methodsFor: 'ometa grammar - text' stamp: 'pb 5/22/2015 18:34'!
         token :t =

	spaces seq(t)! !

!OMeta2 methodsFor: 'ometa grammar - text' stamp: 'pb 5/22/2015 18:35'!
                         upper =

	char:x ?[x isUppercase] -> [x]! !

!OMeta2 methodsFor: 'ometa grammar' stamp: 'pb 6/10/2015 15:53'!
                  empty
	"fixme - inline?"
	^ true.! !

!OMeta2 methodsFor: 'ometa grammar' stamp: 'pb 6/4/2015 17:23'!
                          end =
	// Are we at the end of the input stream?
	~anything! !

!OMeta2 methodsFor: 'ometa grammar' stamp: 'pb 5/22/2015 18:25'!
                               exactly :wanted =

	anything:got ?[wanted = got] -> [wanted]! !

!OMeta2 methodsFor: 'ometa grammar' stamp: 'pb 6/10/2015 15:53'!
                              firstAndRest
	"A meta rule for 'first rest+' where the rule names are substituted with the values of first and rest.  See listOf for another example of a meta rule.  fixme - rewrite in OMeta"
	| first rest |
	first := self apply: #anything.
	rest := self apply: #anything.
	^ self genericMany: [self apply: rest] into: (OrderedCollection with: (self apply: first))! !

!OMeta2 methodsFor: 'ometa grammar' stamp: 'pb 6/10/2015 15:55'!
              fromTo :x :y =
	// Match the sequence from x to y.  Example to match a comment: fromTo("/*", "*/"):commentText
	seq(x) (~seq(y) anything)*:t seq(y) -> [t]! !

!OMeta2 methodsFor: 'ometa grammar' stamp: 'pb 6/11/2015 01:48'!
fromToOrEnd :x :y =
	// fixme - not working
	// Match the sequence from x to y.  Example to match a comment: fromTo("/*", "*/"):commentText
	seq(x) (~seq(y) anything)*:t (seq(y) | end) -> [t]! !

!OMeta2 methodsFor: 'ometa grammar' stamp: 'pb 5/22/2015 18:29'!
                           listOf :rule :delim =

		apply(rule):x (token(delim) apply(rule))*:xs -> [xs addFirst: x; yourself]
	|	empty -> [#()]! !

!OMeta2 methodsFor: 'ometa grammar' stamp: 'pb 5/22/2015 18:31'!
     notLast :rule =

	apply(rule):ans &apply(rule) -> [ans]! !

!OMeta2 methodsFor: 'ometa grammar' stamp: 'pb 5/22/2015 18:31'!
   number =

	anything:x ?[x isNumber] -> [x]! !

!OMeta2 methodsFor: 'ometa grammar' stamp: 'pb 6/4/2015 17:24'!
                 range :a :b =
	// Is the next object within the range of a .. b?  Example usage: checking if an input character falls within the given range.
	anything:x ?[a <= x & (x <= b)] -> [x]! !

!OMeta2 methodsFor: 'ometa grammar' stamp: 'pb 5/22/2015 18:34'!
     symbol =

	anything:x ?[x isSymbol] -> [x]! !

!OMeta2 methodsFor: 'private' stamp: 'pb 5/12/2016 21:52'!
                      parseLog: aString
	Transcript
		show: aString;
		finishEntry.! !

!OMeta2 commentStamp: '<historical>' prior: 0!
               OMeta Implementation

Parser Notes:
========

If your input consists of strings you want to parse (source code, text files, etc.), you most likely want to call the class-side 'MatchAll' methods (i.e. #matchAll:with:).  If your input consists of structured data (nested arrays etc) to parse, you probably want to call the class-side 'Match' methods (i.e. #match:with:).

For more unconventional parsing needs, you will likely need to override some OMeta2Base methods in your parser subclass.  It is highly suggested that you do not change OMeta2Base directly as any bugs or changes in behavior will likely break OMeta2 itself.  Therefore, overriding in your subclass is the recommended approach.

Todos:
====

* implement OMeta -> Squeak translator
* implement Squeak parser
* implement OMeta/Squeak "compiler", make it OMeta2's compilerClass

* rewrite #empty and #firstAndRest in OMeta syntax
* consider implementing position-related functionality (see http://www.tinlizzie.org/ometa-js/ometa-base.js)
* consider the optimization suggestions in the comments of OMeta2Lib's methods!

OMeta2NullOpt subclass: #OMeta2AndOrOpt
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2'!

!OMeta2AndOrOpt methodsFor: 'private' stamp: 'aw 5/20/2009 12:46'!
                          and =

	trans:x end setHelped -> [x]
|	transInside(#And):xs -> [xs addFirst: #And; yourself]! !

!OMeta2AndOrOpt methodsFor: 'private' stamp: 'aw 5/20/2009 12:46'!
                            or =

	trans:x end setHelped -> [x]
|	transInside(#Or):xs -> [xs addFirst: #Or; yourself]! !

!OMeta2AndOrOpt methodsFor: 'private' stamp: 'aw 5/20/2009 12:36'!
                               transInside :t =

	{exactly(t) transInside(t):xs} transInside(t):ys setHelped -> [xs, ys]
|	trans:x transInside(t):xs -> [xs addFirst: x; yourself]
|	empty -> [OrderedCollection new]! !

!OMeta2AndOrOpt commentStamp: '<historical>' prior: 0!
              Syntax tree grammar used by OMeta2Optimizer in stage 2 of compilation.

OMeta implementation!

Object subclass: #OMeta2Base
	instanceVariableNames: 'input om2streams haltingPoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'aw 2/18/2009 16:05'!
                            ? aBoolean

	^ self pred: aBoolean! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'aw 2/16/2009 15:13'!
                    anything

	| ans |
	ans := input head.
	input := input tail.
	^ ans! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'pb 9/5/2017 13:02'!
                    apply: aRule

	" A memoRec is an association whose key is the answer,
	  and whose value is the next input. Failers pretend to
     be memoRecs, but throw a fail in response to #value "
	| memo memoRec |
	input == haltingPoint ifTrue: [self halt].
	memo := input memo.
	memoRec := memo at: aRule ifAbsent: [nil].
	memoRec ifNil: [
		| origInput failer ans |
		origInput := input.
		failer := OM2Failer new.
		memo at: aRule put: failer.
		ans := self perform: aRule.
		memoRec := ans -> input.
		memo at: aRule put: memoRec.
		failer used ifTrue: [
			" left recursion detected "
			| sentinel keepGoing |
			sentinel := input.
			keepGoing := true.
			[keepGoing] whileTrue: [
				[
					input := origInput.
					ans := self perform: aRule.
					input == sentinel ifTrue: [OM2Fail parserFailedAt: input pos].
					memoRec key: ans value: input.
				] on: OM2Fail do: [keepGoing := false]
			]
		]		
	].
	input := memoRec value.
	^ memoRec key! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'aw 2/16/2009 13:39'!
       apply: aRule withArgs: args

	args reverseDo: [:a | input := OM2Stream new initHead: a tail: input].
	^ self perform: aRule! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'aw 2/19/2009 23:17'!
                           consumedBy: aBlock

	| origInput i ws |
	origInput := input.
	aBlock value.
	ws := WriteStream on: origInput inputSpecies new.
	i := origInput.
	[i == input] whileFalse: [
		ws nextPut: i head.
		i := i tail
	].
	^ ws contents! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'aw 2/16/2009 14:11'!
                    foreign

	| aGrammar aRule g ans |
	aGrammar := self apply: #anything.
	aRule := self apply: #anything.
	g := aGrammar new initInput: (OM2StreamProxy for: input).
	ans := g apply: aRule.
	input := g input target.
	^ ans! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'pb 3/14/2016 02:39'!
                           form: aBlock

	| v origInput |
	v := self apply: #anything.
	"FIXME - delete once confirmed
	self pred: (v isCollection and: [v isSequenceable and: [v isSymbol not]]).
	"
	self pred: (self isForm: v).
	origInput := input.
	input := self om2streams at: v ifAbsentPut: [OM2LazyStream for: v readStream withPos: 1].
	aBlock value.
	self apply: #end.
	input := origInput.
	^ v! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'aw 2/20/2009 14:57'!
  indexConsumedBy: aBlock

	| from to |
	from := self pos.
	aBlock value.
	to := self pos.
	^ from -> to! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'aw 2/16/2009 13:48'!
                lookahead: aBlock

	| origInput ans |
	origInput := input.
	ans := aBlock value.
	input := origInput.
	^ ans! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'aw 2/16/2009 13:56'!
          many1: aBlock

	^ self genericMany: aBlock into: (OrderedCollection with: aBlock value)! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'aw 2/16/2009 13:56'!
                               many: aBlock

	^ self genericMany: aBlock into: OrderedCollection new! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'pb 9/5/2017 13:02'!
                  not: aBlock

	| origInput |
	origInput := input.
	[aBlock value] on: OM2Fail do: [
		input := origInput.
		^ true
	].
	OM2Fail parserFailedAt: input pos! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'pb 9/5/2017 13:02'!
                               ometaOr: choices

	| origInput |
	origInput := input.
	choices do: [:choice |
		input := origInput.
		[^ choice value] on: OM2Fail do: []
	].
	OM2Fail parserFailedAt: input pos! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'aw 2/20/2009 14:33'!
      opt: aBlock

	^ self ometaOr: {
		[aBlock value].
		[nil]
	}! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'pb 9/5/2017 13:02'!
                           pred: aBooleanValue

	" may want to have the compiler inline this automatically, for performance "
	aBooleanValue ifTrue: [^ true].
	OM2Fail parserFailedAt: input pos! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'aw 2/16/2009 16:16'!
                seq

	| xs |
	xs := self apply: #anything.
	xs do: [:x |
		" may want to inline #apply:withArgs: below as an
		  optimization, since this rule gets used a lot "
		self apply: #exactly withArgs: {x}
	].
	^ xs
	! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'aw 2/16/2009 15:03'!
     super: superclass apply: aRule withArgs: args

	args reverseDo: [:a | input := OM2Stream new initHead: a tail: input].
	^ self perform: aRule withArguments: #() inSuperclass: superclass! !

!OMeta2Base methodsFor: 'private' stamp: 'aw 2/16/2009 14:01'!
   apply
	| aRule |
	aRule := self apply: #anything.
	^ self apply: aRule! !

!OMeta2Base methodsFor: 'private' stamp: 'aw 2/26/2009 13:17'!
                      forgetEverything

	input transitiveForgetEverything.
	self om2streams valuesDo: [:s | s transitiveForgetEverything]! !

!OMeta2Base methodsFor: 'private' stamp: 'aw 2/16/2009 15:19'!
         genericMany: aBlock into: anOrderedCollection

	[
		| origInput |
		origInput := input.
		[anOrderedCollection addLast: aBlock value] on: OM2Fail do: [
			input := origInput.
			^ anOrderedCollection
		].
		true
	] whileTrue! !

!OMeta2Base methodsFor: 'private' stamp: 'aw 2/27/2009 11:25'!
                            haltingPoint: anOM2Stream

	haltingPoint := anOM2Stream! !

!OMeta2Base methodsFor: 'private' stamp: 'aw 2/16/2009 14:06'!
     initInput: i

	input := i! !

!OMeta2Base methodsFor: 'private' stamp: 'aw 2/16/2009 14:10'!
   input

	^ input! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 3/14/2016 02:39'!
             isForm: obj
	^ (obj isCollection and: [obj isSequenceable and: [obj isSymbol not]])! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 5/26/2015 14:53'!
         om2streams
	^ om2streams ifNil: [om2streams := IdentityDictionary new].! !

!OMeta2Base methodsFor: 'private' stamp: 'aw 2/20/2009 14:48'!
                     pos
	"fixme - called by examples.  Replace call with @<>?"
	^ input pos! !

!OMeta2Base methodsFor: 'initialization' stamp: 'aw 2/26/2009 11:16'!
              initialize

	super initialize.
	om2streams := IdentityDictionary new! !

!OMeta2Base commentStamp: '<historical>' prior: 0!
    I provide the core language/library runtime support for OMeta that cannot be rewritten as OMeta code.!

OMeta2Base class
	instanceVariableNames: ''!

!OMeta2Base class methodsFor: 'matching' stamp: 'aw 2/26/2009 12:52'!
    debugMatch: anObject with: aRule

	^ self debugMatch: anObject with: aRule withArgs: #()! !

!OMeta2Base class methodsFor: 'matching' stamp: 'aw 2/26/2009 12:58'!
                             debugMatch: anObject with: aRule withArgs: args

	^ self debugMatchAll: {anObject} readStream with: aRule withArgs: args! !

!OMeta2Base class methodsFor: 'matching' stamp: 'aw 2/26/2009 12:35'!
                             debugMatchAll: aSequenceableCollection with: aRule

	^ self debugMatchAll: aSequenceableCollection with: aRule withArgs: #()! !

!OMeta2Base class methodsFor: 'matching' stamp: 'aw 2/26/2009 12:53'!
                         debugMatchAll: aSequenceableCollection with: aRule withArgs: args

	^ self matchStream: aSequenceableCollection readStream with: aRule withArgs: args withPlaybackDebugging: true! !

!OMeta2Base class methodsFor: 'matching' stamp: 'pb 3/14/2016 02:39'!
    match: anObject with: aRule
	"Recommended for use with structured data (i.e. arrays of arrays etc)"

	^ self match: anObject with: aRule withArgs: #()! !

!OMeta2Base class methodsFor: 'matching' stamp: 'aw 2/26/2009 12:55'!
                               match: anObject with: aRule withArgs: args

	^ self matchAll: {anObject} readStream with: aRule withArgs: args! !

!OMeta2Base class methodsFor: 'matching' stamp: 'aw 2/18/2009 15:39'!
       matchAll: aSequenceableCollection with: aRule

	^ self matchAll: aSequenceableCollection with: aRule withArgs: #()! !

!OMeta2Base class methodsFor: 'matching' stamp: 'pb 3/14/2016 02:39'!
   matchAll: aSequenceableCollection with: aRule withArgs: args
	"Recommended for use with unstructured data (i.e. strings and simple arrays)"
	^ self matchStream: aSequenceableCollection readStream with: aRule withArgs: args withPlaybackDebugging: false! !

!OMeta2Base class methodsFor: 'matching' stamp: 'tak 4/7/2009 14:58'!
                          matcherOn: aReadStream

	| input matcher |
	input := OM2LazyStream for: aReadStream withPos: 1.
	matcher := self new initInput: input.
	^ matcher! !

!OMeta2Base class methodsFor: 'private-ometa2preload' stamp: 'aw 2/27/2009 14:14'!
                       matchStream: aReadStream with: aRule withArgs: args withPlaybackDebugging: debugging

	| input matcher ans|
	input := OM2LazyStream for: aReadStream withPos: 1.
	matcher := self new initInput: input.
	[
		matcher apply: #empty withArgs: args.
		ans := matcher apply: aRule.
		matcher apply: #end.
		^ ans
	] on: OM2Fail do: [:e |
		| curr prev prevPrev |
		debugging ifFalse: [e signal].
		curr := input.
		prev := nil.
		prevPrev := nil.
		[curr notNil] whileTrue: [
			prevPrev := prev.
			prev := curr.
			curr := curr basicTail
		].
		curr := prevPrev ifNotNil: [prevPrev] ifNil: [prev].
		"fixme - does this add any value?
		self inform: 'will halt each time matcher reaches ', curr printString.
		"
		matcher
			initInput: input;
			forgetEverything.
		curr ifNil: [self error: 'you''ve found a bug -- please report it'].
		curr become: (OM2StreamDebugger for: curr copy).
		matcher haltingPoint: curr.
		matcher apply: #empty withArgs: args.
		ans := matcher apply: aRule.
		matcher apply: #end.
		^ ans
	]! !

!OMeta2Base class methodsFor: 'private-ometa2preload' stamp: 'pb 6/08/2015 15:45'!
                   ometa2FlattenerClass
	^ OMeta2Flattener! !

!OMeta2Base class methodsFor: 'private-ometa2preload' stamp: 'pb 6/08/2015 15:45'!
 ometa2OptimizerClass
	^ OMeta2Optimizer! !

!OMeta2Base class methodsFor: 'private-ometa2preload' stamp: 'pb 6/08/2015 15:45'!
 ometa2RuleParserClass
	^ OMeta2RuleParser! !

!OMeta2Base class methodsFor: 'private-ometa2preload' stamp: 'pb 6/08/2015 15:45'!
                               ometa2RuleTranslatorClass
	^ OMeta2RuleTranslator! !

!OMeta2Base class methodsFor: 'accessing' stamp: 'aw 2/20/2009 14:52'!
   compilerClass
        ^ OMeta2Compiler! !


Compiler subclass: #OMeta2Compiler
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!

!OMeta2Compiler methodsFor: 'private-ometa2preload' stamp: 'aw 2/18/2009 16:30'!
                          compile: origCode in: cls classified: aCategory notifying: notify ifFail: failBlock

	^ self compile: origCode in: cls notifying: notify ifFail: failBlock! !

!OMeta2Compiler methodsFor: 'private-ometa2preload' stamp: 'aw 5/20/2009 12:57'!
                compile: origCode in: cls notifying: notify ifFail: failBlock

	| origCodeStream parseTree structuredCode translatedCode |
	origCodeStream := origCode asString readStream.
	self from: origCodeStream class: cls context: nil notifying: notify.
	[
		parseTree := cls ometa2RuleParserClass matchStream: origCodeStream with: #rule withArgs: #() withPlaybackDebugging: false.
		parseTree := cls ometa2OptimizerClass match: parseTree with: #optimizeRule.
		structuredCode := cls ometa2RuleTranslatorClass match: parseTree with: #translate withArgs: {cls}.
		translatedCode := cls ometa2FlattenerClass match: structuredCode with: #flatten
	] on: OM2Fail do: [
		self notify: '<-- parse error around here -->' at: origCodeStream position.
		^ failBlock value
	].
	^ Compiler new
		compile: translatedCode readStream
		in: cls
		notifying: notify
		ifFail: failBlock! !

!OMeta2Compiler methodsFor: 'private-ometa2preload' stamp: 'aw 2/27/2009 13:11'!
                  parse: aStream class: aClass noPattern: noPattern context: ctxt notifying: req ifFail: aBlock

	^ [
		| parseTree structuredCode code node |
		parseTree := aClass ometa2RuleParserClass matchAll: aStream contents with: #rule.
		structuredCode := aClass ometa2RuleTranslatorClass match: parseTree with: #translate withArgs: {aClass}.
		code := aClass ometa2FlattenerClass match: structuredCode with: #flatten.
		node := Parser new parse: code readStream class: aClass noPattern: noPattern context: ctxt notifying: req ifFail: aBlock.
		OMeta2MethodNode adoptInstance: node.
		node
	] on: OM2Fail do: [aBlock value]! !

!OMeta2Compiler methodsFor: 'private-ometa2preload' stamp: 'hmm 5/24/2010 10:51'!
     parser
        ^ self parserClass new! !

!OMeta2Compiler methodsFor: 'private-ometa2preload' stamp: 'aw 2/27/2009 13:10'!
     parserClass

	^ self class! !

!OMeta2Compiler commentStamp: '<historical>' prior: 0!
          I provide the interface that the Smalltalk environment expects.  In turn, I call out to various OMeta parsers that actually perform the compilation.

I use the indirection provided by OMeta2 class methods to allow for overriding of various functionality and make things a bit easier when trying out new extensions and optimization ideas for OMeta.!

OMeta2Compiler class
	instanceVariableNames: ''!

!OMeta2Compiler class methodsFor: '*OMeta2Extensions' stamp: 'pb 6/22/2015 20:01'!
                             textStylerClass
	^ SHTextStylerOMeta2! !


OMeta2 subclass: #OMeta2Debug
	instanceVariableNames: 'om2ApplyPc om2ApplyWithArgsPc om2DebugRoot om2Eos om2TraceLog om2Trans om2TransId'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Extensions'!

!OMeta2Debug methodsFor: 'ometa grammar' stamp: 'pb 10/1/2017 15:25:03'!
                    apply: aRule
	input class = OM2EndOfStream ifTrue: [
		om2Eos > 100000
			ifTrue: [ OMeta2DebugError new signal: 'Infinite recursion detected'
				"There's a good possibility that there is a rule with optional arity (i.e. using * and/or ?) that is being matched even though we are at the end of the input stream." ]
			ifFalse: [ om2Eos := om2Eos + 1 ]].
	om2ApplyPc
		at: aRule
		put:
			(om2ApplyPc
				at: aRule
				ifAbsentPut: [ 0 ]) + 1.
	^ super apply: aRule.! !

!OMeta2Debug methodsFor: 'ometa grammar' stamp: 'pb 10/1/2017 15:25:24'!
apply: aRule withArgs: args
	om2ApplyWithArgsPc
		at: aRule
		put:
			(om2ApplyWithArgsPc
				at: aRule
				ifAbsentPut: [ 0 ]) + 1.
	^ super
		apply: aRule
		withArgs: args.! !

!OMeta2Debug methodsFor: 'ometa grammar' stamp: 'pb 6/12/2015 14:58'!
       seq
	| xs |
	xs := self apply: #anything.
	[
	xs do: [ :x |
		" may want to inline #apply:withArgs: below as an
		  optimization, since this rule gets used a lot "
		self
			apply: #exactly
			withArgs: {x} ].
	^ xs ] on: Exception
		do: [ :e |
			(xs isKindOf: Collection)
				ifTrue: [ e signal
					"no idea what the problem is" ]
				ifFalse: [ OMeta2DebugError new signal: 'Not a sequence: ' , xs asString
					"we were probably passed in a character, number, etc..." ]].! !

!OMeta2Debug methodsFor: 'private' stamp: 'pb 10/1/2017 15:25:43'!
                            debugFinishTrans: name id: transId
	self debugShouldTrace ifTrue: [
		(om2Trans at: transId)
			
				at: 'matched'
				put: true;
			
				at: 'pos'
				put: self pos ].! !

!OMeta2Debug methodsFor: 'private' stamp: 'pb 6/15/2015 05:53'!
                   debugLogTrace
	om2TraceLog add: om2Trans.
	om2Trans := Dictionary new.! !

!OMeta2Debug methodsFor: 'private' stamp: 'pb 6/15/2015 05:03'!
                     debugShouldTrace
	^ false! !

!OMeta2Debug methodsFor: 'private' stamp: 'pb 10/1/2017 15:26:03'!
                               debugStartTrans: name
	self debugShouldTrace ifTrue: [
		om2TransId := om2TransId + 1.
		om2Trans
			at: om2TransId
			put:
				(Dictionary new
					
						at: 'rule'
						put: name;
					
						at: 'matched'
						put: false;
					yourself).
		^ om2TransId ].! !

!OMeta2Debug methodsFor: 'private' stamp: 'pb 10/1/2017 15:26:50'!
                   om2DebugPc
	^ Dictionary new
		
			at: 'applyPc'
			put: om2ApplyPc;
		
			at: 'applyWithArgsPc'
			put: om2ApplyWithArgsPc;
		yourself.! !

!OMeta2Debug methodsFor: 'private' stamp: 'pb 6/12/2015 07:17'!
                   om2DebugRoot: aRule
	om2DebugRoot := aRule! !

!OMeta2Debug methodsFor: 'initialization' stamp: 'pb 10/1/2017 15:26:31'!
       initialize
	super initialize.
	om2Eos := 0.
	om2ApplyPc := Dictionary new.
	om2ApplyWithArgsPc := Dictionary new.
	om2Trans := Dictionary new.
	om2TransId := 0.
	om2TraceLog := OrderedCollection new.! !

!OMeta2Debug commentStamp: '<historical>' prior: 0!
WORK IN PROGRESS... not ready for normal use!!

This is a debugging and profiling version of OMeta2.  It trades quite a bit of performance to try to detect and report known runtime errors and collect detailed statistics.  This is often worthwhile when initially designing and debugging a parser.

To use, simply set this class as your parser's parent class.  Once you're happy with how the parser is operating, feel free to change your parser's parent class back to OMeta2 to eliminate the runtime overhead.

todo: infinite recursion detection!

OMeta2Debug class
	instanceVariableNames: 'LastMatcher'!

!OMeta2Debug class methodsFor: 'accessing' stamp: 'pb 6/12/2015 06:20'!
                            lastMatcher
	^ LastMatcher! !

!OMeta2Debug class methodsFor: 'private' stamp: 'pb 6/12/2015 07:18'!
                           matchStream: aReadStream with: aRule withArgs: args withPlaybackDebugging: debugging
	| input matcher ans |
	input := OM2LazyStream
		for: aReadStream
		withPos: 1.
	matcher := self new initInput: input.
	matcher om2DebugRoot: aRule.
	LastMatcher := matcher.
	[
	matcher
		apply: #empty
		withArgs: args.
	ans := matcher apply: aRule.
	matcher apply: #end.
	^ ans ]
		on: OM2Fail
		do: [ :e | | curr prev prevPrev |
			debugging ifFalse: [ e signal ].
			curr := input.
			prev := nil.
			prevPrev := nil.
			[ curr notNil ] whileTrue: [
				prevPrev := prev.
				prev := curr.
				curr := curr basicTail ].
			curr := prevPrev
				ifNil: [ prev ]
				ifNotNil: [ prevPrev ].
			"fixme - does this add any value?
		self inform: 'will halt each time matcher reaches ', curr printString.
		"
			matcher
				initInput: input;
				forgetEverything.
			curr ifNil: [ self error: 'you''ve found a bug -- please tell Alex' ].
			curr become: (OM2StreamDebugger for: curr copy).
			matcher haltingPoint: curr.
			matcher
				apply: #empty
				withArgs: args.
			ans := matcher apply: aRule.
			matcher apply: #end.
			Transcript
				show: matcher om2DebugPc asString;
				finishEntry.
			^ ans ].! !

!OMeta2Debug class methodsFor: 'private' stamp: 'pb 2/3/2016 21:33'!
                  ometa2RuleTranslatorClass
	^ OMeta2DebugRuleTranslator.! !

!OMeta2DebugError commentStamp: '<historical>' prior: 0!
           This is so we can determine debug vs. regular OMeta runtime errors!

OMeta2RuleTranslator subclass: #OMeta2DebugRuleTranslator
	instanceVariableNames: 'transLogId transLog tempSequenceId'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Extensions'!

!OMeta2DebugRuleTranslator methodsFor: 'private' stamp: 'pb 6/20/2016 21:54'!
        debugNextSequenceId
	"Some generated debugging code requires unique generated names in the event of nesting... a sequence provides uniqueness."
	^ tempSequenceId  := tempSequenceId + 1! !

!OMeta2DebugRuleTranslator methodsFor: 'private' stamp: 'pb 6/9/2016 18:38'!
                      debugWrapRule: rule body: body
	^ {'debugTmpTransId:=self debugStartTrans: #'. rule . '.
debugTmpResult :='. body. '.
self debugFinishTrans: #'. rule. ' id: debugTmpTransId.
^ debugTmpResult'}.! !

!OMeta2DebugRuleTranslator methodsFor: 'private' stamp: 'pb 6/20/2016 23:26'!
            form =
// FIXME - doing it here so that #form: doesn't need to know about debug transactions...
// Form is a sort of built-in sub-rule that can be useful to trace when troubleshooting with structured data
//	trans:x -> [{'(self form: ['. x. '])'}]
	[self debugNextSequenceId asString]:ftId
	trans:x -> [{'[|fresult',ftId,' ftr',ftId,'|
			ftr',ftId,' := self debugStartTrans: #subRuleForm.
			fresult',ftId,':=(self form: ['. x. ']).
			self debugFinishTrans: #subRuleForm id: ftr',ftId,'.
			fresult',ftId,'] value'}]! !

!OMeta2DebugRuleTranslator methodsFor: 'private' stamp: 'pb 6/15/2015 04:00'!
       rule =

	symbol:name
	anything:temps [temps select: [:t | (grammarClass instVarNames includes: t) not]]:temps
	trans:body
	-> [{name. ' | debugTmpResult debugTmpTransId '. self delim: temps asSortedCollection with: ' '. ' | '. self debugWrapRule: name body: body}]! !

!OMeta2DebugRuleTranslator methodsFor: 'initialization' stamp: 'pb 6/20/2016 21:52'!
                              initialize
	super initialize.
	tempSequenceId := 0.
	transLog := OrderedCollection new.
	transLogId := 1.! !

!OMeta2DebugRuleTranslator commentStamp: '<historical>' prior: 0!
                WORK IN PROGRESS... not ready for normal use!!!

OMeta2Debug subclass: #OMeta2ExtendedParser
	instanceVariableNames: 'ast curNode temps blockLevel'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Extensions'!

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/25/2015 06:45'!
                     application =

	@<"^" name:rule>:superIdx args:as	-> [(self newNode: #SuperApp)
				properties: {#op -> rule.
							#args -> as.
							self newRange: superIdx type: #blockTempVar};
				yourself]
										//-> [{#SuperApp. rule}, as]
|	@<name:grm $. nsName:rule>:app1Idx	 @<args:as>:app2Idx -> [(self newNode: #App)
				properties: {#op -> #foreign.
					#parm -> grm.
					#huh1 -> ('#', rule) asSymbol.
					#huh2 -> as.
					self newRange: app1Idx type: #blockTempVar with: app2Idx type: #externalFunctionCallingConvention}]
										//-> [{#App. #foreign. grm. ('#', rule) asSymbol}, as]
|	@<name:rule>:app1Idx @<args:as>:app2Idx					-> [(self newNode: #App)
				properties: { #op -> rule.
					#parm -> as.
					self newRange: app1Idx type: #blockTempVar with: app2Idx type: #externalFunctionCallingConvention}]
										//-> [{#App. rule}, as]! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/17/2015 19:43'!
                             args =
	// fixme - best way to style?
	$( listOf(#squeakExpression. '.'):ans ")" -> [ans]
|	~$( -> [#()]! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/26/2015 01:45'!
          blockEnter
	blockLevel := blockLevel+1.
	"Transcript show: 'bl: ', blockLevel asString; finishEntry"! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/25/2015 01:18'!
              blockLevelAndLeave
	| retVal |
	retVal _ #blockStart1.
	blockLevel > 1 ifTrue: [
		blockLevel > 2
			ifTrue: [
				blockLevel > 3
					ifTrue: [ retVal _ #blockStart4 ]
					ifFalse: [ retVal _ #blockStart3 ]]
			ifFalse: [ retVal _ #blockStart2 ]].
	blockLevel _ blockLevel - 1.
	^ retVal.! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/17/2015 17:27'!
                characterLiteral =

	@<spaces $$ char:c>:cIdx -> [(self newNode: #App) properties: { #op -> #exactly.
																#parm -> c storeString.
																self newRange: cIdx type: #character}]
					//-> [{#App. #exactly. c storeString}]! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/17/2015 19:29'!
  characters =

	@<"``" (~($' $') char)*:xs $' $'>:charIdx -> [(self newNode: #App) properties:
							{ #op -> #seq.
							#parm -> (String withAll: xs) storeString.
							self newRange:  charIdx type: #character}]
							//-> [{#App. #seq. (String withAll: xs) storeString}]! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/17/2015 19:36'!
                              expr =
	// Wrap the sub-expressions with an 'or'.  If it's not needed, we'll optimize it away later.
	// fixme - how to best highlight OR...
	listOf(#expr4. '|'):xs -> [(self newNode: #Or) addChildren: xs]
					//-> [(OrderedCollection with: #Or) addAll: xs; yourself]! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 8/19/2016 20:43:04'!
   expr1 =
	// Handle any syntactic sugar and parse the final expression
	@<(keyword('true') | keyword('false') | keyword('nil')):lit>:litIdx
						-> [(self newNode: #App) properties: {#op -> #exactly. #parm -> lit. self newRange: litIdx type: #nil}]
						//-> [{#App. #exactly. lit}]
|	application
|	semanticAction
|	semanticPredicate
|	characters
|	tokenSugar
|	stringLiteral
|	symbolLiteral
|	numberLiteral
|	characterLiteral
|	@<"{">:blkStart [self blockEnter]  expr:e @<"}">:blkEnd
					-> [(self newNode: #Form) properties: {#op -> e.
											self newRange: blkStart and: blkEnd type: self blockLevelAndLeave}]
											/*self newRange: blkStart and: blkEnd type: #blockStart1}]*/
						//-> [{#Form. e}]
|	@<"<">:blkStart [self blockEnter]  expr:e @<">">:blkEnd
				 	-> [(self newNode: #ConsBy) properties: {#op -> e.
											self newRange: blkStart and: blkEnd type: self blockLevelAndLeave}]
											/*self newRange: blkStart and: blkEnd type: #blockStart3}]*/
						//-> [{#ConsBy. e}]
|	@<"@<">:blkStart [self blockEnter] expr:e @<">">:blkEnd
				 	-> [(self newNode: #IdxConsBy) properties: {#op -> e.
											self newRange: blkStart and: blkEnd type: self blockLevelAndLeave}]
											/*self newRange: blkStart and: blkEnd type: #blockStart2}]*/
						//-> [{#IdxConsBy. e}]
|	@<"(">:blkStart expr:e @<")">:blkEnd -> [e] // fixme - syntax highlighting! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/25/2015 06:29'!
             expr2 =
	// Handle lookahead
	@<"~">:xIdx expr2:x -> [(self newNode: #Not) properties: {#op -> x. self newRange: xIdx type: #blockArg}] //-> [{#Not. x}]
|	@<"&">:xIdx expr2:x -> [(self newNode: #Lookahead) properties: {#op -> x. self newRange: xIdx type: #blockArg}] //-> [{#Lookahead. x}]
|	expr1! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/25/2015 06:02'!
         expr3 =
	// Handle arity and variable assignment
	expr2:x optIter(x):x
		(	$: @<nsName:n>:tmpIdx [temps add: n] -> [(self newNode: #Set) properties: {#op -> n. #parm -> x. self newRange: tmpIdx type: #tempVar}]
										 //-> [{#Set. n. x}]
		|	empty						-> [x]
		)
|	":" nsName:n [temps add: n] -> [(self newNode: #Set) properties: {#op -> n};
										addChild: ((self newNode: #App) properties: {#op -> #anything})]
									 //-> [{#Set. n. {#App. #anything}}]! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/13/2015 20:00'!
                               expr4 =
	// Wrap related rule sub-expressions with an 'and'.  If it's not needed, we'll optimize it away later
	expr3*:xs -> [(self newNode: #And) addChildren: xs]
			//-> [(OrderedCollection with: #And) addAll: xs; yourself]! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/25/2015 00:43'!
                 initialize
	super initialize.
	ast := self newNode: #rule.
	blockLevel := 0.
	curNode := ast.
	curNode properties at: #comments put: OrderedCollection new.
	temps := IdentitySet new.! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/13/2015 06:31'!
                            keyword :xs =

	token(xs) ~letterOrDigit -> [xs]! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/12/2015 19:19'!
  name =

	spaces nsName! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/12/2015 19:19'!
                            nameFirst =

	letter! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/12/2015 19:19'!
                              nameRest =

	nameFirst | digit! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/14/2015 17:29'!
                    newNode: nodeType
	^ SyntaxTreeNode node: nodeType.! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/17/2015 19:58'!
                               newRange: assoc and: otherAssoc type: type
	"create assoc to be use as a range property.  this currently covers every use case except comments in the space rule.  fixme... not currently used"
	| passoc |
	passoc := (self newRange: assoc type: type).
	passoc value add: (SHRange start: otherAssoc key end: otherAssoc value -1 type: type); yourself.
	^ passoc
! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/17/2015 02:26'!
            newRange: assoc type: type
	"create assoc to be use as a range property.  this currently covers every use case except comments in the space rule"
	"#rangeIdxList -> (OrderedCollection new add: (SHRange start: app2Idx key end: app2Idx value type: #key); yourself)"
	^ #rangeIdxList ->
		(OrderedCollection new
			add:
				(SHRange
					start: assoc key
					end: assoc value - 1
					type: type);
			yourself).! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/25/2015 06:41'!
                         newRange: assoc type: type with: assoc2 type: type2
	"create assoc to be use as a range property.  this currently covers every use case except comments in the space rule"
	"#rangeIdxList -> (OrderedCollection new add: (SHRange start: app2Idx key end: app2Idx value type: #key); yourself)"
	^ #rangeIdxList ->
		(OrderedCollection new
			add:
				(SHRange
					start: assoc key
					end: assoc value - 1
					type: type);
			add:
				(SHRange
					start: assoc2 key
					end: assoc2 value - 1
					type: type2);
			yourself).! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/13/2015 21:17'!
      nsName =

	firstAndRest(#nameFirst. #nameRest):xs -> [(String withAll: xs) asSymbol]
|	$_ -> [#anything]
! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/17/2015 17:14'!
         numberLiteral =

	@<spaces ($- spaces -> [-1] | empty -> [1]):sign digit+:ds>:numIdx
		-> [(self newNode: #App) properties: {#op -> #exactly.
				#parm -> (sign * (String withAll: ds) asNumber) storeString.
				self newRange: numIdx type: #number}]
		//-> [{#App. #exactly. (sign * (String withAll: ds) asNumber) storeString}]! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/17/2015 16:51'!
            optIter :x =

	@<"*">:arManyIdx		-> [(self newNode: #Many) properties: {#parm -> x.
																	self newRange: arManyIdx type: #blockArg}]
			//-> [{#Many.  x}]
|	@<"+">:arMany1Idx		-> [(self newNode: #Many1) properties: {#parm -> x.
																	self newRange: arMany1Idx type: #blockArg}]
			//-> [{#Many1. x}]
|	@<"?">:arOptIdx ~$[	-> [(self newNode: #Opt) properties: {#parm -> x.
																	self newRange: arOptIdx type: #blockArg}]
			//-> [{#Opt. x}]
|	empty	-> [x]! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/17/2015 22:42'!
           rulePart :ruleName =
	// testing
	[nil]:retVal
	@<name:n ?[n = ruleName] expr4:b1>:nIdx -> [[curNode properties: {self newRange: nIdx type: #keyword}. retVal] value]
		(	@<"=">:nIdx2 expr:b2	-> [[((curNode properties at: #rangeIdxList) at: 1) end: nIdx2 value. retVal := (self newNode: #And) addChild: b1; addChild: b2] value] // nIdx2 is a hack to get to the '='.  Highly non-optimal as we really want params highlighted in a different style anyway
							//-> [{#And. b1. b2}]
		|	empty			-> [retVal := curNode addChild: b1]
							// [b1]
		)! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/17/2015 19:59'!
                 semanticAction =

	@<"->"? "[">:saIdx1 squeakExpression:e @<$]>:saIdx2 -> [(self newNode: #Act) properties: {#op -> e. self newRange: saIdx1 and: saIdx2 type: #patternArg}]
									//-> [{#Act. e}]! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/17/2015 20:00'!
            semanticPredicate =

	@<"?[">:spIdx1 squeakExpression:e @<$]>:spIdx2 -> [(self newNode: #Pred) properties: {#op -> e. self newRange: spIdx1 and: spIdx2 type: #patternArg}]
								//-> [{#Pred. e}]! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/17/2015 02:26'!
             space =

	^space
	| @<fromTo('/*'. '*/')>:longCommentIdx -> [(curNode properties at: #comments) add: (SHRange start: longCommentIdx key end: longCommentIdx value - 1 type: #comment)]
	| @<fromToEnd('//')>:commentIdx -> [(curNode properties at: #comments) add: (SHRange start: commentIdx key end: commentIdx value - 1 type: #comment)]! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/17/2015 17:16'!
     squeakExpression = @<O2SqueakRecognizer.squeakExpr:ans>:sqIdx spaces
							-> [(self newNode: #Smalltalk) properties: {#parm -> ans.
									self newRange: sqIdx type: #externalFunctionCallingConvention}]
							//-> [ans]! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/17/2015 19:30'!
                  stringLiteral =

	@<"'" ($' $' -> [$'] | ~$' char)*:xs $'>:strIdx -> [(self newNode: #App) properties: 											{#op -> #exactly.
											 #parm ->  (String withAll: xs) storeString.
											self newRange: strIdx type: #text}]
									//-> [{#App. #exactly. (String withAll: xs) storeString}]! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/25/2015 00:40'!
     symbolLiteral =

	// TODO: make this accept, e.g., #foo:bar:
	@<"#" nsName:s>:symIdx -> [(self newNode: #App) properties: {#op -> #exactly.
											#parm -> s storeString. self newRange: symIdx type: #symbol}]
				//-> [{#App. #exactly. s storeString}]! !

!OMeta2ExtendedParser methodsFor: 'private' stamp: 'pb 6/17/2015 16:48'!
                   tokenSugar =

	@<token('"') (~$" char)*:xs $">:tokIdx -> [(self newNode: #App) properties: {#op -> #token.
															#parm -> (String withAll: xs) storeString.
															self newRange: tokIdx type: #stringSymbol}]
							//-> [{#App. #token. (String withAll: xs) storeString}]! !

!OMeta2ExtendedParser methodsFor: 'grammar' stamp: 'pb 6/16/2015 23:10'!
                    isSmalltalkCode = ~(^space* nsName expr4 "=") <char*>:squeakCode -> [true]
		|	anything* -> [false]
		// fixme - inefficient way to test! !

!OMeta2ExtendedParser methodsFor: 'grammar' stamp: 'pb 6/17/2015 04:14'!
          rule = ~(^space* nsName expr4 "=") <char*>:squeakCode -> [self newNode: #Squeak]
											//-> [{#Squeak. squeakCode}]
											// This isn't OMeta code so we'll handoff to Squeak when the time comes
|	&(^space* nsName):n rulePart(n):x ("," rulePart(n))*:xs spaces end
		-> [ curNode := (curNode node: #Rule) properties: {#temps -> temps asSortedCollection.
					#n -> n};
					addChild: ((self newNode: #Or) addChild: x; addChildren: xs)]
		//-> [{#Rule. n. temps asSortedCollection. (OrderedCollection with: #Or with: x) addAll: xs; yourself}]
! !

!OMeta2ExtendedParser commentStamp: '<historical>' prior: 0!
                        WORK IN PROGRESS... not ready for normal use!!

This is a more full-featured OMeta parser that renders to a labelled syntax tree.  While significantly larger than the default parser, it will allow for much more flexibility.

Open issues:
- should I even be trying to re-use Smalltalk themes?  There is no clean mapping so even if we do it, using other themes may look unacceptably bad.
- need to finalize approach: extend existing ast or go with a more annotated version?!

OMeta2ExtendedParser class
	instanceVariableNames: ''!

!OMeta2ExtendedParser class methodsFor: 'private' stamp: 'pb 5/4/2016 15:10'!
rangesFor: source
	| result |
	(self
		matchAll: source
		with: #isSmalltalkCode)
		ifTrue: [ ^ nil ]
		ifFalse: [
			result := OrderedCollection new.
			(self
				matchAll: source
				with: #rule) do: [ :ea |
				self
					recurseForRanges: ea
					into: result ].
			^ result sort: [ :a :b |
				a start < b start ]].! !

!OMeta2ExtendedParser class methodsFor: 'private' stamp: 'pb 6/25/2015 05:10'!
             recurseForRanges: ea into: result
	| p |
	p := ea properties.
	p
		at: #rangeIdxList
		ifPresent: [ :ranges |
			result addAll: ranges ].
	p
		at: #comments
		ifPresent: [ :ranges |
			result addAll: ranges ].
	p
		at: #op
		ifPresent: [ :op |
			(op isKindOf: SyntaxTreeNode) ifTrue: [
				op do: [ :opNode |
					self
						recurseForRanges: opNode
						into: result ]]].
	p
		at: #parm
		ifPresent: [ :parm |
			(parm isKindOf: SyntaxTreeNode) ifTrue: [
				parm do: [ :parmNode |
					self
						recurseForRanges: parmNode
						into: result ]]].
	result.! !

!OMeta2ExtendedParser class methodsFor: 'private-wip' stamp: 'pb 5/4/2016 15:10'!
                         scratchParserNew
	^ self matchAll: ((self methodDict at: #rulePart) getSource) with: #rule! !

!OMeta2ExtendedParser class methodsFor: 'private-wip' stamp: 'pb 5/4/2016 15:10'!
               scratchParserStock
	"Stock OMeta rule parser"
	^ self
		matchAll: (self methodDict at: #rulePart) getSource
		with: #rule.! !

!OMeta2ExtendedParser class methodsFor: 'private-wip' stamp: 'pb 5/4/2016 15:11'!
               scratchRecurseSHRange
	| recurseForRanges result |
	result := OrderedCollection new.
	recurseForRanges := [ :ea :useResult | | p |
	p := ea properties.
	p
		at: #rangeIdxList
		ifPresent: [ :ranges |
			useResult addAll: ranges ].
	useResult ].
	self demo do: [ :ea | | p |
		p := ea properties.
		p
			at: #rangeIdxList
			ifPresent: [ :ranges |
				result addAll: ranges ].
		p at: #comments ifPresent: [:ranges|
			result addAll: ranges].
		p
			at: #op
			ifPresent: [ :op |
				(op isKindOf: SyntaxTreeNode) ifTrue: [
					recurseForRanges
						value: op
						value: result ]].
		p
			at: #parm
			ifPresent: [ :parm |
				(parm isKindOf: SyntaxTreeNode) ifTrue: [
					recurseForRanges
						value: parm
						value: result ]].
		result ].
	^ result sort: [:a :b| a start<b start].! !


OMeta2 subclass: #OMeta2Flattener
	instanceVariableNames: 'ws'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2'!

!OMeta2Flattener methodsFor: 'grammar root' stamp: 'pb 5/22/2015 18:40'!
                         flatten :tree =

	iFlatten(tree) -> [ws contents]! !

!OMeta2Flattener methodsFor: 'private' stamp: 'pb 5/22/2015 18:41'!
      iFlatten =

	string:s 	[ws nextPutAll: s]
|	{iFlatten*}! !

!OMeta2Flattener methodsFor: 'initialization' stamp: 'aw 2/18/2009 15:05'!
                         initialize

	super initialize.
	ws := (String new: 64) writeStream! !

!OMeta2Flattener commentStamp: '<historical>' prior: 0!
 OMeta2Flattener is phase 4 of OMeta code compilation.  I take the rendered code tree produced by phase 3 and flatten it into a single string of source code that will be passed to the Smalltalk compiler or parser.

OMeta implementation!

MethodNode subclass: #OMeta2MethodNode
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!

!OMeta2MethodNode methodsFor: 'debugger support' stamp: 'hmm 8/25/2012 14:28'!
                       schematicTempNamesString
        "The decompiler wants a list of temp names. However, this mechanism depends on a number of assumptions that do not hold with OMeta2 generated methods. Therefore we simply skip the temp names, letting the decompiler build generic ones.

This fixes an error when attempting to prettyPrint OMeta source code. (prettyPrint reveals the actual Smalltalk code generated by OMeta)"
        ^nil! !


OMeta2 subclass: #OMeta2NullOpt
	instanceVariableNames: 'didSomething'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2'!

!OMeta2NullOpt methodsFor: 'private' stamp: 'aw 5/20/2009 12:44'!
          and = trans*:xs -> [xs addFirst: #And; yourself]! !

!OMeta2NullOpt methodsFor: 'private' stamp: 'aw 5/20/2009 12:44'!
         consby = trans:x -> [{#ConsBy. x}]! !

!OMeta2NullOpt methodsFor: 'private' stamp: 'aw 5/20/2009 12:44'!
                       form = trans:x -> [{#Form. x}]! !

!OMeta2NullOpt methodsFor: 'private' stamp: 'aw 5/20/2009 12:01'!
                           helped = ?[didSomething]! !

!OMeta2NullOpt methodsFor: 'private' stamp: 'aw 5/20/2009 12:44'!
 idxconsby = trans:x -> [{#IdxConsBy. x}]! !

!OMeta2NullOpt methodsFor: 'private' stamp: 'aw 5/20/2009 12:44'!
                 lookahead = trans:x -> [{#Lookahead. x}]! !

!OMeta2NullOpt methodsFor: 'private' stamp: 'aw 5/20/2009 12:44'!
                 many = trans:x -> [{#Many. x}]! !

!OMeta2NullOpt methodsFor: 'private' stamp: 'aw 5/20/2009 12:44'!
                           many1 = trans:x -> [{#Many1. x}]! !

!OMeta2NullOpt methodsFor: 'private' stamp: 'aw 5/20/2009 12:45'!
                         not = trans:x -> [{#Not. x}]! !

!OMeta2NullOpt methodsFor: 'private' stamp: 'aw 5/20/2009 12:45'!
                             opt = trans:x -> [{#Opt. x}]! !

!OMeta2NullOpt methodsFor: 'private' stamp: 'aw 5/20/2009 12:45'!
                             or = trans*:xs -> [xs addFirst: #Or; yourself]! !

!OMeta2NullOpt methodsFor: 'private' stamp: 'aw 5/20/2009 12:45'!
           rule = _:name _:temps trans:body -> [{#Rule. name. temps. body}]! !

!OMeta2NullOpt methodsFor: 'private' stamp: 'aw 5/20/2009 12:45'!
                         set = _:name trans:val -> [{#Set. name. val}]! !

!OMeta2NullOpt methodsFor: 'private' stamp: 'aw 5/20/2009 12:00'!
            setHelped = [didSomething := true]! !

!OMeta2NullOpt methodsFor: 'private' stamp: 'aw 5/20/2009 12:42'!
                       trans =

	{:t [t asLowercase asSymbol]:t ?[self class canUnderstand: t] apply(t):ans} -> [ans]
|	_! !

!OMeta2NullOpt methodsFor: 'initialization' stamp: 'aw 5/20/2009 12:30'!
                initialize

	super initialize.
	didSomething := false! !

!OMeta2NullOpt methodsFor: 'grammar root' stamp: 'aw 5/20/2009 12:02'!
                               optimize = trans:x helped -> [x]! !

!OMeta2NullOpt commentStamp: '<historical>' prior: 0!
     Base syntax tree grammar to perform code transformations. Currrently not used directly as its subclass, OMeta2AndOrOpt, is called during phase 2.

OMeta implementation!

OMeta2 subclass: #OMeta2Optimizer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2'!

!OMeta2Optimizer methodsFor: 'grammar root' stamp: 'pb 6/7/2015 17:47'!
             optimizeRule = _:ans (OMeta2AndOrOpt.optimize(ans):ans)* -> [ans]! !

!OMeta2Optimizer commentStamp: '<historical>' prior: 0!
  OMeta2Optimizer is phase 2 of OMeta code compilation.  I take the parse tree from phase 1 and apply an syntax tree grammar (OMeta2AndOrOpt) which looks for any obvious and/or transformations to produce a simplified syntax tree.

fixme - clean up comment.

OMeta implementation!

OMeta2 subclass: #OMeta2RuleParser
	instanceVariableNames: 'temps'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2'!

!OMeta2RuleParser methodsFor: 'private' stamp: 'pb 5/22/2015 18:59'!
                             application =

	"^" name:rule args:as				-> [{#SuperApp. rule}, as]
|	name:grm $. nsName:rule args:as	-> [{#App. #foreign. grm. ('#', rule) asSymbol}, as]
|	name:rule args:as						-> [{#App. rule}, as]! !

!OMeta2RuleParser methodsFor: 'private' stamp: 'pb 5/22/2015 19:00'!
             args =

	$( listOf(#squeakExpression. '.'):ans ")" -> [ans]
|	~$( -> [#()]! !

!OMeta2RuleParser methodsFor: 'private' stamp: 'pb 5/22/2015 19:00'!
            characterLiteral =

	spaces $$ char:c -> [{#App. #exactly. c storeString}]! !

!OMeta2RuleParser methodsFor: 'private' stamp: 'pb 5/22/2015 19:01'!
            characters =

	"``" (~($' $') char)*:xs $' $' -> [{#App. #seq. (String withAll: xs) storeString}]! !

!OMeta2RuleParser methodsFor: 'private' stamp: 'pb 6/11/2015 19:05'!
                     expr =
	// Wrap the sub-expressions with an 'or'.  If it's not needed, we'll optimize it away later.
	listOf(#expr4. '|'):xs -> [(OrderedCollection with: #Or) addAll: xs; yourself]! !

!OMeta2RuleParser methodsFor: 'private' stamp: 'pb 6/11/2015 18:56'!
  expr1 =
	// Handle any syntactic sugar and parse the final expression
	(keyword('true') | keyword('false') | keyword('nil')):lit -> [{#App. #exactly. lit}]
|	application
|	semanticAction
|	semanticPredicate
|	characters
|	tokenSugar
|	stringLiteral
|	symbolLiteral
|	numberLiteral
|	characterLiteral
|	"{"  expr:e "}" -> [{#Form. e}]
|	"<"  expr:e ">" -> [{#ConsBy. e}]
|	"@<" expr:e ">" -> [{#IdxConsBy. e}]
|	"("  expr:e ")" -> [e]! !

!OMeta2RuleParser methodsFor: 'private' stamp: 'pb 6/11/2015 18:49'!
     expr2 =
	// Handle lookahead
	"~" expr2:x -> [{#Not. x}]
|	"&" expr2:x -> [{#Lookahead. x}]
|	expr1! !

!OMeta2RuleParser methodsFor: 'private' stamp: 'pb 6/11/2015 18:49'!
                   expr3 =
	// Handle arity and variable assignment
	expr2:x optIter(x):x
		(	$: nsName:n [temps add: n]	-> [{#Set. n. x}]
		|	empty								-> [x]
		)
|	":" nsName:n [temps add: n]			-> [{#Set. n. {#App. #anything}}]! !

!OMeta2RuleParser methodsFor: 'private' stamp: 'pb 6/11/2015 18:57'!
 expr4 =
	// Wrap related rule sub-expressions with an 'and'.  If it's not needed, we'll optimize it away later
	expr3*:xs -> [(OrderedCollection with: #And) addAll: xs; yourself]! !

!OMeta2RuleParser methodsFor: 'private' stamp: 'pb 5/22/2015 19:02'!
    keyword :xs =

	token(xs) ~letterOrDigit -> [xs]! !

!OMeta2RuleParser methodsFor: 'private' stamp: 'pb 5/22/2015 19:02'!
      name =

	spaces nsName! !

!OMeta2RuleParser methodsFor: 'private' stamp: 'pb 5/22/2015 19:03'!
nameFirst =

	letter! !

!OMeta2RuleParser methodsFor: 'private' stamp: 'pb 5/22/2015 19:03'!
  nameRest =

	nameFirst | digit! !

!OMeta2RuleParser methodsFor: 'private' stamp: 'pb 5/22/2015 19:03'!
                        nsName =

	firstAndRest(#nameFirst. #nameRest):xs -> [(String withAll: xs) asSymbol]
|	$_ -> [#anything]
! !

!OMeta2RuleParser methodsFor: 'private' stamp: 'pb 5/22/2015 19:04'!
             numberLiteral =

	spaces ($- spaces -> [-1] | empty -> [1]):sign digit+:ds
		-> [{#App. #exactly. (sign * (String withAll: ds) asNumber) storeString}]! !

!OMeta2RuleParser methodsFor: 'private' stamp: 'pb 5/22/2015 19:04'!
optIter :x =

	"*"		-> [{#Many.  x}]
|	"+"		-> [{#Many1. x}]
|	"?" ~$[	-> [{#Opt. x}]
|	empty		-> [x]! !

!OMeta2RuleParser methodsFor: 'private' stamp: 'pb 5/22/2015 19:05'!
                 rulePart :ruleName =

	name:n ?[n = ruleName] expr4:b1
		(	"=" expr:b2	-> [{#And. b1. b2}]
		|	empty			-> [b1]
		)! !

!OMeta2RuleParser methodsFor: 'private' stamp: 'pb 5/22/2015 19:05'!
    semanticAction =

	"->"? "[" squeakExpression:e $] -> [{#Act. e}]! !

!OMeta2RuleParser methodsFor: 'private' stamp: 'pb 5/22/2015 19:05'!
                     semanticPredicate =

	"?[" squeakExpression:e $] -> [{#Pred. e}]! !

!OMeta2RuleParser methodsFor: 'private' stamp: 'pb 6/5/2015 22:15'!
                       space =

	^space | fromTo('/*'. '*/') | fromToEnd('//')! !

!OMeta2RuleParser methodsFor: 'private' stamp: 'pb 6/7/2015 17:48'!
squeakExpression = O2SqueakRecognizer.squeakExpr:ans spaces -> [ans]! !

!OMeta2RuleParser methodsFor: 'private' stamp: 'pb 5/22/2015 19:06'!
                  stringLiteral =

	"'" ($' $' -> [$'] | ~$' char)*:xs $' -> [{#App. #exactly. (String withAll: xs) storeString}]! !

!OMeta2RuleParser methodsFor: 'private' stamp: 'pb 5/22/2015 19:06'!
       symbolLiteral =

	// TODO: make this accept, e.g., #foo:bar:
	"#" nsName:s -> [{#App. #exactly. s storeString}]! !

!OMeta2RuleParser methodsFor: 'private' stamp: 'pb 5/22/2015 19:07'!
       tokenSugar =

	token('"') (~$" char)*:xs $" -> [{#App. #token. (String withAll: xs) storeString}]! !

!OMeta2RuleParser methodsFor: 'initialization' stamp: 'aw 2/18/2009 15:04'!
              initialize

	super initialize.
	temps := IdentitySet new! !

!OMeta2RuleParser methodsFor: 'grammar root' stamp: 'pb 6/11/2015 19:04'!
                         rule =
	~(^space* nsName expr4 "=") <char*>:squeakCode -> [{#Squeak. squeakCode}] // This isn't OMeta code so we'll handoff to Squeak when the time comes
|	&(^space* nsName):n rulePart(n):x ("," rulePart(n))*:xs spaces end
		-> [{#Rule. n. temps asSortedCollection. (OrderedCollection with: #Or with: x) addAll: xs; yourself}]! !

!OMeta2RuleParser commentStamp: '<historical>' prior: 0!
                            OMeta2RuleParser is phase 1 of OMeta code compilation.  I take arbitrary source code and produce an syntax tree of raw operations in a Lispy nested list containing elements in the form #(arg1. arg2...) where:

arg1 is the OMeta primitive to perform (#Act, #And, #App, #ConsBy, #Form, #IdxConsBy, #Opt, #Or, #Lookahead, #Many, #Many1, #Not, #Pred, #Rule, #Set, #SuperApp) each corresponding to an OMeta primitive operation:
- #And and #Or correspond to Smalltalk #and: and #or:
- #Act and #Rule indicate a method call defined in arg2
- #Set indicates a collection (implemented as an array)
- #App, #ConsBy, #Form, #IdxConsBy, #Opt, #Lookahead, #Many, #Many1, #Not, #Pred and #SuperApp have corresponding methods in OMeta2Base

arg2 is either an operand for the atomic operation (an OMeta or application rule name or semantic predicate/action code snippet) or a list of child operations in the case of #And and #Or operations.

arg3, if it exists, is either an operand for the atomic operation (often an operand for the rule supplied in arg2 such as a string literal) or a list of child operations.

And so on... arg4 and greater occur in more complex #And and #Or lists or for rules/method calls requiring additional parameters passed.

The syntax tree produced represents the worst case application logic as no optmization is performed yet.  Stages 2 and 3 require this simple form to perform their transformations. (i.e. any changes/extensions here will have significant implications downstream)

OMeta implementation!

OMeta2RuleParser class
	instanceVariableNames: ''!

!OMeta2RuleParser class methodsFor: 'testing' stamp: 'aw 2/23/2009 10:07'!
                isOMeta2Rule: aString

	^ [(self matchAll: aString with: #rule) first ~= #Squeak] on: OM2Fail do: [false]! !


OMeta2 subclass: #OMeta2RuleTranslator
	instanceVariableNames: 'grammarClass'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2'!

!OMeta2RuleTranslator methodsFor: 'private' stamp: 'pb 5/22/2015 19:07'!
                      act = string:x -> [{'('. x. ')'}]! !

!OMeta2RuleTranslator methodsFor: 'private' stamp: 'pb 5/22/2015 19:08'!
                 and = trans*:xs -> [{'(true ifTrue: ['. self delim: xs with: '. '. '])'}]! !

!OMeta2RuleTranslator methodsFor: 'private' stamp: 'pb 6/9/2015 04:28'!
          app =
	symbol:rule
	(	anything+:args [self delim: args with: '. ']:args -> [{'(self apply: '. rule storeString. ' withArgs: {'. args. '})'}]
	|	[{'(self apply: '. rule storeString. ')'}]
	)
! !

!OMeta2RuleTranslator methodsFor: 'private' stamp: 'pb 5/22/2015 19:08'!
                    consby =

	trans:x -> [{'(self consumedBy: ['. x. '])'}]! !

!OMeta2RuleTranslator methodsFor: 'private' stamp: 'aw 2/18/2009 14:43'!
                          delim: aSequenceableCollection  with: anObject

	| first ans |
	
	first := true.
	ans := OrderedCollection new.
	aSequenceableCollection do: [:x |
		first ifTrue: [first := false] ifFalse: [ans add: anObject].
		ans add: x
	].
	^ ans! !

!OMeta2RuleTranslator methodsFor: 'private' stamp: 'pb 5/22/2015 19:09'!
         form =

	trans:x -> [{'(self form: ['. x. '])'}]! !

!OMeta2RuleTranslator methodsFor: 'private' stamp: 'pb 5/22/2015 19:09'!
  idxconsby =

	trans:x -> [{'(self indexConsumedBy: ['. x. '])'}]! !

!OMeta2RuleTranslator methodsFor: 'private' stamp: 'pb 5/22/2015 19:09'!
                  lookahead =

	trans:x -> [{'(self lookahead: ['. x. '])'}]! !

!OMeta2RuleTranslator methodsFor: 'private' stamp: 'pb 5/22/2015 19:10'!
                        many =

	trans:x -> [{'(self many: ['. x. '])'}]! !

!OMeta2RuleTranslator methodsFor: 'private' stamp: 'pb 5/22/2015 19:10'!
  many1 =

	trans:x -> [{'(self many1: ['. x. '])'}]! !

!OMeta2RuleTranslator methodsFor: 'private' stamp: 'pb 5/22/2015 19:10'!
not =

	trans:x -> [{'(self not: ['. x. '])'}]! !

!OMeta2RuleTranslator methodsFor: 'private' stamp: 'pb 5/22/2015 19:10'!
    opt =

	trans:x -> [{'(self opt: ['. x. '])'}]! !

!OMeta2RuleTranslator methodsFor: 'private' stamp: 'pb 5/22/2015 19:11'!
    or =

	(trans:x -> [{'['. x. ']'}])*:xs -> [{'(self ometaOr: {'. self delim: xs with: '. '. '})'}]! !

!OMeta2RuleTranslator methodsFor: 'private' stamp: 'pb 5/22/2015 19:11'!
                pred =

	string:x -> [{'(self pred: ('. x. '))'}]! !

!OMeta2RuleTranslator methodsFor: 'private' stamp: 'pb 6/24/2015 23:44'!
 rule =

	symbol:name
	anything:temps [temps select: [:t | (grammarClass instVarNames includes: t) not]]:temps
	trans:body
	-> [{name. '"Generated by OMeta... edit the rule, not this Smalltalk code"'. ' |'. self delim: temps asSortedCollection with: ' '. ' | ^ '. body}]! !

!OMeta2RuleTranslator methodsFor: 'private' stamp: 'pb 5/22/2015 19:12'!
     set =

	symbol:n trans:v -> [{'('. n asString. ' := '. v. ')'}]! !

!OMeta2RuleTranslator methodsFor: 'private' stamp: 'pb 5/22/2015 19:12'!
                   squeak = string! !

!OMeta2RuleTranslator methodsFor: 'private' stamp: 'pb 5/22/2015 19:12'!
   superapp =

	symbol:rule anything*:args
	[self delim: args with: '. ']:args
	-> [{'(self super: '. grammarClass superclass name. ' apply: '. rule storeString. ' withArgs: {'. args. '})'}]! !

!OMeta2RuleTranslator methodsFor: 'private' stamp: 'pb 5/22/2015 19:13'!
                       trans = {symbol:type apply(type asLowercase asSymbol):ans} -> [ans]! !

!OMeta2RuleTranslator methodsFor: 'grammar root' stamp: 'pb 5/22/2015 19:13'!
          translate :grammarClass = trans! !

!OMeta2RuleTranslator commentStamp: '<historical>' prior: 0!
                               OMeta2RuleTranslator is phase 3 of OMeta code compilation.  I take the parse tree from phase 1 or 2 and translate it to a list-based tree containing rendered Smalltalk code snippets.

OMeta implementation!

ProtoObject subclass: #Object
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Objects'!

!Object methodsFor: 'message handling' stamp: 'HAW 8/22/2017 10:17:59'!
    argumentName

	^self argumentNameSufix prefixedWithAOrAn ! !

!Object methodsFor: 'message handling' stamp: 'HAW 8/22/2017 10:16:01'!
                          argumentNameSufix

	^self class isMeta ifTrue: ['Class'] ifFalse: [self class name]! !

!Object methodsFor: 'printing' stamp: 'jmv 8/25/2017 10:55:31'!
        printOn: aStream
	"Append to the argument, aStream, a sequence of characters that  
	identifies the receiver."

	| title |
	title _ self class name.
	aStream
		nextPutAll: title aOrAnPrefix;
		space;
		nextPutAll: title! !

!Object methodsFor: 'printing' stamp: 'jmv 8/25/2017 10:55:49'!
printWithClosureAnalysisOn: aStream
	"Append to the argument, aStream, a sequence of characters that  
	identifies the receiver."

	| title |
	title _ self class name.
	aStream
		nextPutAll: title aOrAnPrefix;
		space;
		nextPutAll: title! !

!Object methodsFor: 'private' stamp: 'jmv 6/19/2017 16:14:39'!
              primitiveError: aString 
	"This method is called when the error handling results in a recursion in 
	calling on error: or halt or halt:."

	| context emergencyEvaluator lines r |
	r _ `10@10` extent: (Display extent -20 min: `700@1000`).
	lines _ r height // AbstractFont default height.
	emergencyEvaluator _ Transcripter newInFrame: r.
	emergencyEvaluator
		nextPutAll: '***System error handling failed***'; newLine;
		nextPutAll: aString; newLine;
		nextPutAll: '-------------------------------'; newLine.
	context _ thisContext sender sender.
	(30 min: lines - 10) timesRepeat: [context ifNotNil: [emergencyEvaluator print: (context _ context sender); newLine]].
	emergencyEvaluator
		nextPutAll: '-------------------------------'; newLine;
		nextPutAll: 'Type ''revert'' to revert your last method change.'; newLine;
		nextPutAll: 'Type ''exit'' to exit the emergency evaluator.'; newLine.
	emergencyEvaluator readEvalPrint! !


Object class
	instanceVariableNames: ''!

!Object class methodsFor: 'instance creation' stamp: 'jmv 12/30/2016 17:33:31'!
unStream: aByteArray
	^ ReferenceStream unStream: aByteArray! !


AbstractHierarchicalList subclass: #ObjectExplorer
	instanceVariableNames: 'rootObject monitorList'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Explorer'!

!ObjectExplorer methodsFor: 'user interface support' stamp: 'jmv 8/17/2017 16:28:32'!
                        textStylerClassFor: textGetter

	^SHTextStylerST80! !

!ObjectExplorer methodsFor: 'user commands' stamp: 'jmv 12/29/2016 11:01:35'!
                           inspectSelection
	self object inspect! !

!ObjectExplorer methodsFor: 'shout styling' stamp: 'jmv 8/17/2017 16:54:38'!
         bindingNamesDo: aBlock
	self doItReceiver class allInstVarNames do: aBlock! !

!ObjectExplorer methodsFor: 'shout styling' stamp: 'jmv 8/17/2017 16:54:33'!
    hasBindingOf: aString
	^ self doItReceiver class allInstVarNames includes: aString! !

!ObjectExplorer methodsFor: 'shout styling' stamp: 'jmv 8/26/2017 19:27:12'!
                            shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Answer true to allow styling to proceed, or false to veto the styling"

	anSHTextStyler workspace: self.
	^true! !

!ObjectExplorer methodsFor: 'testing' stamp: 'jmv 8/18/2017 17:42:19'!
                 is: aSymbol
	^ aSymbol == #providesBindings or: [ super is: aSymbol ]! !


SystemWindow subclass: #ObjectExplorerWindow
	instanceVariableNames: 'listMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!

!ObjectExplorerWindow methodsFor: 'GUI building' stamp: 'jmv 12/29/2016 11:00:46'!
      buildMorphicWindow

	| textMorph |
	listMorph _ HierarchicalListMorph
			model: model
			listGetter: #getList
			indexGetter: #getCurrentSelection
			indexSetter: #noteNewSelection:
			mainView: self
			menuGetter: #genericMenu
			keystrokeAction: #explorerKey:from:.
	listMorph autoDeselect: false.
	listMorph doubleClickSelector: #inspectSelection.
	textMorph _ (TextModelMorph textProvider: model)
			askBeforeDiscardingEdits: false.
	self layoutMorph
		addMorph: listMorph proportionalHeight: 0.8;
		addAdjusterAndMorph: textMorph proportionalHeight: 0.2.
	self setLabel: (model rootObject printStringLimitedTo: 64)! !

!ObjectExplorerWindow methodsFor: 'GUI building' stamp: 'jmv 6/19/2017 16:01:35'!
                              initialExtent

	^`300@500`! !

!ObjectExplorerWindow methodsFor: 'menu commands' stamp: 'jmv 12/29/2016 10:50:28'!
             openWeightExplorer
	"Create and schedule a Weight Explorer on the receiver's model's currently selected object."

	^WeightTracer openExplorerOn: model object! !


ExceptionHandlingCondition subclass: #OrExceptionHandlingCondition
	instanceVariableNames: 'leftCondition rightCondition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions Kernel'!

!OrExceptionHandlingCondition methodsFor: 'accessing' stamp: 'HAW 3/28/2017 17:55:27'!
                             leftCondition

	^leftCondition ! !

!OrExceptionHandlingCondition methodsFor: 'accessing' stamp: 'HAW 3/28/2017 17:56:11'!
     rightCondition

	^rightCondition ! !

!OrExceptionHandlingCondition methodsFor: 'error handling' stamp: 'HAW 3/28/2017 17:31:39'!
                              handles: anException

	^ (leftCondition handles: anException) or: [ rightCondition handles: anException ]! !

!OrExceptionHandlingCondition methodsFor: 'initialization' stamp: 'HAW 3/28/2017 17:32:20'!
                      initializeHandling: aLeftCondition or: aRightCondition

	leftCondition _ aLeftCondition.
	rightCondition _ aRightCondition ! !

!OrExceptionHandlingCondition methodsFor: 'handling condition creation' stamp: 'HAW 3/29/2017 13:59:16'!
                       , anExceptionHandlingCondition

	"See ExceptionHandlingCondition>>#- for an explanation of why double dispatch is used as implementation"
	
	^anExceptionHandlingCondition createOrConditionWithOrCondition: self
	! !

!OrExceptionHandlingCondition methodsFor: 'handling condition creation' stamp: 'HAW 3/29/2017 13:59:22'!
                               - anExceptionHandlingCondition

	"See ExceptionHandlingCondition>>#- for an explanation of why double dispatch is used as implementation"
	
	^anExceptionHandlingCondition createFilterConditionWithOrCondition: self
	! !

!OrExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 17:32:37'!
                 createFilterConditionWithExceptionType: anExceptionType

	^FilterExceptionHandlingCondition 
		handling: anExceptionType - leftCondition 
		filtering: rightCondition ! !

!OrExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 17:33:37'!
  createFilterConditionWithFilterCondition: aFilterExceptionHandlingCondition 
	
	^aFilterExceptionHandlingCondition - leftCondition - rightCondition ! !

!OrExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 17:34:05'!
                    createFilterConditionWithOrCondition: anOrExceptionHandlingCondition 
	
	^ anOrExceptionHandlingCondition - leftCondition - rightCondition ! !

!OrExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 11:16:37'!
                             createOrConditionWithExceptionType: anExceptionType

	^self class handling: anExceptionType or: self! !

!OrExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 14:56:09'!
    createOrConditionWithFilterCondition: aFilterExceptionHandlingCondition 
	
	^self, aFilterExceptionHandlingCondition ! !

!OrExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 11:20:32'!
                   createOrConditionWithOrCondition: anOrExceptionHandlingCondition 
	
	^self class handling: anOrExceptionHandlingCondition or: self! !

!OrExceptionHandlingCondition methodsFor: 'printing' stamp: 'HAW 3/28/2017 17:54:46'!
   printOn: aStream
	
	aStream
		print: leftCondition;
		nextPutAll: ', ';
		print: rightCondition ! !


OrExceptionHandlingCondition class
	instanceVariableNames: ''!

!OrExceptionHandlingCondition class methodsFor: 'instance creation' stamp: 'HAW 3/27/2017 15:47:32'!
                     handling: anExceptionClass or: anotherExceptionClass
 
	^self new initializeHandling: anExceptionClass or: anotherExceptionClass
! !


SequenceableCollection subclass: #OrderedCollection
	instanceVariableNames: 'array firstIndex lastIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Sequenceable'!

!OrderedCollection methodsFor: 'enumerating' stamp: 'len 11/28/2016 10:50:21'!
           collect: aBlock 
	"Evaluate aBlock with each of my elements as the argument. Collect the 
	resulting values into a collection that is like me. Answer the new 
	collection. Override superclass in order to use addLast:, not at:put:."

	| newCollection |
	newCollection _ self species new: self size.
	newCollection resetTo: 1.
	firstIndex to: lastIndex do: [ :index |
		newCollection addLast: (aBlock value: (array at: index))].
	^ newCollection! !

!OrderedCollection methodsFor: 'enumerating' stamp: 'jmv 11/30/2016 14:51:19'!
                 with: otherCollection with: thirdCollection collect: threeArgBlock
	"Collect and return the result of evaluating twoArgBlock with 
	corresponding elements from this collection and otherCollection."
	| result |
	otherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].
	result _ self species new: self size.
	1 to: self size do: [ :index |
		result addLast:
			(threeArgBlock
				value: (self at: index)
				value: (otherCollection at: index)
				value: (thirdCollection at: index) )].
	^ result! !

!OrderedCollection methodsFor: 'converting' stamp: 'len 11/29/2016 08:54:14'!
                       asNewArray
	^ array copyFrom: firstIndex to: lastIndex! !


OrderedCollection class
	instanceVariableNames: ''!

!OrderedCollection class methodsFor: 'instance creation' stamp: 'len 11/28/2016 19:18:39'!
                    newFrom: aCollection
	"Create a new collection containing all the elements from aCollection"

	^(self new: aCollection size)
		resetTo: 1;
		addAll: aCollection;
		yourself! !


Inspector subclass: #OrderedCollectionInspector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Inspector'!

!OrderedCollectionInspector methodsFor: 'as yet unclassified' stamp: 'HAW 7/29/2017 15:13:36'!
                       fieldList

	| fieldsHere |
	object isNil ifTrue: [^OrderedCollection new].
	fieldsHere _
		[
			(object size <= (self i1 + self i2)
				ifTrue: [(1 to: object size) collect: [:i | i printString]]
				ifFalse: [(1 to: self i1) , (object size-(self i2-1) to: object size) collect: [:i | i printString]])
		] on: Error do: [:ex | ex return: OrderedCollection new].	
	^self baseFieldList , fieldsHere
"
OrderedCollection new inspect
(OrderedCollection newFrom: #(3 5 7 123)) inspect
(OrderedCollection newFrom: (1 to: 1000)) inspect
"! !


Scanner subclass: #Parser
	instanceVariableNames: 'here hereType hereMark hereEnd prevMark prevEnd encoder requestor parseNode failBlock requestorOffset tempsMark doitFlag properties category sourceStreamGetter'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

!Parser methodsFor: 'primitives' stamp: 'nice 9/6/2013 00:48'!
        externalFunctionDeclaration
	"Parse the function declaration for a call to an external library."
	| descriptorClass callType modifier retType externalName args argType module fn |
	descriptorClass := Smalltalk at: #ExternalFunction ifAbsent: [ ^ false ].
	callType := descriptorClass callingConventionFor: here.
	callType == nil ifTrue:[^false].
	[modifier := descriptorClass callingConventionModifierFor: token.
	 modifier notNil] whileTrue:
		[self advance.
		 callType := callType bitOr: modifier].
	"Parse return type"
	self advance.
	retType := self externalType: descriptorClass.
	retType == nil ifTrue:[^self expected:'return type'].
	"Parse function name or index"
	externalName := here.
	(self match: #string) 
		ifTrue:[externalName := externalName asSymbol]
		ifFalse:[(self match:#number) ifFalse:[^self expected:'function name or index']].
	(self match: #leftParenthesis) ifFalse:[^self expected:'argument list'].
	args := WriteStream on: Array new.
	[self match: #rightParenthesis] whileFalse:[
		argType := self externalType: descriptorClass.
		argType == nil ifTrue:[^self expected:'argument'].
		argType isVoid & argType isPointerType not ifFalse:[args nextPut: argType]].
	(self matchToken: 'module:') ifTrue:[
		module := here.
		(self match: #string) ifFalse:[^self expected: 'String'].
		module := module asSymbol].
	Smalltalk at: #ExternalLibraryFunction ifPresent:[:xfn|
		fn := xfn name: externalName 
				module: module 
				callType: callType
				returnType: retType
				argumentTypes: args contents.
		self allocateLiteral: fn].
	(self matchToken: 'error:')
		ifTrue:
			[| errorCodeVariable |
			 errorCodeVariable := here.
			(hereType == #string
			 or: [hereType == #word]) ifFalse:[^self expected: 'error code (a variable or string)'].
			 self advance.
			 self addPragma: (Pragma keyword: #primitive:error: arguments: (Array with: 120 with: errorCodeVariable)).
			 fn ifNotNil: [fn setErrorCodeName: errorCodeVariable]]
		ifFalse:
			[self addPragma: (Pragma keyword: #primitive: arguments: #(120))].
	^true! !


BorderedRectMorph subclass: #PasteUpMorph
	instanceVariableNames: 'worldState backgroundImage backgroundImageData taskbar'
	classVariableNames: 'WindowEventHandler'
	poolDictionaries: ''
	category: 'Morphic-Worlds'!

!PasteUpMorph methodsFor: 'caching' stamp: 'jmv 3/3/2017 11:42:44'!
   releaseCachedState
	super releaseCachedState.
	backgroundImage _ nil.
	self isWorldMorph ifTrue: [
		worldState cleanseStepList.
		worldState clearCanvas ]! !

!PasteUpMorph methodsFor: 'change reporting' stamp: 'jmv 1/16/2017 09:56:14'!
                  addedMorph: aMorph
	"Notify the receiver that the given morph was just added."
	super addedMorph: aMorph.
	self taskbar ifNotNil: [ :tb |
		tb wasOpened: aMorph ]! !

!PasteUpMorph methodsFor: 'change reporting' stamp: 'jmv 6/19/2017 15:55:13'!
           invalidateDisplayRect: damageRect from: aMorph
        "Clip damage reports to my bounds, since drawing is clipped to my bounds."

        self == self world 
                ifTrue: [ worldState recordDamagedRect: (damageRect intersect: ( `0@0` extent: extent) ) ]
                ifFalse: [ super invalidateDisplayRect: damageRect from: aMorph ]
! !

!PasteUpMorph methodsFor: 'change reporting' stamp: 'jmv 1/16/2017 09:56:07'!
                 removedMorph: aMorph
	"Notify the receiver that aMorph was just removed from its children"
	super removedMorph: aMorph.
	self taskbar ifNotNil: [ :tb |
		tb wasDeleted: aMorph ]! !

!PasteUpMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:55:00'!
     drawOn: aCanvas

	"draw background image."
	backgroundImage
		ifNotNil: [
			aCanvas image: backgroundImage at: `0@0` ]
		ifNil: [
			"draw background fill"
			(self isWorldMorph and: [ aCanvas drawsOnDisplay ] and: [ color mightBeTranslucent ])
				ifTrue: [
					"Special case so a translucent background on the Display allows you to see through the main Cuis Window.
					Requires proper handling of translucent Display in the VM.
					Seems to work only on Linux when using a composing window manager."
					(BitBlt toForm: Display) clipRect: aCanvas clipRect;
						copy: Display boundingBox
						from: `0@0` in: nil
						fillColor: color rule: Form over.
					Display forceToScreen]
				ifFalse: [ super drawOn: aCanvas ]]! !

!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 6/19/2017 15:55:18'!
                           morphPositionInWorld

	self flag: #jmvVer2. "Solo para evitar los warning por falta de owner... pensar despues este caso"
	self isWorldMorph ifTrue: [ ^ `0@0` ].
	^super morphPositionInWorld! !

!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 1/22/2017 21:17:32'!
                       privateExtent: newExtent

	^ (super privateExtent: newExtent)
		ifTrue: [
			self buildMagnifiedBackgroundImage.
			worldState ifNotNil: [
				worldState clearCanvas ]];
		yourself! !

!PasteUpMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:35'!
                              defaultBorderColor
	"answer the default border color/fill style for the receiver"
	^ Color
		r: 0.861
		g: 1.0
		b: 0.722! !

!PasteUpMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:29'!
                         defaultColor
	"answer the default color/fill style for the receiver"
	^ Color
		r: 0.8
		g: 1.0
		b: 0.6! !

!PasteUpMorph methodsFor: 'interaction loop' stamp: 'jmv 3/2/2017 19:58:01'!
      doOneCycleNow
	"see the comment in WorldState >> doOneCycleNow
	Only used for a few tests."
	worldState doOneCycleNow! !

!PasteUpMorph methodsFor: 'printing' stamp: 'jmv 12/9/2016 10:25:13'!
printOn: aStream
	"Reimplemented to add a tag showing that the receiver is currently functioning as a 'world', if it is"

	self isWorldMorph
		ifTrue: [aStream nextPutAll: ' [world]']
		ifFalse: [super printOn: aStream]! !

!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 6/19/2017 15:55:22'!
                     viewBox

	^ worldState
		ifNotNil: [
			 `0@0` extent: extent ]
		ifNil: [
			self world viewBox ]! !

!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 11/10/2013 19:32'!
                   findWindow: evt
	"Present a menu names of windows and naked morphs, and activate the one that gets chosen.  Collapsed windows appear below line, expand if chosen; naked morphs appear below second line; if any of them has been given an explicit name, that is what's shown, else the class-name of the morph shows; if a naked morph is chosen, bring it to front and have it don a halo."
	| menu expanded collapsed nakedMorphs |
	menu _ MenuMorph new.
	expanded _ SystemWindow windowsIn: self satisfying: [ :w | w isCollapsed not ].
	collapsed _ SystemWindow windowsIn: self satisfying: [ :w | w isCollapsed ].
	nakedMorphs _ self submorphsSatisfying: [ :m |
		(m is: #SystemWindow) not ].
	expanded isEmpty & (collapsed isEmpty & nakedMorphs isEmpty) ifTrue: [ ^ Smalltalk beep ].
	(expanded asArray sort: [ :w1 :w2 |
		w1 label caseInsensitiveLessOrEqual: w2 label ]) do: [ :w |
		menu
			add: w label
			target: w
			action: #activateAndForceLabelToShow.
		w canDiscardEdits ifFalse: [ menu lastItem color: Color red ]].
	expanded isEmpty | (collapsed isEmpty & nakedMorphs isEmpty) ifFalse: [ menu addLine ].
	(collapsed asArray sort: [ :w1 :w2 |
		w1 label caseInsensitiveLessOrEqual: w2 label ]) do: [ :w |
		menu
			add: w label
			target: w
			action: #expand.
		w canDiscardEdits ifFalse: [ menu lastItem color: Color red ]].
	nakedMorphs isEmpty ifFalse: [ menu addLine ].
	(nakedMorphs asArray sort: [ :w1 :w2 |
		w1 label caseInsensitiveLessOrEqual: w2 label ]) do: [ :w |
		menu
			add: w label
			target: w
			action: #comeToFrontAndAddHalo ].
	menu addTitle: 'find window'.
	menu popUpInWorld: self! !

!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 1/8/2017 16:44:57'!
           allNonWindowRelatedSubmorphs
	"Answer all non-window submorphs that are not flap-related"

	^submorphs 
		reject: [ :m | (m is: #SystemWindow) or: [ m is: #TaskbarMorph ] ]! !

!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 3/2/2017 19:34:54'!
       displayWorldSafely

	worldState displayWorldSafely
! !

!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 3/2/2017 19:33:20'!
doOneCycle
	"see the comment in WorldState >> doOneCycle"

	worldState doOneCycle! !

!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 3/2/2017 20:08:11'!
  doOneMinimalCycleNow
	"see the comment in WorldState >> doOneMinimalCycleNow"

	worldState doOneMinimalCycleNow! !

!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 6/19/2017 15:55:05'!
   fillRects: rectangleList color: aColor
	"For testing. Flashes the given list of rectangles on the Display so you can watch incremental redisplay at work."


	| blt screenRect |
	blt _ (BitBlt toForm: Display)
		sourceForm: nil;
		sourceOrigin: `0@0`;
		clipRect: self viewBox;
		fillColor: aColor;
		combinationRule: Form over.

	rectangleList do: [:r |
		screenRect _ r translatedBy: self viewBox origin.
		blt destRect: screenRect; copyBits.
		Display forceToScreen: screenRect ].

	(Delay forMilliseconds: 150) wait! !

!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 6/19/2017 15:55:09'!
            flashRects: rectangleList color: aColor
	"For testing. Flashes the given list of rectangles on the Display so you can watch incremental redisplay at work."
	"Details: Uses two reverses so that the display is restored to its original state. This is necessary when in deferred update mode."

	| blt screenRect |
	blt _ (BitBlt toForm: Display)
		sourceForm: nil;
		sourceOrigin: `0@0`;
		clipRect: self viewBox;
		fillColor: aColor;
		combinationRule: Form reverse.

	rectangleList do: [:r |
		screenRect _ r translatedBy: self viewBox origin.
		blt destRect: screenRect; copyBits.
		Display forceToScreen: screenRect ].

	(Delay forMilliseconds: 250) wait.

	rectangleList do: [:r |
		screenRect _ r translatedBy: self viewBox origin.
		blt destRect: screenRect; copyBits.
		Display forceToScreen: screenRect ]! !

!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 3/2/2017 19:37:11'!
          privateOuterDisplayWorld

	worldState displayWorldAndSubmorphs: submorphs
! !

!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 1/17/2017 11:05:24'!
        restoreMorphicDisplay
	DisplayScreen startUp.
	self
		morphExtent: Display extent;
		handsDo: [ :h | h visible: true ];
		fullRepaintNeeded.
	WorldState addDeferredUIMessage: [ Cursor normal activateCursor ]! !

!PasteUpMorph methodsFor: 'halos and balloon help' stamp: 'pb 6/9/2017 00:51:44'!
                          wantsHaloHandleWithSelector: aSelector inHalo: aHaloMorph
	"Answer whether the receiver would like to offer the halo handle with the given selector (e.g. #addCollapseHandle:)"
	(#(addHelpHandle: addRotateHandle: addRecolorHandle:) statePointsTo: aSelector)
		ifTrue: ["FIXME - hack to disable for non-functional halo items"
			^ false].
	
	self isWorldMorph ifFalse: [
		^super wantsHaloHandleWithSelector: aSelector inHalo: aHaloMorph ].

	^#(addDebugHandle: addMenuHandle: addHelpHandle:)
		statePointsTo: aSelector! !

!PasteUpMorph methodsFor: 'taskbar' stamp: 'jmv 1/15/2017 14:43:48'!
                 showTaskbar

	taskbar ifNil: [
		taskbar _ TaskbarMorph newRow.
		taskbar openInWorld: self ]! !

!PasteUpMorph methodsFor: 'taskbar' stamp: 'jmv 1/15/2017 18:57:53'!
                         taskbarDeleted
	taskbar _ nil! !


PasteUpMorph class
	instanceVariableNames: ''!

!PasteUpMorph class methodsFor: 'instance creation' stamp: 'jmv 6/19/2017 15:55:26'!
                        newWorld
	"
[
	ProjectX stopUIProcess.
	ProjectX spawnNewMorphicProcessFor: PasteUpMorph newWorld
] fork.
	"
	| w ws |
	w _ self new.
	ws _ WorldState new.
	w worldState: ws.
	w morphPosition: `0@0` extent: Display extent.
	ws setCanvas: Display getCanvas.
	w borderWidth: 0.
	ws handsDo: [ :h |
		h privateOwner: w ].
	^w! !

!PasteUpMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:51:39'!
categoryInNewMorphMenu
	^ 'Worlds'! !


PluggableMorph subclass: #PluggableButtonMorph
	instanceVariableNames: 'label font icon getStateSelector actionSelector isPressed mouseIsOver magnifiedIcon actWhen roundButtonStyle iconName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jmv 8/25/2017 15:05:56'!
                               label: aStringOrNil font: aFontOrNil
	"Label this button with the given string."
	label _ aStringOrNil.
	font _ aFontOrNil.
	(self fontToUse notNil and: [ label notNil ])
		ifTrue: [ "Add a bit of padding"
			extent := (self fontToUse widthOfString: label) + 10 @ (self fontToUse height + 10) ]! !

!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:55:30'!
        draw3DLookOn: aCanvas

	| borderStyleSymbol c |
	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c _ color.
	self mouseIsOver ifTrue: [ c _ c  lighter ].
	aCanvas
		fillRectangle: (`0@0` extent: extent)
		color: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol
		baseColorForBorder: c.

	self drawRegularLabelOn: aCanvas! !

!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 5/1/2015 16:20'!
  drawEmbossedLabelOn: aCanvas

	| availableW center colorForLabel f l labelMargin targetSize w x y |
	label ifNotNil: [
		colorForLabel _ Theme current buttonLabel.
		self isPressed
			ifFalse: [
				self mouseIsOver
					ifFalse: [ colorForLabel _ colorForLabel adjustSaturation: -0.10 brightness: 0.10 ]]
			ifTrue: [ colorForLabel _ colorForLabel adjustSaturation: 0.0 brightness: -0.07 ].
		f _ self fontToUse.
		center _ extent // 2.
		labelMargin _ 3.
		w _ f widthOfString: label.
		availableW _ extent x - labelMargin - labelMargin.
		availableW >= w
			ifTrue: [
				l _ label ]
			ifFalse: [
				x _ labelMargin.
				targetSize _ label size * availableW // w.
				l _ label squeezedTo: targetSize.
				(f widthOfString: l) > availableW ifTrue: [
					targetSize _ targetSize - 1.
					l _ label squeezedTo: targetSize ]].
		
		w _ f widthOfString: l.
		x _ center x - (w // 2).
		y _ center y - (f height // 2).
		aCanvas
			drawString: l
			at: x@y
			font: f
			color: colorForLabel
			embossed: true ]! !

!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 7/10/2014 22:43'!
                            drawRegularLabelOn: aCanvas

	| w f center x y  availableW l labelMargin |

	f _ self fontToUse.
	center _ extent // 2.

	label ifNotNil: [
		labelMargin _ 4.
		w _ f widthOfString: label.
		availableW _ extent x - labelMargin - labelMargin - 1.
		availableW >= w
			ifTrue: [
				x _ center x - (w // 2).
				l _ label ]
			ifFalse: [
				x _ labelMargin.
				l _ label squeezedTo: (label size * availableW / w) rounded ].
		y _ center y - (f height // 2).
		self isPressed ifTrue: [
			x _ x + 1.
			y _ y + 1 ].
		aCanvas
			drawString: l
			at: x@y
			font: f
			color: Theme current buttonLabel ]! !

!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:55:46'!
                     drawRoundGradientLookOn: aCanvas
	| r colorForButton rect bottomFactor topFactor |

	self isPressed
		ifFalse: [
			topFactor _ Theme current buttonGradientTopFactor.
			bottomFactor _ Theme current buttonGradientBottomFactor.
			self mouseIsOver
				ifTrue: [	
					colorForButton _ Color h: color hue s: color saturation * 1.3 v: color brightness * 0.9 ]
				ifFalse: [
					colorForButton _ color ]]
		ifTrue: [
			topFactor _ Theme current buttonGradientBottomFactor.
			bottomFactor _ Theme current buttonGradientTopFactor.
			colorForButton _ color adjustSaturation: 0.1 brightness: -0.1 ].

	colorForButton ifNotNil: [
		r _ Theme current roundedButtonRadius.
		Theme current useButtonGradient
			ifTrue: [
				rect _ (`0@0` extent: extent) insetBy: `1@3`.
				aCanvas
					roundRect: rect
					color: colorForButton
					radius: r
					gradientTop: topFactor
					gradientBottom: bottomFactor
					gradientHeight: Theme current buttonGradientHeight ]
			ifFalse: [
				rect _ (`0@0` extent: extent) insetBy: `1@3`.
				aCanvas roundRect: rect color: colorForButton radius: r ]
		].

	Theme current embossedButtonLabels
		ifTrue: [ self drawEmbossedLabelOn: aCanvas ]
		ifFalse: [ self drawRegularLabelOn: aCanvas ]! !

!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 4/12/2012 22:37'!
           iconColor

	^ self isPressed
		ifTrue: [ Color gray: 0.75 ]
		ifFalse: [
			self mouseIsOver
				ifTrue: [ Color gray: 0.75 ]
				ifFalse: [ Color white ]].! !

!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:09:15'!
           initialize
	"initialize the state of the receiver"
	super initialize.

	roundButtonStyle _ nil.	"nil: honor Theme. true: draw as round button. false: draw as classic 3d border square button"
	model _ nil.
	getStateSelector _ nil.
	actionSelector _ nil.
	isPressed _ false.
	mouseIsOver _ false.
	actWhen _ #buttonUp.
	extent _  `20 @ 15`! !

!PluggableButtonMorph methodsFor: 'private' stamp: 'jmv 2/17/2017 15:10:48'!
                             magnifiedIcon
	| factor magnifiedExtent w h |

	icon ifNil: [ ^nil ].
	magnifiedIcon ifNil: [
		magnifiedIcon _ icon.
		w _ icon width.
		h _ icon height.
		w*h = 0 ifFalse: [
			factor _ 1.0 * extent x / w min: 1.0 * extent y / h.
			(factor < 1 or: [ factor > 1.7 and: [self isRoundButton]]) ifTrue: [
				magnifiedExtent _ (icon extent * factor) rounded.
				magnifiedIcon _ icon magnifyTo: magnifiedExtent ]]].
	^magnifiedIcon! !

!PluggableButtonMorph methodsFor: 'geometry testing' stamp: 'jmv 6/19/2017 15:55:52'!
                       morphContainsPoint: aLocalPoint

	| iconOrigin |
	((`0@0` extent: extent) containsPoint: aLocalPoint) ifFalse: [ ^false ].
	^ self isOrthoRectangularMorph or: [
		magnifiedIcon isNil or: [
			iconOrigin _ extent - magnifiedIcon extent // 2.
			(magnifiedIcon isTransparentAt: (aLocalPoint - iconOrigin) rounded) not ]]! !


PluggableButtonMorph class
	instanceVariableNames: ''!

!PluggableButtonMorph class methodsFor: 'example' stamp: 'jmv 6/19/2017 16:09:19'!
                 example
	"
	PluggableButtonMorph example openInWorld
	"

	| s1 s2 s3 b1 b2 b3 row |
	s1 _ Switch new.
	s2 _ Switch new turnOn.
	s3 _ Switch new.
	s2 onAction: [s3 turnOff].
	s3 onAction: [s2 turnOff].
	b1 _ (PluggableButtonMorph model: s1 stateGetter: #isOn action: #switch) label: 'S1'.
	b2 _ (PluggableButtonMorph model: s2 stateGetter: #isOn action: #turnOn) label: 'S2'.
	b3 _ (PluggableButtonMorph model: s3 stateGetter: #isOn action: #turnOn) label: 'S3'.
	b1 color: Color lightRed.
	b2 color: Color lightRed.
	b3 color: Color lightRed.
	row _ LayoutMorph newRow
		addMorphs: (Array with: b1 with: b2 with: b3);
		morphExtent: `120@35`.
	^ row
! !


PluggableScrollPane subclass: #PluggableListMorph
	instanceVariableNames: 'list getListSelector getIndexSelector setIndexSelector keystrokeActionSelector autoDeselect lastKeystrokeTime lastKeystrokes doubleClickSelector menuGetter mainView'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!PluggableListMorph methodsFor: 'events' stamp: 'jmv 8/17/2017 13:05:27'!
          doubleClick: aMouseButtonEvent localPosition: localEventPosition
	| index |
	doubleClickSelector ifNil: [ ^super doubleClick: aMouseButtonEvent localPosition: localEventPosition ].
	index _ self rowAtLocation: localEventPosition.
	index = 0 ifTrue: [ ^super doubleClick: aMouseButtonEvent localPosition: localEventPosition ].
	index == self selectionIndex
		ifFalse: [ self changeModelSelection: index ].
	^ self model perform: doubleClickSelector! !

!PluggableListMorph methodsFor: 'initialization' stamp: 'jmv 12/29/2016 10:41:28'!
         doubleClickSelector: aSymbol
	doubleClickSelector _ aSymbol! !

!PluggableListMorph methodsFor: 'selection' stamp: 'pb 7/6/2017 02:47:04'!
                     scrollSelectionIntoView
	"make sure that the current selection is visible"
	| row r |
	row _ self getCurrentSelectionIndex.
	row = 0 
		ifTrue: [
			"Value is 0, but we need to propagate it to model"
			scrollBar internalScrollValue: scrollBar scrollValue ]
		ifFalse: [
			self flag: #jmvVer2.
			r _ self listMorph drawBoundsForRow: row.
			r _ ((self listMorph externalize: r origin) extent: r extent).
			self scrollToShow: r ]! !


PluggableListMorph subclass: #PluggableListMorphOfMany
	instanceVariableNames: 'dragOnOrOff getSelectionListSelector setSelectionListSelector dragStartRow'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!PluggableListMorphOfMany methodsFor: 'events' stamp: 'pb 7/6/2017 02:56:44'!
                      mouseMove: aMouseMoveEvent localPosition: localEventPosition
	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"

	| oldIndex oldVal row |
	row _ (localEventPosition y < 0 and: [ scrollBar scrollValue > 0.0 ])
		ifTrue: [
			scrollBar scrollUp: 1.
			"Leave at least one visible item unaffected, for better visual feedback to the user."
			(self rowAtLocation: `0@0`) + 2 ]
		ifFalse: [
			(localEventPosition y > extent y and: [ scrollBar scrollValue < 1.0 ])
				ifTrue: [
					scrollBar scrollDown: 1.
					"Leave at least one visible item unaffected, for better visual feedback to the user."
					(self rowAtLocation: 0@extent y) - 3 ]
				ifFalse: [ self rowAtLocation: localEventPosition ]].
	row = 0 ifTrue: [ ^ self ].

	"No change if model is locked"
	self owningWindow ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].

	dragOnOrOff ifNil: [
		"Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"
		dragOnOrOff _ (self listSelectionAt: row) not.
		dragStartRow _ row ].

	"Set meaning for subsequent dragging of selection"
	oldIndex _ self getCurrentSelectionIndex.
	oldIndex ~= 0 ifTrue: [ oldVal _ self listSelectionAt: oldIndex ].

	"Set or clear new primary selection (listIndex)"
	dragOnOrOff 
		ifTrue: [ self changeModelSelection: row ]
		ifFalse: [ self changeModelSelection: 0 ].

	"Need to restore the old one, due to how model works, and set new one."
	oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].
	
	"Select all in between if drag was too fast"
	"self listSelectionAt: row put: dragOnOrOff."
	(row min: dragStartRow) to: (row max: dragStartRow) do: [ :r |
		self listSelectionAt: r put: dragOnOrOff ]! !


BorderedRectMorph subclass: #PluggableMorph
	instanceVariableNames: 'model'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!PluggableMorph methodsFor: 'initialization' stamp: 'jmv 8/6/2014 09:15'!
    defaultColor
	"answer the default color/fill style for the receiver"
	^ Color lightGray! !

!PluggableMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:09:25'!
                      initialize
	super initialize.
	extent _ `200@100`! !


PluggableMorph subclass: #PluggableScrollPane
	instanceVariableNames: 'scrollBar scroller hScrollBar hideScrollBars drawKeyboardFocusIndicator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!PluggableScrollPane methodsFor: 'access' stamp: 'jmv 6/19/2017 15:56:26'!
   addToScroller: aMorph

	scroller
		addMorph: aMorph position: `0@0`;
		morphExtent: aMorph morphExtent! !

!PluggableScrollPane methodsFor: 'geometry' stamp: 'pb 7/6/2017 02:46:41'!
          hSetScrollDelta
	"Set the ScrollBar deltas, value and interval, based on the current scroll pane size, offset and range."
	| range delta w |
	
	delta _ self scrollDeltaWidth * 1.0.		"avoid Fraction arithmetic"
	range _ self hLeftoverScrollRange.
	range = 0 ifTrue: [
		^hScrollBar scrollDelta: 0.02 pageDelta: 0.2; interval: 1.0; internalScrollValue: 0 ].

	"Set up for one line (for arrow scrolling), or a full pane less one line (for paging)."
	w _ self viewableWidth * 1.0.		"avoid Fraction arithmetic"
	hScrollBar scrollDelta: delta / range pageDelta: w - delta / range.
	hScrollBar interval: w / self hTotalScrollRange.
	hScrollBar internalScrollValue: hScrollBar scrollValue! !

!PluggableScrollPane methodsFor: 'geometry' stamp: 'pb 7/6/2017 02:48:25'!
        vSetScrollDelta
	"Set the ScrollBar deltas, value and interval, based on the current scroll pane size, offset and range."
	| range delta h |
	
	delta _ self scrollDeltaHeight * 1.0.	"avoid Fraction arithmetic"
	range _ self vLeftoverScrollRange.
	range = 0 ifTrue: [
		^ scrollBar scrollDelta: 0.02 pageDelta: 0.2; interval: 1.0; internalScrollValue: 0 ].

	"Set up for one line (for arrow scrolling), or a full pane less one line (for paging)."
	h _ self viewableHeight * 1.0. 		"avoid Fraction arithmetic"
	scrollBar scrollDelta: delta / range pageDelta: h - delta / range.
	scrollBar interval: h / self vTotalScrollRange.
	scrollBar internalScrollValue: scrollBar scrollValue! !

!PluggableScrollPane methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:09:31'!
  initialize
	
	"initialize the state of the receiver"
	super initialize.
	hideScrollBars _ false.

	"initialize the receiver's scrollBars"
	scrollBar _ self scrollBarClass new model: self setValueSelector: #vScrollBarValue:.
	hScrollBar _ self scrollBarClass new model: self setValueSelector: #hScrollBarValue:.
	drawKeyboardFocusIndicator _ true.

	scroller _ self innerMorphClass new.
	self addMorph: scroller.
	self scrollerOffset: `0@ 0`.
	self addMorph: scrollBar.
	self addMorph: hScrollBar.! !

!PluggableScrollPane methodsFor: 'scrolling' stamp: 'pb 7/6/2017 02:48:00'!
                               hideOrShowScrollBars

	"Assume for a moment we don't need an horizontal scrollbar"
	self hHideScrollBar.

	"Add or remove vertical scrollbar, asuming for a monent there's no horizontal scrollbar,
	to determine need of horizontal scrollbar..."
	self vIsScrollbarNeeded
		ifTrue: [ self vShowScrollBar ]
		ifFalse: [ self vHideScrollBar ].

	"If we need an horizontal scrollbar, add it."
	self hIsScrollbarNeeded ifTrue: [
		self hShowScrollBar.

		"If horizontal scrollbar is needed, maybe vertical scrollbar will be needed too (even if we previously thoutht it wouldn't be needed)."	
		"Note that there is no chance of modifying the need of horizontal scrollbar: it was already needed. Therefore, there is no circularity here."
		self vIsScrollbarNeeded  ifTrue: [
			self vShowScrollBar ]].

	"Ensure that if no scrollbars are needed, whole contents are visible"
	self vIsScrollbarShowing ifFalse: [
		scrollBar internalScrollValue: 0 ].
	self hIsScrollbarShowing ifFalse: [
		hScrollBar internalScrollValue: 0 ].

	self updateScrollBarsBounds! !

!PluggableScrollPane methodsFor: 'scrolling' stamp: 'pb 7/6/2017 02:51:24'!
                           scrollBy: delta
	"Move the contents in the direction delta."

	| newYoffset r newXoffset |
	
	"Set the offset on the scroller"
	newYoffset _ self scrollerOffset y - delta y max: 0.
	newXoffset _ self scrollerOffset x - delta x max: 0.
	
	self scrollerOffset: newXoffset@ newYoffset.

	"Update the scrollBars"
	(r _ self vLeftoverScrollRange) = 0
		ifTrue: [ scrollBar scrollValue: 0.0 ]
		ifFalse: [ scrollBar scrollValue: newYoffset asFloat / r ].
	(r _ self hLeftoverScrollRange) = 0
		ifTrue: [ hScrollBar scrollValue: 0.0 ]
		ifFalse: [ hScrollBar scrollValue: newXoffset asFloat / r ]! !

!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 6/19/2017 15:56:31'!
scrollToShow: aRectangle
	"scroll to include as much of aRectangle as possible, where aRectangle is in the scroller's local space.
	This means that 0@0 is scrolling all the way top and all the way left"
	| delta |
	(aRectangle top >= 0 and: [
		aRectangle bottom <= self viewableHeight ])
		ifTrue: [
			"already visible"
			^self ].

	"Scroll end of selection into view if necessary"
	delta _ aRectangle amountToTranslateWithin: (`0@0` extent: self viewableExtent).
	delta y ~= 0 ifTrue: [
		self scrollBy: 0@delta y ]! !


TextModel subclass: #PluggableTextModel
	instanceVariableNames: 'textProvider textGetter textSetter selectionGetter'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!PluggableTextModel methodsFor: 'shout styling' stamp: 'jmv 8/26/2017 19:21:51'!
    shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Set the classOrMetaClass in anSHTextStyler, so that identifiers
	will be resolved correctly.
	Answer true to allow styling to proceed, or false to veto the styling"
	^textProvider shouldStyle: text with: anSHTextStyler! !


Object subclass: #Point
	instanceVariableNames: 'x y'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Primitives'!

!Point methodsFor: 'point functions' stamp: 'jmv 6/19/2017 16:10:05'!
                               eightNeighbors
	^ (Array with: self + `1@0`
		with: self + `1@1`
		with: self + `0@1`
		with: self + `-1@1`) ,
	(Array with: self + `-1@0`
		with: self + `-1@-1`
		with: self + `0@-1`
		with: self + `1@-1`)
! !

!Point methodsFor: 'point functions' stamp: 'jmv 6/19/2017 16:10:18'!
      fourNeighbors
	^ Array with: self + `1@0`
		with: self + `0@1`
		with: self + `-1@0`
		with: self + `0@-1`
! !

!Point methodsFor: 'printing' stamp: 'jmv 12/15/2016 10:20:58'!
                printStringFractionDigits: placesDesired
	^(x printStringFractionDigits: placesDesired), '@', (y printStringFractionDigits: placesDesired)! !

!Point methodsFor: 'private' stamp: 'jmv 12/11/2016 10:28:44'!
                  privateSetX: xValue setY: yValue
	"Points are immutable. Right now this is by convention, but we'll make this enfoced by VM.
	Do not all this method, except from instance creation."
	x _ xValue.
	y _ yValue! !

!Point methodsFor: 'copying' stamp: 'pb 10/29/2016 18:18:07'!
               shallowCopy
	"Immutable"
	^ self.! !

!Point commentStamp: 'jmv 12/30/2016 17:39:06' prior: 0!
 I represent an x-y pair of numbers usually designating a location on the screen.

When dealing with display coordinates, the y axis is usually considered to increase downwards. However, the standard math convention is to consider it increasing upwards. 
Points don't need to know about this. In the first case, theta increases clockwise. In the second case, it increases counter-clockwise, also the standard math convention.

Any method that doesn't follow this (because it assumes one specific convention) include this fact in the selector and in a comment.

My instances are immutable. See #privateSetX:setY:!

Point class
	instanceVariableNames: ''!

!Point class methodsFor: 'instance creation' stamp: 'pb 10/29/2016 17:14:00'!
    r: rho degrees: degrees
	"Answer an instance of me with polar coordinates rho and theta."
	^ self
		rho: rho
		theta: degrees asFloat degreesToRadians.! !

!Point class methodsFor: 'instance creation' stamp: 'pb 10/29/2016 17:12:53'!
                      rho: rho theta: radians
	"Answer an instance of me with polar coordinates rho and theta."
	^ self
		x: rho asFloat * radians cos
		y: rho asFloat * radians sin.! !

!Point class methodsFor: 'instance creation' stamp: 'jmv 12/11/2016 10:28:50'!
            x: anX y: anY
	"Answer an instance of me with supplied coordinates."

	^self new privateSetX: anX setY: anY! !


Stream subclass: #PositionableStream
	instanceVariableNames: 'collection position readLimit'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

!PositionableStream methodsFor: 'accessing' stamp: 'jmv 11/17/2016 09:06:59'!
                   peek
	"Answer what would be returned if the message next were sent to the 
	receiver. If the receiver is at the end, answer nil."

	| nextObject |
	position < readLimit ifTrue: [
		^collection at: position+1 ].
	self atEnd ifTrue: [^nil].
	nextObject _ self next.
	position _ position - 1.
	^nextObject! !

!PositionableStream methodsFor: 'testing' stamp: 'jmv 11/17/2016 10:28:06'!
 atEnd
	"Answer whether the receiver can access any more objects."

	^position >= readLimit! !

!PositionableStream methodsFor: 'testing' stamp: 'jmv 1/3/2017 10:57:48'!
                       isText
	"Return true if the receiver is a Text stream"
	^collection is: #Text! !

!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 7/17/2017 15:45:10'!
fileInAnnouncing: announcement
	"This is special for reading expressions from text that has been formatted 
	with exclamation delimitors. The expressions are read and passed to the 
	Compiler. Answer the result of compilation.  Put up a progress report with
     the given announcement as the title."

	| val chunk |
	announcement 
		displayProgressAt: Sensor mousePoint
		from: 0
		to: self size
		during: [ :barBlock | 
			[ self atEnd ] whileFalse: [
					barBlock value: self position.
					self skipSeparators.
					
					[
						val := (self peekFor: $!!) 
								ifTrue: [
									chunk := self nextChunk.
									"These are the ones that should do nothing, 
									because next line is a doit that does the stuff
									(or because it is handled elsewhere)"
									(chunk beginsWith: 'description:  ')
									| (chunk beginsWith: 'provides: ')
									| (chunk beginsWith: 'requires: ')
									| (chunk beginsWith: 'classDefinition: ')
									| (chunk beginsWith: 'classRemoval: ')
									| (chunk beginsWith: 'methodRemoval: ')
									| (chunk beginsWith: 'classMoveToSomePackage: ')
									| (chunk beginsWith: 'methodMoveToSomePackage: ')
										ifFalse: [(Compiler evaluate: chunk logged: false) scanFrom: self]]
								ifFalse: [
									chunk := self nextChunk.
									self checkForPreamble: chunk.
									[ Compiler evaluate: chunk logged: true ]
										on: Error
										do: [ :ex |
											ex print.
											('while evaluating: ', chunk) print.
											ex pass ]
										]] 
							on: InMidstOfFileinNotification
							do: [ :ex | ex resume: true ] ].
			].
	"Note:  The main purpose of this banner is to flush the changes file."
	Smalltalk logChange: '----End fileIn of ' , self name , '----'.
	^val! !

!PositionableStream methodsFor: 'gui' stamp: 'jmv 7/17/2017 15:38:57'!
              untilEnd: aBlock displayingProgress: aString
	aString
		displayProgressAt: Sensor mousePoint
		from: 0 to: self size
		during: [ :barBlock |
			[ self atEnd ] whileFalse: [
				barBlock value: self position.
				aBlock value ]]! !


CodeWindow subclass: #PreDebugWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!

!PreDebugWindow methodsFor: 'GUI building' stamp: 'HAW 1/12/2017 18:47:35'!
buttonRowForPreDebugWindow: aDebugger
	| row aButton triads buttons |
	buttons _ OrderedCollection new.
	triads _ OrderedCollection withAll: self preDebugButtonSpec.
	aDebugger shouldBeAbleToCreateMethod ifTrue: [ triads add: { 'Create'. #createMethod. 'create the missing method' }].
	
	triads do: [ :triad |
		aButton _ PluggableButtonMorph new model: self.
		aButton label: triad first.
		aButton action: triad second.
		aButton setBalloonText: triad third.
		buttons add: aButton].
	
	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: Color transparent.
	row separation: 1.
	row addMorphs: buttons.
	^row! !

!PreDebugWindow methodsFor: 'GUI building' stamp: 'jmv 6/19/2017 16:01:38'!
 initialExtent
	^ `640 @ 320`! !

!PreDebugWindow methodsFor: 'button actions' stamp: 'HAW 1/12/2017 17:06:43'!
                 createMethod
	"Should only be called when this Debugger was created in response to a
	MessageNotUnderstood exception. Create a stub for the method that was
	missing and proceed into it."
	
	model createMethod.
	self debug
! !


PreDebugWindow class
	instanceVariableNames: ''!

!PreDebugWindow class methodsFor: 'instance creation' stamp: 'jmv 1/2/2017 14:19:05'!
                    open: model label: aString message: messageString
	|  window |
	Preferences usePreDebugWindow
		ifTrue: [
			window _ self new.
			window
				model: model;
				buildMorphicWindowMessage: messageString print.
			aString ifNotNil: [ window setLabel: aString ].
			 window openInWorld ]
		ifFalse: [
			model openFullMorphicLabel: aString ]! !


Preferences class
	instanceVariableNames: ''!

!Preferences class methodsFor: 'fonts' stamp: 'jmv 10/1/2017 17:11:24'!
                  defaultFontFamily
	"Answer the default font family name"

	^self parameters at: #defaultFontFamily ifAbsentPut: [ AbstractFont familyNames first ]! !

!Preferences class methodsFor: 'fonts' stamp: 'jmv 9/25/2017 20:40:23'!
 restoreDefaultFonts
	"Since this is called from menus, we can take the opportunity to prompt for missing font styles.
	Preferences restoreDefaultFonts
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 9)
			(setListFontTo: 9)
			(setMenuFontTo: 10)
			(setWindowTitleFontTo: 12)
			(setCodeFontTo: 9)
			(setButtonFontTo: 9))! !

!Preferences class methodsFor: 'fonts' stamp: 'jmv 9/25/2017 20:33:41'!
                               setDefaultFont: fontFamilyName spec: defaultFontsSpec
		
	| font |
	defaultFontsSpec do: [ :triplet |
		font _ AbstractFont familyName: fontFamilyName pointSize: triplet second.
		font ifNil: [ font _ AbstractFont default ]. 
		triplet size > 2 ifTrue: [
			font _ font emphasized: triplet third ].
		self
			perform: triplet first
			with: font]! !

!Preferences class methodsFor: 'fonts' stamp: 'jmv 9/25/2017 20:22:40'!
                         setDefaultFontFamilyTo: aString

	self parameters at: #defaultFontFamily put: aString! !

!Preferences class methodsFor: 'halos' stamp: 'pb 6/9/2017 00:46:36'!
iconicHaloSpecifications
	"Answer an array that characterizes the locations, colors, icons, and selectors of the halo handles that may be used in the iconic halo scheme"

	"
	Preferences resetHaloSpecifications
	"

^ #(
	"selector						horiz				vert					color info						icon key 						balloon help
	 ---------						------				-----------			-------------------------------		---------------"
	(addCollapseHandle:		left				topCenter		(tan)							haloCollapseIcon 			'Collapse')
	(addDebugHandle:			right				topCenter		(orange)						haloDebugIcon 				'Debug')
	(addDismissHandle:			left				top				(red)							haloDismissIcon 				'Remove')
	"FIXME - Currently non-functional...
	(addRotateHandle:			left				bottom			(blue)							haloRotateIcon 				'Rotate')
	"
	(addMenuHandle:			leftCenter		top				(blue lighter)					haloMenuIcon 				'Menu')
	(addGrabHandle:				center			top				(black)							haloGrabIcon 				'Pick up')
	(addDragHandle:				rightCenter		top				(brown)						haloDragIcon 				'Move')
	(addDupHandle:				right				top				(green)						haloDuplicateIcon 			'Duplicate')	
	(addHelpHandle:				center			bottom			(lightBlue)					haloHelpIcon 				'Help')
	(addGrowHandle:			right				bottom			(yellow)						haloScaleIcon 				'Change size')
	(addFontSizeHandle:		leftCenter		bottom			(lightGreen)					haloFontSizeIcon 			'Change font')
	(addFontEmphHandle:		rightCenter		bottom			(lightBrown darker)			haloFontEmphasisIcon 		'Emphasis & alignment')
	"FIXME - Currently non-functional...
	(addRecolorHandle:			right				bottomCenter	(magenta darker)			haloColorIcon 				'Change color')
	"
)! !

!Preferences class methodsFor: 'halos' stamp: 'jmv 4/20/2015 16:17'!
    installHaloSpecsFromArray: anArray

	| aColor |
	^ self parameters at: #HaloSpecs put: (anArray collect: [ :each |
				aColor _ Color.
				each fourth do: [ :sel | aColor _ aColor perform: sel].
				HaloSpec new 
					horizontalPlacement: each second
					verticalPlacement: each third 
					color: aColor
					iconSymbol: each fifth
					addHandleSelector: each first
					hoverHelp: each sixth])! !

!Preferences class methodsFor: 'personalization' stamp: 'jmv 1/15/2017 18:51:02'!
                            taskbarIncludesAllWindows
	"
	true: All windows are included in Taskbar
	false: Only collapsed windows are included in Taskbar
	"
	^ self
		valueOfFlag: #taskbarIncludesAllWindows
		ifAbsent: [ true ].! !

!Preferences class methodsFor: 'personalization' stamp: 'jmv 1/2/2017 14:18:06'!
 usePreDebugWindow
	^ self
		valueOfFlag: #usePreDebugWindow
		ifAbsent: [ false ].! !

!Preferences class methodsFor: 'shout' stamp: 'jmv 9/17/2017 21:27:39'!
 backgroundColorFillsAllBackground
	"I.e. do fill all whitespace (tabs and space at right of end of text) with backgroundColor"
	^ self
		valueOfFlag: #backgroundColorFillsAllBackground
		ifAbsent: [true]! !

!Preferences class methodsFor: 'shout' stamp: 'jmv 9/10/2017 16:40:28'!
        highlightBlockNesting
	^ self
		valueOfFlag: #highlightBlockNesting
		ifAbsent: [true]! !

!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 9/25/2017 20:40:14'!
            bigFonts
	"Sets not only fonts but other GUI elements
	to fit high resolution or large screens
	Preferences bigFonts
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 11)
			(setListFontTo: 11)
			(setMenuFontTo: 12)
			(setWindowTitleFontTo: 14)
			(setCodeFontTo: 11)
			(setButtonFontTo: 11)).
	Preferences enable: #biggerCursors! !

!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 9/25/2017 20:40:20'!
       hugeFonts
	"Sets not only fonts but other GUI elements
	to fit very high resolution or very large screens
	Preferences hugeFonts
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 17)
			(setListFontTo: 17)
			(setMenuFontTo: 17)
			(setWindowTitleFontTo: 22)
			(setCodeFontTo: 17)
			(setButtonFontTo: 17)).
	Preferences enable: #biggerCursors! !

!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 9/25/2017 20:40:26'!
                           smallFonts
	"Sets not only fonts but other GUI elements
	to fit low resolution or small screens
	Preferences smallFonts
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 8)
			(setListFontTo: 8)
			(setMenuFontTo: 8)
			(setWindowTitleFontTo: 11)
			(setCodeFontTo: 8)
			(setButtonFontTo: 8)).
	Preferences disable: #biggerCursors! !

!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 9/25/2017 20:40:30'!
        standardFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences standardFonts
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 9)
			(setListFontTo: 9)
			(setMenuFontTo: 10)
			(setWindowTitleFontTo: 12)
			(setCodeFontTo: 9)
			(setButtonFontTo: 9)).
	Preferences disable: #biggerCursors! !

!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 9/25/2017 20:40:32'!
                             tinyFonts
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences tinyFonts
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 7)
			(setListFontTo: 5)
			(setMenuFontTo: 5)
			(setWindowTitleFontTo: 7)
			(setCodeFontTo: 5)
			(setButtonFontTo: 5)).
	Preferences disable: #biggerCursors! !

!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 9/25/2017 20:40:36'!
 veryBigFonts
	"Sets not only fonts but other GUI elements
	to fit very high resolution or very large screens
	Preferences veryBigFonts
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 14)
			(setListFontTo: 14)
			(setMenuFontTo: 14)
			(setWindowTitleFontTo: 17)
			(setCodeFontTo: 14)
			(setButtonFontTo: 14)).
	Preferences enable: #biggerCursors! !

!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 9/25/2017 20:40:39'!
                     verySmallFonts
	"Sets not only fonts but other GUI elements
	to fit low resolution or small screens
	Preferences verySmallFonts
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 8)
			(setListFontTo: 7)
			(setMenuFontTo: 7)
			(setWindowTitleFontTo: 9)
			(setCodeFontTo: 7)
			(setButtonFontTo: 7)).
	Preferences disable: #biggerCursors! !

!Preferences class methodsFor: 'start up' stamp: 'HAW 9/9/2017 12:07:37'!
                checkLostChangesOnStartUp
	^ self
		valueOfFlag: #checkLostChangesOnStartUp
		ifAbsent: [ true ].! !


Link subclass: #Process
	instanceVariableNames: 'suspendedContext priority myList threadId name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Processes'!

!Process methodsFor: 'changing suspended state' stamp: 'HAW 7/29/2017 16:00:49'!
                         stepToHome: aContext 
	"Resume self until the home of top context is aContext.  Top context may be a block context.
	 Catch any UnhandledErrors that are created while stepping, answering the relevant signalerContext
	 if so. Note that this will cause weird effects if using through to step through UnhandledError
	 code, but as the doctor ordered, don't do that; use over or into instead."

	| home anError |
	
	home := aContext home.
	[suspendedContext := suspendedContext step.
	home == suspendedContext home or: [home isDead]] whileFalse:
		[(suspendedContext selector == #signalForException:
			and: [(suspendedContext receiver isBehavior 
			and: [suspendedContext receiver includesBehavior: UnhandledError])
			and: [anError := suspendedContext tempAt: 1.
				((suspendedContext objectClass: anError) includesBehavior: Exception)
			and: [anError canSearchForSignalerContext]]]) ifTrue:
				[anError signalerContext ifNotNil: [:unhandledErrorSignalerContext|
					[unhandledErrorSignalerContext == suspendedContext] whileFalse:
						[self completeStep: suspendedContext].
					"Give a debugger a chance to update its title to reflect the new exception"
					 Notification new
						tag: {unhandledErrorSignalerContext. anError};
						signal.
					^unhandledErrorSignalerContext]]].
		
	^suspendedContext! !


Object subclass: #ProgessiveTestRunner
	instanceVariableNames: 'testSuite testsStream progressBar testResult testRunIncrement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

!ProgessiveTestRunner methodsFor: 'initialization' stamp: 'HAW 2/1/2017 19:20:06'!
                              initializeFor: aTestSuite

	testSuite _ aTestSuite.
	! !

!ProgessiveTestRunner methodsFor: 'evaluating' stamp: 'HAW 1/31/2017 11:50:37'!
                      value

	testsStream _ ReadStream on: testSuite tests.
	testsStream atEnd
		ifTrue: [ self informNoTestToRun ]
	 	ifFalse:[ self createProgressBarAndRun ]! !

!ProgessiveTestRunner methodsFor: 'progress bar - private' stamp: 'HAW 1/31/2017 10:25:22'!
      calculateTestRunIncrement
	
	testRunIncrement _ 1/testsStream size! !

!ProgessiveTestRunner methodsFor: 'progress bar - private' stamp: 'HAW 1/31/2017 10:25:31'!
                             createProgressBar
		
	progressBar _ ProgressMorph label: testSuite name.
	self calculateTestRunIncrement.
	self updateProgressBarSubLabel.
	! !

!ProgessiveTestRunner methodsFor: 'progress bar - private' stamp: 'HAW 1/31/2017 10:25:43'!
                   updateDoneIncrement 

 	progressBar incrDone: testRunIncrement 
	! !

!ProgessiveTestRunner methodsFor: 'progress bar - private' stamp: 'HAW 1/31/2017 11:10:25'!
                              updateProgressBarSubLabel

	testsStream atEnd ifFalse: [
		progressBar subLabel: testsStream next printString, ' (', testsStream position printString, '/', testsStream size printString, ')' ].! !

!ProgessiveTestRunner methodsFor: 'show result - private' stamp: 'HAW 1/31/2017 20:05:25'!
informAllTestPassed 
	
	PopUpMenu inform: testResult printString.
	! !

!ProgessiveTestRunner methodsFor: 'show result - private' stamp: 'HAW 1/31/2017 10:05:21'!
                             informNoTestToRun
		
	 PopUpMenu inform: 'No test to run'! !

!ProgessiveTestRunner methodsFor: 'show result - private' stamp: 'HAW 6/3/2017 20:40:29'!
        openTestResultWindow

	TestResultWindow openFor: testResult 
	! !

!ProgessiveTestRunner methodsFor: 'show result - private' stamp: 'HAW 6/3/2017 20:40:17'!
   showDeffects
	
	 | defects |
			
	defects _ 	testResult defects.
	defects size = 1
		ifTrue: [ defects anyOne debug ] 
		ifFalse: [ self openTestResultWindow]! !

!ProgessiveTestRunner methodsFor: 'evaluating - private' stamp: 'HAW 2/1/2017 19:14:08'!
    createProgressBarAndRun

	self createProgressBar.
	[ self runSuiteShowingProgress ] fork! !

!ProgessiveTestRunner methodsFor: 'evaluating - private' stamp: 'HAW 2/1/2017 19:26:59'!
          registerTestSuiteAction
		
	testSuite when: #changed: send: #testRun: to: self! !

!ProgessiveTestRunner methodsFor: 'evaluating - private' stamp: 'HAW 1/31/2017 10:09:41'!
                   runSuite
		
	testResult _ testSuite run.	
	testResult hasPassed 
		ifTrue: [ self informAllTestPassed ] 
		ifFalse: [self showDeffects ]
	! !

!ProgessiveTestRunner methodsFor: 'evaluating - private' stamp: 'HAW 1/31/2017 11:47:58'!
                       runSuiteShowingProgress

	[ self registerTestSuiteAction. 
	progressBar openInWorld.
	self runSuite ] ensure: [
		self unregisterTestSuiteAction.
		WorldState addDeferredUIMessage: [progressBar dismissMorph] ].
	! !

!ProgessiveTestRunner methodsFor: 'evaluating - private' stamp: 'HAW 2/1/2017 19:19:28'!
              testRun: aTest

	self updateProgressBarSubLabel.
	self updateDoneIncrement 
	
		! !

!ProgessiveTestRunner methodsFor: 'evaluating - private' stamp: 'HAW 1/31/2017 10:04:32'!
                 unregisterTestSuiteAction
	
	testSuite releaseActionMap ! !


ProgessiveTestRunner class
	instanceVariableNames: ''!

!ProgessiveTestRunner class methodsFor: 'instance creation' stamp: 'HAW 1/31/2017 09:37:34'!
             for: aTestSuite

	^self new initializeFor: aTestSuite! !


BorderedRectMorph subclass: #ProgressBarMorph
	instanceVariableNames: 'value progressColor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!ProgressBarMorph methodsFor: 'accessing' stamp: 'pb 7/6/2017 02:42:04'!
                   progressValue
	^value! !

!ProgressBarMorph methodsFor: 'accessing' stamp: 'pb 7/6/2017 02:42:12'!
                             progressValue: aValue
	value _ aValue.
	self redrawNeeded! !

!ProgressBarMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2011 10:52'!
                     defaultColor
	^Color white! !

!ProgressBarMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2011 10:53'!
                    initialize
	super initialize.
	progressColor _ Color gray.
	value _ 0.0! !

!ProgressBarMorph methodsFor: 'menu' stamp: 'pb 7/6/2017 02:57:29'!
                changeProgressValue: evt
	| answer |
	answer _ FillInTheBlankMorph
		request: 'Enter new value (0 - 1.0)'
		initialAnswer: self progressValue contents asString.
	answer isEmptyOrNil ifTrue: [^ self].
	self progressValue: answer asNumber! !


ProgressBarMorph class
	instanceVariableNames: ''!

!ProgressBarMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/9/2017 00:05:22'!
                             categoryInNewMorphMenu
	^ 'Widgets'! !


Exception subclass: #ProgressInitiationException
	instanceVariableNames: 'workBlock maxVal minVal aPoint progressTitle currentVal'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions Kernel'!

!ProgressInitiationException methodsFor: 'as yet unclassified' stamp: 'jmv 6/19/2017 16:15:27'!
     defaultAction

	| delta textFrame barFrame outerFrame result range width filledWidth f h textWidth textForm innerBarFrame oldFilledWidth oldFilledWidth2 prevContents |
	f _ AbstractFont default.
	h _ f height * 3//2.
	textWidth _ (f widthOfString: progressTitle) + h.
	width _ 150 max: textWidth.

	textForm _ Form extent: width@h depth: 32.
	textForm fillBlack.
	textForm fillWhite: (textForm boundingBox insetBy: 2).
	progressTitle displayOn: textForm at: (width-textWidth+h//2@4).
	barFrame _ Rectangle center: aPoint extent: width@h.
	textFrame _ `0@0` extent: width@h.
	textFrame _ textFrame
					aligned: textFrame bottomCenter
					with: barFrame topCenter + `0@2`.
	outerFrame _ barFrame merge: textFrame.
	delta _ outerFrame amountToTranslateWithin: Display boundingBox.
	barFrame _ barFrame translatedBy: delta.
	textFrame _ textFrame translatedBy: delta.
	outerFrame _ outerFrame translatedBy: delta.
	prevContents _ Form fromDisplay: outerFrame.
	range _ maxVal = minVal ifTrue: [1] ifFalse: [maxVal - minVal].  "Avoid div by 0"
	innerBarFrame _ barFrame insetBy: 2.
	textForm displayAt: textFrame topLeft.
	Display fillBlack: barFrame.
	Display fillWhite: innerBarFrame.
	oldFilledWidth _ 0.
	oldFilledWidth2 _ 0.
	result _ workBlock value:  "Supply the bar-update block for evaluation in the work block"
		[ :barVal |
		barVal
			ifNotNil: [ currentVal _ barVal ]
			ifNil: [
				currentVal _ currentVal + 1.
				currentVal >= maxVal
					ifTrue: [ currentVal _ minVal ]].
		filledWidth _ ((barFrame width-4) asFloat * ((currentVal-minVal) asFloat / range min: 1.0)) asInteger.
		filledWidth  > oldFilledWidth ifTrue: [
			textForm displayAt: textFrame topLeft.
			Display fillBlack: barFrame.
			Display fillWhite: innerBarFrame.
			Display fillGray: (barFrame topLeft + `2@2` extent: filledWidth@17).
			filledWidth -200 > oldFilledWidth2
				ifFalse: [
					"Usually just request an update, to be done asynchronously."
					DisplayScreen screenUpdateRequired: outerFrame ]
				ifTrue: [
					"Once in a while, force a real screen update (warning: really slow on MacOS if done too often)"
					Display forceToScreen: outerFrame. oldFilledWidth2 _ filledWidth ].
			oldFilledWidth _ filledWidth ]].
	prevContents displayAt: outerFrame topLeft.
	self resume: result! !


ProgressInitiationException class
	instanceVariableNames: ''!

!ProgressInitiationException class methodsFor: 'examples and tests' stamp: 'jmv 7/17/2017 15:39:39'!
               testInnermost

	"
	test the progress code WITHOUT special handling
	
	ProgressInitiationException  testInnermost
	"

	^'Now here''s some Real Progress'
		displayProgressAt: Sensor mousePoint
		from: 0 
		to: 10
		during: [ :barBlock |
			1 to: 10 do: [ :x | 
				barBlock value: x.
				(Delay forMilliseconds: 500) wait.
				x = 5 ifTrue: [1/0].	"just to make life interesting"
			].
			'done'
		].

! !


LayoutMorph subclass: #ProgressMorph
	instanceVariableNames: 'labelMorph subLabelMorph progress'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!ProgressMorph methodsFor: 'accessing' stamp: 'pb 7/6/2017 02:57:41'!
                      done
	^progress progressValue! !

!ProgressMorph methodsFor: 'accessing' stamp: 'pb 7/6/2017 02:52:47'!
                        done: amountDone
	progress progressValue: ((amountDone min: 1.0) max: 0.0)! !

!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2011 10:55'!
       defaultColor
	^Color veryLightGray! !

!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:10:33'!
            initialize
	super initialize.
	self separation: 0.
	labelMorph _ StringMorph contents: '' font: AbstractFont default.
	subLabelMorph _ StringMorph contents: '' font: AbstractFont default.
	progress _ ProgressBarMorph new.
	progress morphExtent: `200 @ 15`.
	self addMorphFront: labelMorph.
	self addMorphFront: subLabelMorph.
	self addMorph: progress fixedHeight: 15.! !


ProgressMorph class
	instanceVariableNames: ''!

!ProgressMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/9/2017 00:10:17'!
categoryInNewMorphMenu
	^ 'Widgets'! !


PositionableStream subclass: #ReadStream
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

!ReadStream methodsFor: 'accessing' stamp: 'jmv 11/17/2016 09:59:57'!
                            next
	"Answer the next object in the Stream represented by the receiver."

	^position >= readLimit
		ifFalse: [collection at: (position _ position + 1)]! !

!ReadStream methodsFor: 'accessing' stamp: 'jmv 6/26/2017 19:34:17'!
                              readInto: byteArray startingAt: startIndex count: count
	"Read n objects into the given collection. 
	Return aCollection or a partial copy if less than
	n elements have been read."
	| max |
	max _ (readLimit - position) min: count.
	byteArray 
		replaceFrom: startIndex 
		to: startIndex+max-1
		with: collection
		startingAt: position+1.
	position _ position + max.
	^max! !


WriteStream subclass: #ReadWriteStream
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

!ReadWriteStream methodsFor: 'accessing' stamp: 'jmv 11/17/2016 10:28:45'!
        next
	"Return the next object in the Stream represented by the receiver."

	"treat me as a FIFO"
	^ position >= readLimit
		ifFalse: [collection at: (position _ position + 1)]! !


RealEstateAgent class
	instanceVariableNames: ''!

!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 3/15/2017 14:06:54'!
                              maximumUsableAreaInWorld: aWorldOrNil

	| allowedArea |
	allowedArea _ Display boundingBox.
	aWorldOrNil ifNotNil: [
		allowedArea _ allowedArea intersect: aWorldOrNil viewBox.
		aWorldOrNil taskbar ifNotNil: [ :tb |
			tb morphBoundsInWorld ifNotNil: [ :r |
				allowedArea _ (allowedArea areasOutside: r) first ]]].
	^allowedArea
! !

!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 6/19/2017 16:10:37'!
                     staggerOffset
	^`6 @ 20`! !

!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 6/19/2017 16:10:46'!
         standardWindowExtent
	"Answer the standard default extent for new windows.  "

	| effectiveExtent width strips height grid allowedArea maxLevel |
	effectiveExtent _ self maximumUsableArea extent
					- (self scrollBarSetback @ self screenTopSetback).
	Preferences reverseWindowStagger ifTrue:
		["NOTE: following copied from strictlyStaggeredInitialFrameFor:"
		allowedArea _ self maximumUsableArea insetBy: (
			self scrollBarSetback @ self screenTopSetback extent: `0@0`
		).
		"Number to be staggered at each corner (less on small screens)"
		maxLevel _ allowedArea area > 700000 ifTrue: [3] ifFalse: [2].
		"Amount by which to stagger (less on small screens)"
		grid _ allowedArea area > 700000 ifTrue: [40] ifFalse: [20].
		^ (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))) min: `52@40` * Preferences standardCodeFont height ].
	width _ (strips _ self windowColumnsDesired) > 1
		ifTrue:
			[effectiveExtent x // strips]
		ifFalse:
			[(3 * effectiveExtent x) // 4].
	height _ (strips _ self windowRowsDesired) > 1
		ifTrue:
			[effectiveExtent y // strips]
		ifFalse:
			[(3 * effectiveExtent y) //4].
	^ width @ height

"RealEstateAgent standardWindowExtent"! !

!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 6/19/2017 16:10:58'!
           strictlyStaggeredInitialFrameFor: aStandardSystemView initialExtent: initialExtent world: aWorld 
	"This method implements a staggered window placement policy that I (di) like.
	Basically it provides for up to 4 windows, staggered from each of the 4 corners.
	The windows are staggered so that there will always be a corner visible."

	| allowedArea grid initialFrame otherFrames cornerSel corner delta putativeCorner free maxLevel |
	allowedArea := (self maximumUsableAreaInWorld: aWorld) 
				insetBy: (self scrollBarSetback @ self screenTopSetback extent: `0 @ 0`).
	"Number to be staggered at each corner (less on small screens)"
	maxLevel := allowedArea area > 300000 ifTrue: [3] ifFalse: [2].
	"Amount by which to stagger (less on small screens)"
	grid := allowedArea area > 500000 ifTrue: [40] ifFalse: [20].
	initialFrame := `0 @ 0` extent: initialExtent.
	"min: (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))))
							min: 600@400"
	otherFrames := (SystemWindow windowsIn: aWorld satisfying: [ :w | w visible and: [w isCollapsed not]]) 
						collect: [:w | w morphBoundsInWorld].
	otherFrames _ otherFrames reject: [ :f | f isNil ].
	0 to: maxLevel do: [ :level | 
			1 to: 4 do: [:ci | 
					cornerSel := #(#topLeft #topRight #bottomRight #bottomLeft) at: ci.
					corner := allowedArea perform: cornerSel.
					"The extra grid//2 in delta helps to keep title tabs distinct"
					delta := ((maxLevel - level) * grid + (grid // 2)) @ (level * grid).
					1 to: ci - 1 do: [ :i | delta _ delta y negated @ delta x ].	"slow way"
					putativeCorner := corner + delta.
					free := true.
					otherFrames do: [ :w |
						free := free & ((w perform: cornerSel) ~= putativeCorner)].
					free 
						ifTrue: [
							^(initialFrame aligned: (initialFrame perform: cornerSel)
								with: putativeCorner) translatedAndSquishedToBeWithin: allowedArea]]].
	"If all else fails..."
	^(self scrollBarSetback @ self screenTopSetback 
		extent: initialFrame extent) translatedAndSquishedToBeWithin: allowedArea! !


Object subclass: #Rectangle
	instanceVariableNames: 'origin corner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Primitives'!

!Rectangle methodsFor: 'accessing' stamp: 'jmv 6/19/2017 16:11:04'!
                               innerCorners
	"Return an array of inner corner points,
	ie, the most extreme pixels included,
	in the order of a quadrilateral spec for WarpBlt"
	| r1 |
	r1 _ self topLeft corner: self bottomRight - `1@1`.
	^ Array with: r1 topLeft with: r1 bottomLeft with: r1 bottomRight with: r1 topRight! !

!Rectangle methodsFor: 'transforming' stamp: 'jmv 9/24/2013 22:36'!
                     newRectFrom: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect buttonStart buttonNow aHand delay |
	delay _ Delay forMilliseconds: 10.
	buttonStart _ buttonNow _ Sensor isAnyButtonPressed.
	rect _ self.
	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
	[buttonNow == buttonStart] whileTrue: 
		[delay wait.
		buttonNow _ Sensor isAnyButtonPressed.
		newRect _ newRectBlock value: rect.
		newRect = rect ifFalse:
			[Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
			Display border: newRect width: 2 rule: Form reverse fillColor: Color gray.
			rect _ newRect]].
	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
	" pay the price for reading the sensor directly ; get this party started "
	aHand _ self runningWorld activeHand.
	aHand
		newMouseFocus: nil;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent discardingMouseEvents: false.
	^ rect! !


Morph subclass: #RectangleLikeMorph
	instanceVariableNames: 'extent color'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

!RectangleLikeMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 18:46'!
    defaultColor
	^ Color orange! !

!RectangleLikeMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:11:08'!
             initialize
	super initialize.
	extent _ `50@40`.
	color _ self defaultColor! !

!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 9/22/2012 14:56'!
       morphHeight

"Ensure everybody wants our coordinates!!"
	self flag: #jmvVer2.
	^ extent y! !

!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 2/16/2016 12:58'!
                         morphPosition: newPos extent: newExtent
	"Change the position of this morph. Argument is in owner's coordinates."

	| oldBoundsInWorld someChange |

	"Ask for the old bounds before updating them, but ask for repair only if extent or position has really changed."
	oldBoundsInWorld _ self morphBoundsInWorld.
	someChange _ false.
	(location isTranslation: newPos) ifFalse: [
		location _ location withTranslation: newPos.
		someChange _ true ].

	extent = newExtent ifFalse: [
		(self privateExtent: newExtent) ifTrue: [
			someChange _ true ]].

	someChange ifTrue: [
		"Ask for the old bounds before updating them, but ask for repair only if extent or position has really changed."
		oldBoundsInWorld ifNotNil: [
			self invalidateDisplayRect: oldBoundsInWorld from: nil ].
		self someSubmorphPositionOrExtentChanged.
		owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].
		self redrawNeeded ]! !

!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 9/22/2012 14:57'!
         morphWidth

"Ensure everybody wants our coordinates!!"
	self flag: #jmvVer2.
	^ extent x! !


RectangleLikeMorph class
	instanceVariableNames: ''!

!RectangleLikeMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:47:05'!
             categoryInNewMorphMenu
	^ 'Kernel'! !


DataStream subclass: #ReferenceStream
	instanceVariableNames: 'references objects currentReference fwdRefEnds blockers skipping'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Object Storage'!

!ReferenceStream methodsFor: 'statistics' stamp: 'jmv 7/17/2017 15:40:06'!
                         statisticsOfRefs
	"Analyze the information in references, the objects being written out"

	| parents n kids nm ownerBags tallies owners objParent normalReferences |
	normalReferences _ self references.	"Exclude unrealized weaks"
	parents _ IdentityDictionary new: normalReferences size * 2.
	n _ 0.
	'Finding Owners...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: normalReferences size
	during: [ :barBlock |
	normalReferences keysDo:
		[ :parent | barBlock value: (n _ n+1).
		kids _ parent class isFixed
			ifTrue: [(1 to: parent class instSize) collect: [:i | parent instVarAt: i]]
			ifFalse: [parent class isBits ifTrue: [Array new]
					 ifFalse: [(1 to: parent basicSize) collect: [:i | parent basicAt: i]]].
		(kids select: [:x | normalReferences includesKey: x])
			do: [:child | parents at: child put: parent]]].
	ownerBags _ Dictionary new.
	tallies _ Bag new.
	n _ 0.
	'Tallying Owners...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: normalReferences size
	during: [ :barBlock |
	normalReferences keysDo:  "For each class of obj, tally a bag of owner classes"
		[ :obj | barBlock value: (n _ n+1).
		nm _ obj class name.
		tallies add: nm.
		owners _ ownerBags at: nm ifAbsent: [ownerBags at: nm put: Bag new].
		(objParent _ parents at: obj ifAbsent: nil) ifNotNil: [
			owners add: objParent class name]]].
	^ String streamContents: [ :strm | 
		tallies sortedCounts do: [ :assn |
			n _ assn key.  nm _ assn value.
			owners _ ownerBags at: nm.
			strm newLine; nextPutAll: nm; space; print: n.
			owners size > 0 ifTrue: [
				strm newLine; tab; print: owners sortedCounts]]]! !


ReferenceStream class
	instanceVariableNames: ''!

!ReferenceStream class methodsFor: 'as yet unclassified'!
        example2
"Here is the way to use DataStream and ReferenceStream:
	rr _ ReferenceStream fileNamed: ''test.obj''.
	rr nextPut: <your object>.
	rr close.

To get it back:
	rr _ ReferenceStream fileNamed: ''test.obj''.
	<your object> _ rr next.
	rr close.
"
"An example and test of DataStream/ReferenceStream.
	 11/19/92 jhm: Use self testWith:."
	"ReferenceStream example2"
	| input sharedPoint |

	"Construct the test data."
	input _ Array new: 9.
	input at: 1 put: nil.
	input at: 2 put: true.
	input at: 3 put: false.
	input at: 4 put: #(-4 -4.0 'four' four).
	input at: 5 put: (Form extent: 63 @ 50 depth: 8).
		(input at: 5) fillWithColor: Color lightOrange.
	input at: 6 put: 1024 @ -2048.
	input at: 7 put: input. "a cycle"
	input at: 8 put: (Array with: (sharedPoint _ 0 @ -30000)).
	input at: 9 put: sharedPoint.

	"Write it out, read it back, and return it for inspection."
	^ self testWith: input
! !

!ReparseAfterSourceEditing commentStamp: 'jmv 9/6/2017 10:05:54' prior: 0!
       A ReparseAfterSourceEditing is a Notification used to restart the syntax parsing phase of a compilation after a change in source code.!

RectangleLikeMorph subclass: #ResizeMorph
	instanceVariableNames: 'gridLineWidth gridColor selectionColor outlineMorph grid from to action'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 23:14'!
                   selectTo: localEventPosition
	| newTo |
	newTo _ self toGridPoint: localEventPosition.
	newTo ~= to ifTrue: [
		to _ newTo.
		self redrawNeeded.
		self updateOutlineMorph]! !

!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/17/2015 15:35'!
   selectionRectangle: aRectangle
	^(from corner: to + 1) scaledBy: aRectangle // grid! !

!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/17/2015 15:34'!
                           toGridPoint: aPoint
	^(aPoint min: extent - 1) // (extent // grid)! !

!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 23:15'!
            updateOutlineMorph
	| rectangle |
	rectangle _ self selectionRectangle: Display extent.
	outlineMorph
		morphPosition: rectangle origin extent: rectangle extent;
		show! !

!ResizeMorph methodsFor: 'drawing' stamp: 'bp 10/18/2015 18:00'!
                  drawGridOn: aCanvas
	0 to: grid x do: [:i |
		| x |
		x _ i * (extent x - gridLineWidth) / grid x.
		aCanvas line: x @ 0 to: x @ (extent y - 2) width: gridLineWidth color: gridColor].
	0 to: grid y do: [:i |
		| y |
		y _ i * (extent y - gridLineWidth) / grid y.
		aCanvas line: 0 @ y to: (extent x - 2) @ y width: gridLineWidth color: gridColor]! !

!ResizeMorph methodsFor: 'drawing' stamp: 'bp 10/11/2015 23:02'!
drawOn: aCanvas
	super drawOn: aCanvas.
	from ifNotNil: [aCanvas fillRectangle: (self selectionRectangle: extent) color: selectionColor].
	self drawGridOn: aCanvas! !

!ResizeMorph methodsFor: 'event handling testing' stamp: 'bp 10/11/2015 19:00'!
        handlesMouseDown: aMouseButtonEvent
	^true! !

!ResizeMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:15:44'!
      initialize
	super initialize.
	extent _ `400@300`.
	color _ Color white.
	grid _ `8@6`.
	gridLineWidth _ 2.
	gridColor _ Color black.
	selectionColor _ Color red! !

!ResizeMorph methodsFor: 'events' stamp: 'bp 10/11/2015 23:18'!
                          mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	from _ self toGridPoint: localEventPosition.
	outlineMorph _ BorderedRectMorph new
		borderColor: Color black;
		color: Color transparent;
		openInWorld;
		hide.
	self selectTo: localEventPosition! !

!ResizeMorph methodsFor: 'events' stamp: 'bp 10/11/2015 23:17'!
                mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	self selectTo: localEventPosition.
	outlineMorph delete.
	action ifNotNil: [
		action value.
		self delete]! !

!ResizeMorph methodsFor: 'events' stamp: 'bp 10/11/2015 21:32'!
           mouseMove: aMouseButtonEvent localPosition: localEventPosition
	self selectTo: localEventPosition! !

!ResizeMorph methodsFor: 'printing' stamp: 'bp 10/11/2015 21:25'!
                        printOn: aStream
	super printOn: aStream.
	aStream space; print: from; space; print: to! !

!ResizeMorph methodsFor: 'accessing' stamp: 'bp 10/11/2015 22:22'!
 action: aBlock
	action _ aBlock! !

!ResizeMorph methodsFor: 'accessing' stamp: 'bp 10/11/2015 19:00'!
                         grid: aPoint
	grid _ aPoint! !


ResizeMorph class
	instanceVariableNames: ''!

!ResizeMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:56:28'!
                        categoryInNewMorphMenu
	^ 'Views'! !


ArrayedCollection variableSubclass: #RunNotArray
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Arrayed'!

!RunNotArray methodsFor: 'private' stamp: 'jmv 1/13/2017 09:58:00'!
                        replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Copied from Array"
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !


Object subclass: #SHParserST80
	instanceVariableNames: 'classOrMetaClass source workspace arguments sourcePosition currentToken currentTokenFirst temporaries instanceVariables errorBlock currentTokenSourcePosition blockDepth bracketDepth ranges blockDepths blockDepthsStartIndexes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Syntax Highlighting'!

!SHParserST80 methodsFor: 'accessing' stamp: 'jmv 9/13/2017 22:00:57'!
                    blockDepths
	^blockDepths! !

!SHParserST80 methodsFor: 'accessing' stamp: 'jmv 9/13/2017 22:01:05'!
                           blockDepthsStartIndexes
	^blockDepthsStartIndexes! !

!SHParserST80 methodsFor: 'accessing' stamp: 'jmv 9/13/2017 20:51:24'!
   ranges
	^ ranges! !

!SHParserST80 methodsFor: 'scan' stamp: 'tween 2/17/2007 14:51'!
          scanWhitespace
	| c |
	
	[c := self currentChar.
	c notNil and: [c isSeparator]] 
		whileTrue: [sourcePosition := sourcePosition + 1].
	c == $" ifTrue: [self scanComment]! !

!SHParserST80 methodsFor: 'parse support' stamp: 'jmv 9/17/2017 19:04:26'!
      enterBlock
	blockDepth _ blockDepth + 1.
	bracketDepth _ bracketDepth + 1.
	blockDepths add: blockDepth.
	blockDepthsStartIndexes add: sourcePosition-1! !

!SHParserST80 methodsFor: 'parse support' stamp: 'jmv 9/17/2017 19:02:56'!
                         leaveBlock
	arguments removeKey: blockDepth ifAbsent: nil.
	temporaries removeKey: blockDepth ifAbsent: nil.
	blockDepth _ blockDepth - 1.
	bracketDepth _ bracketDepth - 1.
	blockDepths add: blockDepth.
	blockDepthsStartIndexes add: sourcePosition! !

!SHParserST80 methodsFor: 'character testing' stamp: 'jmv 12/10/2016 10:24:38'!
                    isBinarySelectorCharacter: aCharacter

	aCharacter isValidInIdentifiers ifTrue: [^false].
	aCharacter isSeparator ifTrue: [^false].

	('"#$'':().;[]{}_`'  includes: aCharacter) 
		ifTrue:[^false].
	aCharacter numericValue = Scanner doItCharacterValue ifTrue: [^false "the doIt char"].
	aCharacter numericValue = 0 ifTrue: [^false].
	"Any other char is ok as a binary selector char."
	^true! !

!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 8/28/2017 16:51:25'!
      isIncompleteReservedName: aString 
	"Answer true if aString is the start of a reserved name, false otherwise"

	self reservedNames do: [ :arg | (arg beginsWith: aString) ifTrue: [ ^true ]].
	^false! !

!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 8/28/2017 16:53:14'!
      resolve: aString

	self reservedNames do: [ :symbol | aString = symbol ifTrue: [^symbol]].
	(self isBlockTempName: aString) ifTrue: [^#blockTempVar].
	(self isBlockArgName: aString) ifTrue: [^#blockArg].
	(self isMethodTempName: aString) ifTrue: [^#tempVar].
	(self isMethodArgName: aString) ifTrue: [^#methodArg].
	(self isInstVarName: aString) ifTrue: [^#instVar].
	(self isWorkspaceVarName: aString) ifTrue: [^#workspaceVar].
	Symbol hasInterned: aString ifTrue: [ :symbol |
		(self isClassVarName: symbol) ifTrue: [ ^#classVar ].
		(self isPoolConstantName: symbol) ifTrue: [ ^#poolConstant].
		(self isGlobal: symbol) ifTrue: [^#globalVar]].
	^self resolvePartial: aString! !

!SHParserST80 methodsFor: 'parse' stamp: 'jmv 9/17/2017 19:03:23'!
                   parse: isAMethod 
	"Parse the receiver's text. If isAMethod is true
    then treat text as a method, if false as an
    expression with no message pattern"

	self initializeInstanceVariables.
	sourcePosition _ 1.
	arguments _ Dictionary new.
	temporaries _ Dictionary new.
	blockDepth _ bracketDepth := 0.
	blockDepths _ OrderedCollection with: blockDepth.
	blockDepthsStartIndexes _ OrderedCollection with: sourcePosition.
	ranges ifNil: [ ranges := OrderedCollection new: 100] ifNotNil: [ ranges reset].
	errorBlock _ [^false].
	[
		self scanNext.
		isAMethod 
			ifTrue: [
				self parseMessagePattern.
				self parsePragmaSequence].
		self parseMethodTemporaries.
		isAMethod ifTrue: [self parsePragmaSequence].
		self parseStatementList.
		currentToken ifNotNil: [self error]
	] ensure: [errorBlock _ nil].
	^true! !

!SHParserST80 methodsFor: 'parse' stamp: 'jmv 9/17/2017 19:05:25'!
      parseBacktick
	self enterBlock.
	self scanPast: #backtick.
	currentTokenFirst == $| ifTrue: [self parseBlockTemporaries].
	self parseStatementList.
	self failUnless: currentTokenFirst == $`.
	self leaveBlock.
	self scanPast: #backtick! !

!SHParserST80 methodsFor: 'parse' stamp: 'jmv 9/17/2017 18:40:55'!
              parseBlock
	self enterBlock.
	self scanPast: #blockStart level: bracketDepth.
	currentTokenFirst == $: ifTrue: [self parseBlockArguments].
	currentTokenFirst == $| ifTrue: [self parseBlockTemporaries].
	self parseStatementList.
	self failUnless: currentTokenFirst == $].
	self leaveBlock.
	self scanPast: #blockEnd level: bracketDepth.! !

!SHParserST80 methodsFor: 'parse' stamp: 'jmv 12/29/2016 11:29:52'!
        parseExternalCall
	self scanNext.
	self failWhen: currentToken isNil.
	self scanPast: #externalCallType.
	currentToken = '*' 
		ifTrue: [self scanPast: #externalCallTypePointerIndicator].
	currentTokenFirst isDigit 
		ifTrue: [self scanPast: #integer]
		ifFalse: 	[
			self failUnless: currentTokenFirst == $'.
			self parseString].
	self failUnless: currentTokenFirst == $(.
	self scanPast: #leftParenthesis.
	[currentTokenFirst ~~ $)] 
		whileTrue: [
			self failWhen: currentToken isNil.
			self scanPast: #externalCallType.
			currentToken = '*' 
				ifTrue: [self scanPast: #externalCallTypePointerIndicator]].
	self scanPast: #rightParenthesis.
	currentToken = 'module:' 
		ifTrue: [
			self scanPast: #module.
			self failUnless: currentTokenFirst == $'.
			self parseString].
	self failUnless: currentToken = '>'.
	self scanPast: #primitiveOrExternalCallEnd! !

!SHParserST80 methodsFor: 'parse' stamp: 'jmv 1/13/2017 09:53:38'!
                       parsePrimitive
	self scanNext.
	currentTokenFirst isDigit 
		ifTrue: [self scanPast: #integer]
		ifFalse: [
			self failUnless: currentTokenFirst == $'.
			self parseString.
			currentToken = 'module:' 
				ifTrue: [
					self scanPast: #module.
					self failUnless: currentTokenFirst == $'.
					self parseString]].
	currentToken = 'error:' ifTrue: [
		self scanPast: #primitive. "there's no rangeType for error"
		self isName
			ifTrue: [ self scanPast: #patternTempVar ]
			ifFalse: [ self parseStringOrSymbol ] ].
	self failUnless: currentToken = '>'.
	self scanPast: #primitiveOrExternalCallEnd! !

!SHParserST80 methodsFor: 'parse' stamp: 'ul 10/12/2010 02:43'!
   parseStringOrSymbol

	currentTokenFirst == $' ifTrue: [ ^self parseString ].
	currentTokenFirst == $# ifTrue: [ ^self parseSymbol ].
	self error! !

!SHParserST80 methodsFor: 'parse' stamp: 'jmv 12/30/2016 10:51:08'!
       parseTerm
	self failWhen: currentToken isNil.
	currentTokenFirst == $( 
		ifTrue: [
			bracketDepth := bracketDepth + 1.
			self scanPast: #leftParenthesis level: bracketDepth.
			self parseExpression.
			self failUnless: currentTokenFirst == $).
			self scanPast: #rightParenthesis level: bracketDepth.
			bracketDepth := bracketDepth - 1.
			^self ].
	currentTokenFirst == $[ ifTrue: [^self parseBlock].
	currentTokenFirst == $` ifTrue: [^self parseBacktick].
	currentTokenFirst == ${ 
		ifTrue: [
			self scanPast: #leftBrace.
			self parseBraceArray.
			^self ].
	self isName ifTrue: [^self scanPast: (self resolve: currentToken)].
	self parseLiteral: false! !

!SHParserST80 methodsFor: 'recording ranges' stamp: 'tween 4/28/2004 10:20'!
                         rangeType: aSymbol start: s end: e 
	^ranges add: (SHRange start: s end: e type: aSymbol)! !

!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 8/28/2017 16:52:46'!
               nonGlobalNamesDo: aBlock
	"Evaluate aBlock over all available names, except for globals"

	self
		blockArgNamesDo: aBlock;
		blockTempNamesDo: aBlock;
		methodArgNamesDo: aBlock;
		methodTempNamesDo: aBlock;
		instVarNamesDo: aBlock;
		classVarNamesDo: aBlock;
		poolConstantNamesDo: aBlock;
		workspaceNamesDo: aBlock.
	self
		reservedNames do: aBlock! !

!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 8/28/2017 17:06:34'!
        reservedNames

	^Theme current pseudoVariables! !

!SHParserST80 methodsFor: 'testing' stamp: 'jmv 8/28/2017 17:14:20'!
        isPartialOrFullIdentifier: aSymbol

	(#(#incompleteIdentifier
		#blockTempVar #blockArg #tempVar #methodArg
		#instVar #classVar 
		#workspaceVar #poolConstant #globalVar ) 
			statePointsTo:aSymbol) ifTrue: [ ^ true ].
	(self reservedNames statePointsTo: aSymbol) ifTrue: [ ^ true ].
	^ false! !


Object subclass: #SHRange
	instanceVariableNames: 'start end type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Syntax Highlighting'!

!SHRange methodsFor: '*OMeta2Extensions' stamp: 'pb 6/25/2015 05:05'!
                     printOn: aStream
	aStream nextPutAll: 'a SHRange('.
	start printOn: aStream.
	aStream nextPutAll: '..'.
	end printOn: aStream.
	aStream nextPut: $:.
	type printOn: aStream.
	aStream nextPut: $).! !


SHTextStyler subclass: #SHTextStylerOMeta2
	instanceVariableNames: 'smalltalkFallbackStyler useSmalltalkStyler'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Extensions'!

!SHTextStylerOMeta2 methodsFor: 'private' stamp: 'pb 9/3/2017 19:21:52'!
                 attributesFor: aSymbol
	^ useSmalltalkStyler
		ifTrue: [ smalltalkFallbackStyler class attributesFor: aSymbol ]
		ifFalse: [ self class attributesFor: aSymbol ].! !

!SHTextStylerOMeta2 methodsFor: 'private' stamp: 'pb 9/3/2017 19:34:53'!
                 classOrMetaClass: anObject
	^ useSmalltalkStyler
		ifTrue: [ smalltalkFallbackStyler classOrMetaClass: anObject ]
		ifFalse: [ self ].! !

!SHTextStylerOMeta2 methodsFor: 'private' stamp: 'pb 6/17/2015 00:33'!
              disableFormatAndConvert! !

!SHTextStylerOMeta2 methodsFor: 'private' stamp: 'pb 6/17/2015 00:31'!
                             privateFormatAndConvert! !

!SHTextStylerOMeta2 methodsFor: 'private' stamp: 'pb 9/29/2017 00:04:55'!
                          privateStyle
	| ranges |
	ranges := [
	useSmalltalkStyler := false.
	self class rangeParser rangesFor: formattedText ]
		on: OM2Fail
		do: [ ].
	ranges ifNil: [
		ranges := smalltalkFallbackStyler
			textModel: textModel;
			
				formatAndStyle: textModel actualContents
				allowBackgroundStyleProcess: false;
			parseSetWorkspace: true.
		useSmalltalkStyler := true ].
	ranges ifNotNil: [
		self
			setAttributesIn: formattedText
			fromRanges: ranges
			in: nil ].! !

!SHTextStylerOMeta2 methodsFor: 'private' stamp: 'pb 6/16/2015 23:13'!
 setAttributesIn: aText fromRanges: ranges in: anInterval
	"modified by jmv to keep existing attributes if they answer true to #isParagraphAttribute"
	| attributes defaultAttributes paragraphAttributes attr newRuns newValues lastAttr lastCount beginning chunkRuns end |
	anInterval
		ifNil: [
			beginning := 1.
			end := aText size ]
		ifNotNil: [
			beginning := anInterval first.
			end := anInterval last ].
	defaultAttributes := self attributesFor: #default.
	paragraphAttributes := Array new: end - beginning + 1.
	1
		to: paragraphAttributes size
		do: [ :i |
			paragraphAttributes
				at: i
				put:
					((aText attributesAt: i + beginning - 1) select: [ :each |
						each isParagraphAttribute ]) ].
	attributes := Array new: end - beginning + 1.
	1
		to: attributes size
		do: [ :i |
			attributes
				at: i
				put: (paragraphAttributes at: i) , defaultAttributes ].
	ranges do: [ :range |
		(attr := self attributesFor: range rangeType) ifNotNil: [
			range start
				to: range end
				do: [ :i |
					attributes
						at: i
						put: (paragraphAttributes at: i) , attr ]]].
	newRuns := OrderedCollection new: attributes size // 10.
	newValues := OrderedCollection new: attributes size // 10.
	1
		to: attributes size
		do: [ :i |
			attr := attributes at: i.
			i = 1
				ifTrue: [
					newRuns add: 1.
					lastCount := 1.
					lastAttr := newValues add: attr ]
				ifFalse: [
					attr == lastAttr
						ifTrue: [
							lastCount := lastCount + 1.
							newRuns
								at: newRuns size
								put: lastCount ]
						ifFalse: [
							newRuns add: 1.
							lastCount := 1.
							lastAttr := newValues add: attr ]]].
	chunkRuns := (RunArray
		runs: newRuns
		values: newValues) coalesce.
	aText
		basicReplaceAttributesFrom: beginning
		to: end
		with: chunkRuns.! !

!SHTextStylerOMeta2 methodsFor: 'private' stamp: 'pb 1/5/2016 01:18'!
                             workspace: inst
	"Needed for Debugger>>shoutAboutToStyle:"
	self flag: #fixme.
	^ nil.! !

!SHTextStylerOMeta2 methodsFor: 'initialization' stamp: 'pb 9/3/2017 19:21:19'!
                     initialize
	super initialize.
	useSmalltalkStyler := false.
	smalltalkFallbackStyler := SHTextStylerST80 new.! !

!SHTextStylerOMeta2 commentStamp: '<historical>' prior: 0!
                   Styler for OMeta2-based code (which can include Smalltalk)!

SHTextStylerOMeta2 class
	instanceVariableNames: 'textAttributes'!

!SHTextStylerOMeta2 class methodsFor: 'private' stamp: 'pb 6/17/2015 00:15'!
                  attributeArrayForColor: aColorOrNil emphasis: anEmphasisSymbolOrArrayorNil
	"Answer a new Array containing any non nil TextAttributes specified"
	| answer emphArray |
	answer := #().
	aColorOrNil ifNotNil: [ answer := answer , {TextColor color: aColorOrNil} ].
	anEmphasisSymbolOrArrayorNil ifNotNil: [
		emphArray := anEmphasisSymbolOrArrayorNil isSymbol
			ifTrue: [ {anEmphasisSymbolOrArrayorNil} ]
			ifFalse: [ anEmphasisSymbolOrArrayorNil ].
		emphArray do: [ :each |
			each ~= #normal ifTrue: [ answer := answer , {TextEmphasis perform: each} ]]].
	^ answer.! !

!SHTextStylerOMeta2 class methodsFor: 'private' stamp: 'pb 6/17/2015 01:19'!
                        attributesFor: aSymbol
	textAttributes ifNil: [ textAttributes := self initialTextAttributes ].
	^ textAttributes
		at: aSymbol
		ifAbsent: (self attributeArrayForColor: Color black emphasis: nil).! !

!SHTextStylerOMeta2 class methodsFor: 'private' stamp: 'pb 6/26/2015 02:17'!
         initialTextAttributes
	"emphasis can be bold, italic, underlined... what about outline & strikethrough?"
	| attrArray color dict element emphasis styleTable |
	styleTable := Theme current generateShoutConfig.
	dict := Dictionary new.
	false
		ifTrue: [
			styleTable do: [ :each |
				element := each first.
				color := each
					at: 2
					ifAbsent: nil.
				color := color ifNotNil: [ Color colorFrom: color ].
				emphasis := each
					at: 3
					ifAbsent: nil.
				attrArray := self
					attributeArrayForColor: color
					emphasis: emphasis.
				attrArray notEmpty ifTrue: [
					dict
						at: element
						put: attrArray ]].
			^ dict ]
		ifFalse: [ ^ Dictionary new
					at: #nil "keywords (true/false/nil)"
					put:
						(self
							attributeArrayForColor: Color red muchDarker
							emphasis: nil);

					at: #tempVar "method vars"
					put:
						(self
							attributeArrayForColor: Color grey muchDarker
							emphasis: #italic);

					at: #blockStart1
					put:
						(self
							attributeArrayForColor: (Color r: 0.6 g: 0.6 b: 0.6) "Color aqua"
							emphasis: nil);
				
					at: #blockStart2
					put:
						(self
							attributeArrayForColor: (Color r: 0.45g: 0.45 b: 0.45) "Color teal"
							emphasis: nil);
				
					at: #blockStart3
					put:
						(self
							attributeArrayForColor: (Color r: 0.3 g: 0.3 b: 0.3) "Color blue"
							emphasis: nil);
				
					at: #blockStart4
					put:
						(self
							attributeArrayForColor: (Color r: 0.15 g: 0.15 b: 0.15) "Color navyBlue"
							emphasis: nil);
				
					at: #blockStart5
					put:
						(self
							attributeArrayForColor: (Color r: 0.0 g: 0.0 b: 0.0) "Color purple muchDarker"
							emphasis: nil);
				
					at: #default
					put:
						(self
							attributeArrayForColor: Color black
							emphasis: nil);
				
					at: #comment "/* */ and // comments"
					put:
						(self
							attributeArrayForColor: Color green
							emphasis: #italic);
				
					at: #keyword "rule & parms"
					put:
						(self
							attributeArrayForColor: Color blue lighter
							emphasis: #bold);
				
					at: #blockArg "arity (*+?)/lookahead (&~)"
					put:
						(self
							attributeArrayForColor: Color orange lighter
							emphasis: #bold);
				
					at: #blockTempVar "apply/rule name"
					put:
						(self
							attributeArrayForColor: Color blue
							emphasis: nil);
				
					at: #text "'string'"
					put:
						(self
							attributeArrayForColor: Color blue
							emphasis: #bold);
				
					at: #stringSymbol "token"
					put:
						(self
							attributeArrayForColor: Color navyBlue
							emphasis: #bold);
				
					at: #symbol "#symbol"
					put:
						(self
							attributeArrayForColor: Color blue darker
							emphasis: #bold);
				
					at: #character "$c and ``abc''"
					put:
						(self
							attributeArrayForColor: Color red muchDarker
							emphasis: nil);
				
					at: #patternArg "semantic action/predicate"
					put:
						(self
							attributeArrayForColor: Color cyan muchDarker
							emphasis: nil);
				
					at: #number "123"
					put:
						(self
							attributeArrayForColor: Color purple
							emphasis: nil);
				
					at: #externalFunctionCallingConvention "squeak code"
					put:
						(self
							attributeArrayForColor: Color cyan veryMuchDarker
							emphasis: nil);
				yourself].! !

!SHTextStylerOMeta2 class methodsFor: 'as yet unclassified' stamp: 'pb 6/9/2017 18:16:15'!
 rangeParser
	^ OMeta2ExtendedParser! !

!SHTextStylerOMeta2 class methodsFor: 'private-development' stamp: 'pb 6/17/2015 01:09'!
                               resetAttributes
	textAttributes := nil! !


SHTextStylerOMeta2 subclass: #SHTextStylerOtherOMeta2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Extensions'!

!SHTextStylerOtherOMeta2 methodsFor: 'private' stamp: 'pb 10/1/2017 15:22:36'!
      privateStyle

	| ranges |
	ranges := [
	useSmalltalkStyler := true.
	self class rangeParser rangesFor: formattedText ]
		on: OM2Fail
		do: [ ].
	ranges ifNil: [ | idx |
		useSmalltalkStyler := false.
		idx := formattedText indexOf: Character lf.
		idx > 0
			ifTrue: [
				ranges := {
					SHRange
						start: 1
						end: idx - 1
						type: #bold. 
					SHRange
						start: idx
						end: formattedText size
						type: #normal
				} ]
			ifFalse: [
				ranges := {
					SHRange
						start: 1
						end: formattedText size
						type: #error
				} ]].
	ranges ifNotNil: [
		self
			setAttributesIn: formattedText
			fromRanges: ranges
			in: nil ].! !

!SHTextStylerOtherOMeta2 commentStamp: '<historical>' prior: 0!
              Styler for 'other' OMeta2-based code (which doesn't necessarily use OMeta or Smalltalk syntax).  Since this can be arbitrary code, it doesn't attempt to parse it: it bolds the first line and displays the rest as normal text.

FIXME - when in prettyPrint mode should use a fallback smalltalk styler (so actually we want to use the fallback parser as the primary (can't it doesn't error... so we use the OMeta parser which also handles Smalltalk... FIXME: hack) and if it fails, do it another way)!

SHTextStylerOtherOMeta2 class
	instanceVariableNames: ''!

!SHTextStylerOtherOMeta2 class methodsFor: 'private' stamp: 'pb 9/3/2017 18:32:05'!
                               initialTextAttributes
	"emphasis can be bold, italic, underlined... what about outline & strikethrough?"
	^ Dictionary new
		
			at: #bold
			put:
				(self
					attributeArrayForColor: Color black
					emphasis: #bold);
		
			at: #default
			put:
				(self
					attributeArrayForColor: Color black
					emphasis: nil);
		
			at: #error
			put:
				(self
					attributeArrayForColor: Color red
					emphasis: nil);
		yourself.! !

!SHTextStylerOtherOMeta2 class methodsFor: 'as yet unclassified' stamp: 'pb 9/3/2017 18:02:16'!
                 rangeParser
	^ OMeta2ExtendedParser! !


SHTextStyler subclass: #SHTextStylerST80
	instanceVariableNames: 'classOrMetaClass workspace parser disableFormatAndConvert'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Syntax Highlighting'!

!SHTextStylerST80 methodsFor: 'private' stamp: 'pb 9/30/2017 15:31:56'!
                           parseSetWorkspace: aBoolean
	"Answer a collection of SHRanges by parsing aText.
	When formatting it is not necessary to set the workspace, and this can make the parse take less time, so aBoolean specifies whether the parser should be given the workspace"
	parser ifNil: [ parser := SHParserST80 new ].
	parser
		workspace:
			(aBoolean ifTrue: [ workspace ]);
		classOrMetaClass: classOrMetaClass;
		source: formattedText asString.
	parser parse.
	^ parser ranges.! !

!SHTextStylerST80 methodsFor: 'private' stamp: 'jmv 9/19/2017 22:40:08'!
  privateStyle

	| alpha end start count startIndexes c hue |
	self parseSetWorkspace: true.
	parser ranges ifNotNil: [ :ranges |
		self setAttributesFromRanges: ranges ].

	Preferences highlightBlockNesting ifTrue: [
		startIndexes _ parser blockDepthsStartIndexes.
		count _ startIndexes size.
		parser blockDepths withIndexDo: [ :depth :idx |
			start _ startIndexes at: idx.
			end _ idx = count ifTrue: [formattedText size] ifFalse: [ (startIndexes at: idx+1)-1].
			alpha _ depth / 10.0 min: 1.0.
			hue _ depth * 60.
			c _ Color h: hue s: 0.2 v: 0.5 alpha: alpha.
			formattedText 
				addAttribute: (ShoutTextBackgroundColor 
				color: c ) from: start to: end ]]! !

!SHTextStylerST80 methodsFor: 'private' stamp: 'jmv 9/17/2017 18:30:50'!
                    replaceStringForRangesWithType: aSymbol with: aString
	"Answer aText if no replacements, or a copy of aText with 
	each range with a type of aSymbol replaced by aString"
	| toReplace increaseInLength |

	"We don't handle format and conversion for debuggers"
	disableFormatAndConvert ifTrue: [ ^self ].

	self parseSetWorkspace: false.
	toReplace _ parser ranges select: [ :each |
		each rangeType = aSymbol ].
	toReplace isEmpty ifTrue: [ ^self ].
	increaseInLength := 0.

	(toReplace asArray sort: [ :a :b | a start <= b start ]) 
		do: [ :each | | end start thisIncrease | 
			start := each start + increaseInLength.
			end := each end + increaseInLength.
			formattedText replaceFrom: start to: end with: aString.
			thisIncrease := aString size - each length.
			increaseInLength := increaseInLength + thisIncrease ]! !

!SHTextStylerST80 methodsFor: 'private' stamp: 'jmv 12/30/2016 11:44:19'!
                             setAttributesFromRanges: ranges

	formattedText removeAttributesThat: [ :attribute | attribute isForShout ].

	"Optimize for mutation speed unless method is really large but with very few distict elements:
	Source code that includes just big literals is better served by conventional Text+RunArray"
	"Do it only if we are not breaking textModel!! (for instance, StyledTextEditor asks for formatting just sections, not whole #actualContents)."
	formattedText == textModel actualContents ifTrue: [
		(formattedText size > 2000 and: [ ranges size < 50 ]) ifFalse: [
			formattedText _ formattedText optimizedForMutationSpeed.
			textModel basicActualContents: formattedText ]].

	ranges do: [ :range |

		"Smalltalk text styling"
		(self attributesFor: range rangeType) ifNotNil: [ :attributes |
			attributes do: [ :each |
				formattedText addAttribute: each from: range start to: range end ]].

		"Show as subscripts if appropriate."
		classOrMetaClass ifNotNil: [
			classOrMetaClass theNonMetaClass lastUnderscoreMeansSubscript ifTrue: [
				(#( instVar classVar globalVar workspaceVar poolConstant
					patternArg methodArg patternTempVar tempVar		
					blockPatternArg blockArg blockPatternTempVar blockTempVar 
					incompleteIdentifier undefinedIdentifier) pointsTo: range rangeType )
						ifTrue: [
							formattedText lastIndexOf: $_ startingAt: range end endingAt: range start do: [ :i |
								formattedText addAttribute: ShoutTextEmphasis subscript from: i to: range end ] ]]]]! !


SHTextStylerST80 class
	instanceVariableNames: 'styleTable textAttributes'!

!SHTextStylerST80 class methodsFor: 'style table' stamp: 'pb 5/4/2016 17:44'!
            initialTextAttributes
	| d element color emphasis attrArray |
	d _ IdentityDictionary new.
	self styleTable do: [ :each |
		element _ each first.
		color _ each at: 2 ifAbsent: nil.
		color _ color ifNotNil: [ Color colorFrom: color ].
		emphasis _ each at: 3 ifAbsent: nil.
		attrArray _ self attributeArrayForColor: color emphasis: emphasis.
		attrArray notEmpty ifTrue: [
			d at: element put: attrArray ]].
	^ d! !


Object subclass: #Scanner
	instanceVariableNames: 'source mark hereChar aheadChar token tokenType currentComment buffer typeTable isForTokenization'
	classVariableNames: 'TypeTable'
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

!Scanner methodsFor: 'expression types' stamp: 'jmv 8/2/2017 12:59:08'!
        scanLitByteVec
	"Also accept Floats besides bytes!!
	#[1 2 3 255]
	#[1.0 0.2 1.0]
	#[1.0 -0.2e-23 1.0e4]
	"
	| stream |
	stream _ nil.
	[ tokenType == #rightBracket or: [ tokenType == #doIt ] ] whileFalse: [
		(token == #- and: [(self typeTableAt: hereChar) == #xDigit]) ifTrue: [
			self scanToken.
			token _ token negated ].
		((token isInteger and: [ token between: 0 and: 255 ]) or: [token isFloat])
			ifFalse: [ ^ self offEnd: '8-bit integer, floating point number, or right bracket expected' ].
		stream ifNil: [
			stream _ ((token isFloat ifTrue: [Float64Array] ifFalse: [ByteArray]) new: 16) writeStream ].
		stream nextPut: token.
		self scanToken ].
	token _ stream
		ifNotNil: [ stream contents ]
		ifNil: [
			"For back compatibility, if empty, assume ByteArray"
			ByteArray new ]! !

!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 12/30/2016 10:29:16'!
                xBacktick
	"Smalltalk code evaluated at compile time as a literal."

	self step.
	buffer reset.
	[hereChar == $`
		and: [aheadChar == $`
				ifTrue: [self step. false]
				ifFalse: [true]]]
		whileFalse: [
			buffer nextPut: self step.
			(hereChar = Scanner doItCharacterValue asCharacter and: [source atEnd])
				ifTrue: [^self offEnd: 'Unmatched back quote']].
	self step.
	token _ [ Compiler evaluate: buffer contents ] 
		on: SyntaxErrorNotification, UndeclaredVariableReference, Error
		do: [ :ex |
			ex class caseOf: {
				[ SyntaxErrorNotification ] -> [
						self notify: 'Can not compile: ', ex errorMessage at: mark].
				[ UndeclaredVariableReference ] -> [ 
						self notify: 'Can not compile: Variable ''', ex varName, ''' is not declared' at: mark ]
			} otherwise: [
						self notify: 'Can not evaluate code: ', ex description at: mark ]].
	tokenType _ #literal! !


Scanner class
	instanceVariableNames: ''!

!Scanner class methodsFor: 'cached class state' stamp: 'jmv 12/10/2016 01:26:17'!
            initTypeTable
	| newTable |
	newTable := Array new: 256 withAll: #xIllegal. "default"
	newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. "tab lf ff cr space"

	1 to: 255
		do: [:index |
			(Character numericValue: index) isValidInIdentifiers
				ifTrue: [
					"Digits and $_ are overwritten later"
					newTable at: index put: #xLetter ]].

	newTable atAll: ($0 numericValue to: $9 numericValue) put: #xDigit.
	newTable atAll:  '!!%&+-*/\,<=>?@~' asByteArray put: #xBinary.

	newTable at: Scanner doItCharacterValue put: #doIt.
	newTable at: $" numericValue put: #xDoubleQuote.
	newTable at: $# numericValue put: #xLitQuote.
	newTable at: $$ numericValue put: #xDollar.
	newTable at: $' numericValue put: #xSingleQuote.
	newTable at: $` numericValue put: #xBacktick.
	newTable at: $: numericValue put: #xColon.
	newTable at: $( numericValue put: #leftParenthesis.
	newTable at: $) numericValue put: #rightParenthesis.
	newTable at: $. numericValue put: #period.
	newTable at: $; numericValue put: #semicolon.
	newTable at: $[ numericValue put: #leftBracket.
	newTable at: $] numericValue put: #rightBracket.
	newTable at: ${ numericValue put: #leftBrace.
	newTable at: $} numericValue put: #rightBrace.
	newTable at: $^ numericValue put: #upArrow.
	newTable at: $_ numericValue put: #xUnderscore.
	newTable at: $| numericValue put: #verticalBar.
	TypeTable := newTable "bon voyage!!"

	"
	Scanner initTypeTable
	"! !


PluggableMorph subclass: #ScrollBar
	instanceVariableNames: 'slider value setValueSelector sliderShadow upButton downButton scrollDelta pageDelta interval nextPageDirection grabPosition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

!ScrollBar methodsFor: 'access' stamp: 'pb 7/6/2017 02:44:45'!
       scrollValue
	^ value! !

!ScrollBar methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:57:09'!
     drawOn: aCanvas

	aCanvas
		fillRectangle: (`0@0` extent: extent)
		color: (color alphaMixed: 0.3 with: Theme current scrollbarColor)
		borderWidth: borderWidth
		borderStyleSymbol: #simple
		baseColorForBorder: borderColor! !

!ScrollBar methodsFor: 'geometry' stamp: 'pb 9/13/2017 06:22:10'!
                          freeSliderRoom
	"Answer the length or height of the free slider area, i.e. subtract the slider itself.
	If we are really too short of room, lie a little bit. Answering at least 4, even when the
	free space might be actually negative, makes the scrollbar somewhat usable."

	| buttonsRoom |
	buttonsRoom _ Theme current minimalWindows ifTrue: [0] ifFalse: [self buttonExtent * 2].
	^ ((self isHorizontal
		ifTrue: [ extent x - slider morphWidth]
		ifFalse: [ extent y - slider morphHeight])
			- (borderWidth * 2) - buttonsRoom) max: 4! !

!ScrollBar methodsFor: 'model access' stamp: 'pb 7/6/2017 02:53:19'!
internalScrollValue: newValue
	"Called internally for propagation to model"
	self scrollValue: newValue.
	setValueSelector ifNotNil: [
		model perform: setValueSelector with: value ]! !

!ScrollBar methodsFor: 'model access' stamp: 'pb 7/6/2017 02:45:15'!
scrollValue: newValue
	"Drive the slider position externally..."
	value _ newValue min: 1.0 max: 0.0.
	self computeSlider! !

!ScrollBar methodsFor: 'scrolling' stamp: 'pb 7/6/2017 02:48:48'!
scrollByPage
	"Scroll automatically while mouse is down"
	nextPageDirection
		ifTrue: [self internalScrollValue: (value + pageDelta min: 1.0)]
		ifFalse: [self internalScrollValue: (value - pageDelta max: 0.0)]
! !

!ScrollBar methodsFor: 'scrolling' stamp: 'pb 7/6/2017 02:48:59'!
      scrollDown: count
	self internalScrollValue: (value + (scrollDelta * count) + 0.000001 min: 1.0)! !

!ScrollBar methodsFor: 'scrolling' stamp: 'pb 7/6/2017 02:49:09'!
                         scrollTo: handPositionRelativeToSlider
	| v handPositionRelativeToUs |
	grabPosition ifNotNil: [
		handPositionRelativeToUs _ slider externalize: handPositionRelativeToSlider.
		v _ (self isHorizontal
			ifTrue: [ handPositionRelativeToUs x - grabPosition x ]
			ifFalse: [ handPositionRelativeToUs y - grabPosition y ])
				- borderWidth - self buttonExtent * 1.0
					/ self freeSliderRoom.
		self internalScrollValue: v ]! !

!ScrollBar methodsFor: 'scrolling' stamp: 'pb 7/6/2017 02:49:21'!
                 scrollUp: count
	self internalScrollValue: (value - (scrollDelta * count) - 0.000001 max: 0.0)! !


Collection subclass: #SequenceableCollection
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Abstract'!

!SequenceableCollection methodsFor: 'copying' stamp: 'jmv 11/17/2016 17:08:04'!
                  copyReplaceFrom: start to: stop with: replacementCollection 
	"Answer a copy of the receiver satisfying the following conditions: 
	+ stop is less than start, then this is an insertion; stop should be exactly start-1, 
	+ start = 1 means insert before the first character,
	+ start = size+1 means append after last character. 
	+ Otherwise, this is a replacement; start and stop have to be within the receiver's bounds."

	| newSequenceableCollection newSize endReplacement |
	newSize _ self size - (stop - start + 1) + replacementCollection size.
	endReplacement _ start - 1 + replacementCollection size.
	newSequenceableCollection _ self species new: newSize.
	start > 1 ifTrue:[
		newSequenceableCollection
			replaceFrom: 1
			to: start - 1
			with: self
			startingAt: 1].
	start <= endReplacement ifTrue:[
		newSequenceableCollection
			replaceFrom: start
			to: endReplacement
			with: replacementCollection
			startingAt: 1].
	endReplacement < newSize ifTrue:[
		newSequenceableCollection
			replaceFrom: endReplacement + 1
			to: newSize
			with: self
			startingAt: stop + 1].
	^newSequenceableCollection! !

!SequenceableCollection methodsFor: 'copying' stamp: 'len 4/18/2016 22:08'!
                     shuffledBy: aGenerator
	"To answer a mutable collection when receiver is, for example, an Interval."
	^ (self collect: [ :each | each ]) shuffleBy: aGenerator! !

!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 11/30/2016 14:52:08'!
         with: otherCollection with: thirdCollection collect: threeArgBlock
	"Collect and return the result of evaluating twoArgBlock with corresponding elements from this collection and otherCollection."
	| n result |
	n _ self size.
	otherCollection size = n ifFalse: [ self error: 'otherCollection must be the same size' ].
	thirdCollection size = n ifFalse: [ self error: 'thirdCollection must be the same size' ].
	result _ self species new: n.
	1 to: n do: [ :index | 
		result at: index put:
			(threeArgBlock
				value: (self at: index)
				value: (otherCollection at: index)
				value: (thirdCollection at: index) )].
	^ result! !

!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 11/25/2016 12:15:27'!
                    with: otherCollection with: thirdCollection do: threeArgBlock 
	"Evaluate twoArgBlock with corresponding elements from this collection and otherCollection."
	| n |
	n _ self size.
	otherCollection size = n ifFalse: [self error: 'otherCollection must be the same size'].
	thirdCollection size = n ifFalse: [self error: 'thirdCollection must be the same size'].
	1 to: n do: [ :index |
		threeArgBlock
			value: (self at: index)
			value: (otherCollection at: index)
			value: (thirdCollection at: index)]! !

!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 9/10/2017 16:44:03'!
                 withNextDo: twoArgBlock
	"Evaluate the block with each element and the one following it.
	For the last element, next is nil
	(1 to: 10) asArray withNextDo: [ :each :next | {each. next} print ]
	#() withNextDo: [ :a :b | {a. b} print ]
	"
	| first previous |
	first _ true.
	self do: [ :each |
		first ifTrue: [
			first _ false ]
		ifFalse: [
			twoArgBlock value: previous value: each ].
		previous _ each ].
	first ifFalse: [
		twoArgBlock value: previous value: nil ]! !

!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 9/10/2017 16:44:25'!
                  withPreviousDo: twoArgBlock
	"Evaluate the block with each element and the one before it.
	For the first element, previous is nil
	(1 to: 10) asArray withPreviousDo: [ :each :previous | {previous. each} print ]
	#() withPreviousDo: [ :a :b | {a. b} print ]
	"
	| previous |
	previous _ nil.
	self do: [ :each |
		twoArgBlock value: each value: previous.
		previous _ each ].! !

!SequenceableCollection methodsFor: 'gui' stamp: 'jmv 7/17/2017 15:45:17'!
                          do: aBlock displayingProgress: aString
	aString
		displayProgressAt: Sensor mousePoint
		from: 0 to: self size
		during: [ :barBlock |
			self withIndexDo: [ :each :i |
				barBlock value: i.
				aBlock value: each]]! !

!SequenceableCollection methodsFor: 'math functions' stamp: 'jmv 11/30/2016 15:04:11'!
            += anObject
	^anObject isNumber
		ifTrue: [ self replace: [ :v | v + anObject ]]
		ifFalse: [
			self withIndexDo: [ :v :i |
				self at: i put: ((self at: i) + (anObject at: i)) ]]! !

!SequenceableCollection methodsFor: 'math functions' stamp: 'jmv 11/25/2016 11:41:25'!
               -= anObject
	^anObject isNumber
		ifTrue: [ self replace: [ :v | v - anObject ]]
		ifFalse: [
			self withIndexDo: [ :v :i |
				self at: i put: ((self at: i) - (anObject at: i)) ]]! !

!SequenceableCollection methodsFor: 'math functions' stamp: 'jmv 11/30/2016 15:21:00'!
               derivative
	| displaced answer |
	displaced _ self class new: self size.
	displaced replaceFrom: 2 to: self size with: self startingAt: 1.
	displaced at: 1 put: self first - self first.	"Some reasonable zero"
	answer _ self copy.
	answer -= displaced.
	^answer! !

!SequenceableCollection methodsFor: 'math functions' stamp: 'jmv 11/29/2016 14:23:32'!
integral
	| answer |
	answer _ self copy.
	2 to: answer size do: [ :i |
		answer at: i put: (answer at: i) + (answer at: i-1) ].
	^answer! !


Set class
	instanceVariableNames: ''!

!Set class methodsFor: 'initialization' stamp: 'jmv 7/17/2017 15:40:16'!
 quickRehashAllSets  "Set rehashAllSets"
	| insts |
	self withAllSubclassesDo:
		[:c |
			insts _ c allInstances.
			(insts isEmpty or: [c = MethodDictionary]) ifFalse:
			['Rehashing instances of ' , c name
				displayProgressAt: Sensor mousePoint
				from: 1 to: insts size
				during: [ :barBlock | 1 to: insts size do: [:x | barBlock value: x. (insts at: x) rehash]]
			]
		]! !

!Set class methodsFor: 'initialization' stamp: 'jmv 7/17/2017 15:40:27'!
                        rehashAllSets  "Set rehashAllSets"
	| insts |
	self withAllSubclassesDo:
		[:c | insts _ c allInstances.
		insts isEmpty ifFalse:
		['Rehashing instances of ' , c name
			displayProgressAt: Sensor mousePoint
			from: 1 to: insts size
			during: [ :barBlock |
			1 to: insts size do:
				[ :x | barBlock value: x.
				(insts at: x) rehash]]]]! !


Inspector subclass: #SetInspector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Inspector'!

!SetInspector methodsFor: 'accessing' stamp: 'HAW 5/28/2017 20:56:40'!
                    fieldList
	
	(object isNil or: [ object array isNil]) ifTrue: [^ Set new].
	
	^ self baseFieldList, (object array withIndexCollect: [:each :i | each ifNotNil: [i printString]]) select: [:each | each notNil]! !


TextBackgroundColor subclass: #ShoutTextBackgroundColor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-TextAttributes'!

!ShoutTextBackgroundColor methodsFor: 'testing' stamp: 'jmv 9/7/2017 16:42:03'!
                      isForShout
	"True if to be removed from code before styling"
	^true! !

!ShoutTextBackgroundColor commentStamp: '<historical>' prior: 0!
                       Just for code styler (Shout)!

ActiveModel subclass: #SimpleServiceEntry
	instanceVariableNames: 'provider label selector useLineAfter stateSelector description argumentGetter buttonLabel argumentProvider triggerFileListChanged sortOrder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-FileList'!

!SimpleServiceEntry methodsFor: 'accessing' stamp: 'jmv 8/28/2017 21:35:11'!
                        sortOrder
	^sortOrder! !

!SimpleServiceEntry methodsFor: 'accessing' stamp: 'jmv 8/28/2017 21:28:07'!
                         sortOrder: aNumber
	sortOrder _ aNumber! !

!SimpleServiceEntry methodsFor: 'initialization' stamp: 'jmv 9/6/2017 09:56:01'!
   initialize
	triggerFileListChanged _ false.
	sortOrder _ 1! !

!SmallFloat64 commentStamp: '<historical>' prior: 0!
            My instances represent 64-bit Floats whose exponent fits in 8 bits as immediate objects. This representation is only available on 64-bit systems, not 32-bit systems.!

Integer immediateSubclass: #SmallInteger
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Numbers'!

!SmallInteger methodsFor: 'testing' stamp: 'nice 8/31/2008 00:07'!
     isLarge
	^false! !

!SmallInteger methodsFor: 'system primitives' stamp: 'jmv 1/4/2017 10:35:09'!
                              digitAt: n 
	"Answer the value of an indexable field in the receiver.  LargePositiveInteger uses bytes of base two number, and each is a 'digit' base 256.  Fail if the argument (the index) is not an Integer or is out of bounds."
	n > Smalltalk wordSize ifTrue: [^ 0].
	self < 0
		ifTrue: 
			[self = SmallInteger minVal ifTrue: [
				"Can't negate minVal -- treat specially"
				^ Smalltalk wordSize = 4
					ifTrue: [ #(0 0 0 64) at: n ]
					ifFalse: [ #(0 0 0 0 0 0 0 16) at: n ]].
			^ ((0-self) bitShift: (1-n)*8) bitAnd: 16rFF]
		ifFalse: [^ (self bitShift: (1-n)*8) bitAnd: 16rFF]! !


SmallInteger class
	instanceVariableNames: 'minVal maxVal'!

!SmallInteger class methodsFor: 'constants' stamp: 'jmv 12/19/2016 13:06:38'!
    maxVal
	"Answer the maximum value for a SmallInteger."

	"Ensure word size is properly set. If so, maxVal is also set."
	Smalltalk wordSize.
	^maxVal! !

!SmallInteger class methodsFor: 'constants' stamp: 'jmv 12/19/2016 13:07:24'!
                        minVal
	"Answer the minimum value for a SmallInteger."

	"Ensure word size is properly set. If so, minVal is also set."
	Smalltalk wordSize.
	^minVal! !

!SmallInteger class methodsFor: 'class initialization' stamp: 'jmv 12/19/2016 13:03:09'!
             initMinValAndMaxVal
	| next val |
	val := -32768. "Assume at least 16 bits"
	[next := val + val.
	 next class == self] whileTrue:
		[val := next].
	minVal := val.
	maxVal := -1 - val! !


AutoCompleter subclass: #SmalltalkCompleter
	instanceVariableNames: 'parser'
	classVariableNames: 'AccessLock Selectors'
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

!SmalltalkCompleter methodsFor: 'entries' stamp: 'jmv 8/18/2017 17:43:14'!
      computeEntries

	| allSource contextClass id specificModel last3Ranges range prevRange receiverClass prevPrevRange |
	allSource _ model actualContents string.
	specificModel _ (model is: #hasTextProvider)
		ifTrue: [ model textProvider ]
		ifFalse: [ model ].
	contextClass _ (specificModel is: #CodeProvider) ifTrue: [
		specificModel selectedClassOrMetaClass ].

	"Instead of creating a new string, maybe we could pass the last position to parse to Shout..."
	parser _ SHParserST80 new.
	parser
		workspace: ((specificModel is: #providesBindings) ifTrue: [specificModel]);
		classOrMetaClass: contextClass;
		source: (allSource copyFrom: 1 to: position).
	parser parse.
	last3Ranges _ parser last3Ranges.
	range _ last3Ranges third.
	range ifNil: [ ^entries _ #() ].

	"If parsing breaks before position, then we don't know what to suggest, therefore don't open Completion"
	range end = position ifFalse: [ ^entries _ #() ].

	prefix _ allSource copyFrom: range start to: range end.
	
	(parser isMessage: range rangeType) ifTrue: [
		"If previous range is a constant or a well known identifier, we might filter messages"
		prevRange _ last3Ranges second.
		prevPrevRange _ last3Ranges first.
		receiverClass _ nil.
		"3 if -> ifNil: but not ifTrue:
		3=4 -> ifNil: or ifTrue:"
		(prevRange notNil and: [ prevPrevRange isNil or: [ (#(binary keyword) includes: prevPrevRange rangeType) not]]) ifTrue: [
			id _ (allSource copyFrom: prevRange start to: prevRange end).
			receiverClass _ prevRange rangeType caseOf: {
				[ #globalVar ] -> [ (Smalltalk at: id asSymbol) class ].
				[ #self ] -> [ contextClass ].
				[ #super ] -> [ contextClass superclass ].
				[ #true ] -> [ True ].
				[ #false ] -> [ False ].
				[ #nil ] -> [ UndefinedObject ].
				[ #character ] -> [ id first class ].
				[ #number ] -> [ (Compiler evaluate: id) class ].
				[ #string ] -> [ (Compiler evaluate: id) class ].
				[ #symbol ] -> [ (Compiler evaluate: id) class ].
				[ #stringSymbol ] -> [ (Compiler evaluate: id) class ].
				"thisContext could mean ContextPart or BlockClosure..."
				"[ #thisContext ] -> [ ContextPart ]"
			} otherwise: [ nil ]
		].
		^self computeMessageEntries: receiverClass ].

	(parser isPartialOrFullIdentifier: range rangeType) ifTrue: [
		^self computeIdentifierEntries ].
	
	"If we don't know what to do, do nothing"
	entries _ #()! !


TextEditor subclass: #SmalltalkEditor
	instanceVariableNames: 'lastIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!SmalltalkEditor methodsFor: 'editing keys' stamp: 'HAW 2/10/2017 16:03:46'!
       acceptAndDebugTest: aKeyboardEvent 
	
	^self acceptAndDebugTest ! !

!SmalltalkEditor methodsFor: 'editing keys' stamp: 'HernanWilkinson 1/10/2017 20:04:06'!
  acceptAndTest: aKeyboardEvent

	^self acceptAndTest! !

!SmalltalkEditor methodsFor: 'editing keys' stamp: 'HernanWilkinson 1/10/2017 20:04:34'!
               acceptAndTestAll: aKeyboardEvent

	^self acceptAndTestAll! !

!SmalltalkEditor methodsFor: 'editing keys' stamp: 'HernanWilkinson 1/10/2017 20:02:27'!
         debugIt: aKeyboardEvent

	self debugIt.
	^true! !

!SmalltalkEditor methodsFor: 'new selection' stamp: 'jmv 12/30/2016 10:36:10'!
                              selectWord
	"Select delimited text or word--the result of double-clicking."

	| leftDelimiters rightDelimiters |
	"Warning. Once me (jmv) added Character crCharacter to the delimiters, to make double-click at and of line select whole line.
	This had the bad effect that if a class name is the last word of a line, double-click would correctly select it, but after that,
	doing ctrl-b to browse it would select the whole line..."
	leftDelimiters _ '([{<|''"`'.
	rightDelimiters _ ')]}>|''"`'.
	^self selectWordLeftDelimiters: leftDelimiters rightDelimiters: rightDelimiters! !

!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 3/3/2017 19:12:39'!
                            acceptAndDebugTest
	
	^self acceptAndWithMethodDo: [ :aPotencialTestMethod | 
		aPotencialTestMethod isTestMethod ifTrue: [ 
			aPotencialTestMethod methodClass debugAsFailure: aPotencialTestMethod selector ifCanNot: [ PopUpMenu inform: TestCase canNotDebugMethodErrorDescription ]]]! !

!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/1/2017 18:51:22'!
                             acceptAndTest
	
	self acceptThenTestMethodAndSuite: [ :aMethod | self testSuiteOf: aMethod methodClass ].
	^true! !

!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/1/2017 18:50:41'!
        acceptAndTestAll
	
	self acceptThenTestMethodAndSuite: [ :aMethod | self testSuiteForCategoryOf: aMethod methodClass ].
	^true
	
	! !

!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/10/2017 17:34:38'!
                     acceptAndWithMethodDo: aBlock
	
	| potencialTestMethod |
	
	self acceptContents ifFalse: [ ^false ].
	
	potencialTestMethod _ self codeProvider currentCompiledMethod.
	^potencialTestMethod 
		ifNil: [ false ]
		ifNotNil: [
			aBlock value: potencialTestMethod.
			true]! !

!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/10/2017 17:34:52'!
          acceptThenTestMethodAndSuite: aSuiteBuilder
	
	self acceptAndWithMethodDo: [ :aPotencialTestMethod |
		self runAndDebuggIfNecessary: aPotencialTestMethod.
		self runTestSuite: (aSuiteBuilder value: aPotencialTestMethod) ]! !

!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/10/2017 16:08:47'!
                          runAndDebuggIfNecessary: aPotencialTestMethod

	aPotencialTestMethod isTestMethod ifTrue: [
		aPotencialTestMethod methodClass debug: aPotencialTestMethod selector ]! !

!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/1/2017 19:19:02'!
                   runTestSuite: aTestSuite

	(ProgessiveTestRunner for: aTestSuite) value
	
	! !

!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/5/2017 10:49:25'!
             testSuiteForCategoryOf: aClass

	^TestSuite forSystemCategoryNamed: aClass category using: SystemOrganization 
! !

!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/5/2017 10:48:27'!
         testSuiteOf: aClass

	^TestSuite forClass: aClass
! !


SmalltalkEditor class
	instanceVariableNames: 'menu2'!

!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'HAW 3/18/2017 10:44:48'!
                 cmdShortcutsSpec
	"
	Editor initialize
	"
	"arranged in QWERTY keyboard order"
	^#(
		#(		$r	#acceptAndDebugTest:		'Saves method and debugs it')
		#(		$t	#acceptAndTest:				'Saves method, runs it as test and then all tests in class. Opens debugger if error')
		#(		$y	#acceptAndTestAll:				'Saves method, runs it as test and then all tests in class category. Opens debugger if error')
		#(		$i	#inspectIt:							'Inspect it (selection is a valid expression, or selection is over an inspect-ilst)')
		#(		$p	#printIt:								'Print it (selection is a valid expression)')

		#(		$s	#save:								'Save (i.e. accept)')
		#(		$d	#doIt:								'Do it (selection is a valid expression)')
		#(		$l	#cancelEdits:						'Cancel')

		#(		$b	#browseIt:							'Browse it (selection is a class name or cursor is over a class-list or message-list)')
		#(		$n	#sendersOfIt:						'Senders of it (selection is a message selector or cursor is over a class-list or message-list)')
		#(		$m	#implementorsOfIt:				'Implementors of it (selection is a message selector or cursor is over a class-list or message-list)')

		#(		$E	#methodStringsContainingit:'Method strings containing it')
		#(		$T	#displayIfTrue:					'Insert #ifTrue:')
		#(		$I	#exploreIt:							'Inspect via Object Explorer')

		#(		$A	#argAdvance:						'Advance argument')
		#(		$D	#debugIt:							'Debug it')
		#(		$F	#displayIfFalse:					'Insert #ifFalse:')
		#(		$G	#fileItIn:							'File in selection')

		#(		$V	#pasteInitials:					'Paste author initials')
		#(		$N	#referencesToIt:					'References to it (selection is a class name, or cursor is over a class-list or message-list)')
	)! !

!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'HAW 2/10/2017 15:57:40'!
                         initializeMenu
	"Initialize the mouseButton2 (right button) pop-up menu and corresponding messages."
	"
	Editor initialize
	"

	menu _ SelectionMenu fromArray: {
		{'Help...'.										#openHelp}.
		#-.
		{'Do it (d)'.									#doIt}.
		{'Print it (p)'.									#printIt}.
		{'Inspect it (i)'.								#inspectIt}.
		{'Explore it (I)'.								#exploreIt}.
		{'Debug it (D)'.								#debugIt}.
		{'Profile it'.									#profileIt}.
		#-.
		{'Explain'.										#explain}.
		{'Browse it (b)'.								#browseIt}.
		{'Senders of it (n)'.							#sendersOfIt}.
		{'Implementors of it (m)'.					#implementorsOfIt}.
		{'References to it (N)'.						#referencesToIt}.
		#-.
		{'Method Strings with it (E)'.				#methodStringsContainingit}.
		{'Method Source with it'.					#methodSourceContainingIt}.
		{'Class Comments with it'.					#classCommentsContainingIt}.
		#-.
		{'Accept (s)'.									#acceptContents}.
		{'Cancel (l)'.									#cancelEdits}.
		{'Accept & Run Test in Class (t)'.			#acceptAndTest}.
		{'Accept & Run Test in Category (y)'.		#acceptAndTestAll}.
		{'Accept & Debug Test (r)'.					#acceptAndDebugTest}.
		#-.
		{'More...'.										#getMenu2}.
	}.
	menu2 _ SelectionMenu fromArray: {
		{'Find...(f)'.									#find}.
		{'Find Again (g)'.								#findAgain}.
		{'Use Selection for Find (j)'.				#setSearchString}.
		#-.
		{'Undo - multiple (z)'.						#undo}.
		{'Redo - multiple (Z)'.						#redo}.
		{'Undo / Redo history'.						#offerUndoHistory}.
		#-.
		{'Copy (c)'.									#copySelection}.
		{'Cut (x)'.										#cut}.
		{'Paste (v)'.									#paste}.
		{'Paste without Format'.						#pasteString}.
		{'Paste...'.									#pasteRecent}.
		#-.
		{'Toggle WordWrap'.						#wrapOnOff}.
		{'Set Font... (k)'.								#offerFontMenu}.
		{'Clear Font'.									#clearFont}.
		{'Set Default Font...'.						#offerDefaultFontMenu}.
		#-.
		{'More...'.										#getMenu}.
	}! !


ReferenceStream subclass: #SmartRefStream
	instanceVariableNames: 'structures steady renamed renamedConv superclasses progressBar objCount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Object Storage'!

!SmartRefStream methodsFor: 'read write' stamp: 'jmv 7/17/2017 15:40:37'!
                           nextPut: anObject
	"Really write three objects: (version, class structure, object).  But only when called from the outside.  If any instance-specific classes are present, prepend their source code.  byteStream will be in fileOut format.
	You can see an analysis of which objects are written out by doing: 
	(SmartRefStream statsOfSubObjects: anObject)
	(SmartRefStream tallyOfSubObjects: anObject)
	(SmartRefStream subObjects: anObject ofClass: aClass)"

| info |
topCall
	ifNil: [
		topCall _ anObject.
		'Please wait while objects are counted' 
			displayProgressAt: Sensor mousePoint
			from: 0 to: 10
			during: [ :barBlock | info _ self instVarInfo: anObject].
		byteStream binary.
		'Writing an object file' displayProgressAt: Sensor mousePoint
			from: 0 to: objCount*4	"estimate"
			during: [ :barBlock |
				objCount _ 0.
				progressBar _ barBlock.
				self setStream: byteStream reading: false.
					"set basePos, but keep any class renames"
				super nextPut: ReferenceStream versionCode.
				super nextPut: info.
				super nextPut: anObject.		"<- the real writing"
				].
					"Note: the terminator, $!!, is not doubled inside object data"
		"references is an IDict of every object that got written"
		byteStream ascii.
		byteStream nextPutAll: '!!'; newLine; newLine.
		byteStream padToEndWith: $ .	"really want to truncate file, but can't"
		topCall _ progressBar _ nil]	"reset it"
	ifNotNil: [
		super nextPut: anObject.
		progressBar ifNotNil: [progressBar value: (objCount _ objCount + 1)]].
! !

!SmartRefStream methodsFor: 'read write' stamp: 'jmv 7/17/2017 15:40:57'!
           nextPutObjOnly: anObject
	"Really write three objects: (version, class structure, object).  But only when called from the outside.  Not in fileOut format.  No class definitions will be written for instance-specific classes.  Error if find one.  (Use nextPut: instead)"

	| info |
	topCall
		ifNil: [
			topCall _ anObject.
			super nextPut: ReferenceStream versionCode.
			'Please wait while objects are counted' displayProgressAt: Sensor mousePoint
				from: 0 to: 10
				during: [ :barBlock |
					info _ self instVarInfo: anObject].
			'Writing an object file' displayProgressAt: Sensor mousePoint
				from: 0 to: objCount*4	"estimate"
				during: [ :barBlock |
					objCount _ 0.
					progressBar _ barBlock.
					super nextPut: info.
					super nextPut: anObject.	"<- the real writing"
					"Class inst vars not written here!!"].
			"references is an IDict of every object that got written
			(in case you want to take statistics)"
			"Transcript cr; show: structures keys printString."		"debug"
			topCall _ progressBar _ nil]	"reset it"
		ifNotNil: [
			super nextPut: anObject.
			progressBar ifNotNil: [progressBar value: (objCount _ objCount + 1)]].! !


Object subclass: #SpaceTally
	instanceVariableNames: 'results'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Profiling'!

!SpaceTally methodsFor: 'fileOut' stamp: 'jmv 7/17/2017 15:45:36'!
    printSpaceAnalysis: threshold on: aStream
	"
	SpaceTally new printSpaceAnalysis: 1 on:(FileStream forceNewFileNamed: 'STspace.text')
	"
	"sd-This method should be rewrote to be more coherent within the rest of the class 
	ie using preAllocate and spaceForInstanceOf:"

	"If threshold > 0, then only those classes with more than that number
	of instances will be shown, and they will be sorted by total instance space.
	If threshold = 0, then all classes will appear, sorted by name."

	| codeSpace instCount instSpace totalCodeSpace totalInstCount totalInstSpace eltSize n totalPercent percent |
	Smalltalk garbageCollect.
	totalCodeSpace _ totalInstCount _ totalInstSpace _ n _ 0.
	results _ OrderedCollection new: Smalltalk classNames size.
	'Taking statistics...'
		displayProgressAt: Sensor mousePoint
		from: 0 to: Smalltalk classNames size
		during: [ :barBlock |
			Smalltalk allClassesDo: [ :cl |
				codeSpace _ cl spaceUsed.
				barBlock value: (n _ n+1).
				Smalltalk garbageCollectMost.
				instCount _ cl instanceCount.
				instSpace _ (cl indexIfCompact > 0 ifTrue: [4] ifFalse: [8]) * instCount. "Object headers""Warning: The 3rd header word for big objects is not considered!!"
				cl isVariable
					ifTrue: [
						eltSize _ cl isBytes ifTrue: [1] ifFalse: [4].
						cl allInstancesDo: [ :x |
							instSpace _ instSpace + (x basicSize * eltSize)]]
					ifFalse: [instSpace _ instSpace + (cl instSize * instCount * 4)].
				results add: (SpaceTallyItem analyzedClassName: cl name codeSize: codeSpace instanceCount:  instCount spaceForInstances: instSpace).
				totalCodeSpace _ totalCodeSpace + codeSpace.
				totalInstCount _ totalInstCount + instCount.
				totalInstSpace _ totalInstSpace + instSpace]].
	totalPercent _ 0.0.

	aStream timeStamp.
	aStream
		nextPutAll: ('Class' padded: #right to: 30 with: $ );
		nextPutAll: ('code space' padded: #left to: 12 with: $ );
		nextPutAll: ('# instances' padded: #left to: 12 with: $ );
		nextPutAll: ('inst space' padded: #left to: 12 with: $ );
		nextPutAll: ('percent' padded: #left to: 8 with: $ ); newLine.

	threshold > 0 ifTrue: [
		"If inst count threshold > 0, then sort by space"
		results _ (results select: [:s | s instanceCount >= threshold or: [s spaceForInstances > (totalInstSpace // 500)]])
			asArray sort: [:s :s2 | s spaceForInstances > s2 spaceForInstances]].

	results do: [:s |
		aStream
			nextPutAll: (s analyzedClassName padded: #right to: 30 with: $ );
			nextPutAll: (s codeSize printString padded: #left to: 12 with: $ );
			nextPutAll: (s instanceCount printString padded: #left to: 12 with: $ );
			nextPutAll: (s spaceForInstances printString padded: #left to: 14 with: $ ).
		percent _ s spaceForInstances*100.0/totalInstSpace.
		totalPercent _ totalPercent + percent.
		percent >= 0.1 ifTrue: [
			percent printOn: aStream integerDigits: 6 padWith: $  fractionDigits: 1 positiveIndicator: nil ].
		aStream newLine].

	aStream
		newLine; nextPutAll: ('Total' padded: #right to: 30 with: $ );
		nextPutAll: (totalCodeSpace printString padded: #left to: 12 with: $ );
		nextPutAll: (totalInstCount printString padded: #left to: 12 with: $ );
		nextPutAll: (totalInstSpace printString padded: #left to: 14 with: $ ).
	totalPercent printOn: aStream integerDigits: 6 padWith: $  fractionDigits: 1 positiveIndicator: nil! !


FileStream subclass: #StandardFileStream
	instanceVariableNames: 'name fileID buffer1'
	classVariableNames: 'Registry'
	poolDictionaries: ''
	category: 'System-Files'!

!StandardFileStream methodsFor: 'read, write, position' stamp: 'jmv 11/17/2016 10:00:56'!
    basicNext
	"Answer the next byte from this file, or nil if at the end of the file."
	
	| count |
	collection ifNotNil: [
		position < readLimit 
			ifFalse: [ 
				readLimit := self primRead: fileID into: collection startingAt: 1 count: collection size.
				position := 0.
				readLimit = 0 ifTrue: [ ^nil ] ].
		^collection at: (position := position + 1) ].	
	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.
	^count = 1
		ifTrue: [ buffer1 at: 1 ]! !

!StandardFileStream methodsFor: 'read, write, position' stamp: 'jmv 11/17/2016 09:07:20'!
             peek
	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "
	| next |
	position < readLimit ifTrue: [
		^collection at: position+1 ].
	self atEnd ifTrue: [^ nil].
	next _ self basicNext.
	self position: self position - 1.
	^ next! !


Stream subclass: #StdIOReadStream
	instanceVariableNames: 'fileID name buffer1 peeked'
	classVariableNames: 'StdIn'
	poolDictionaries: ''
	category: 'System-Support'!

!StdIOReadStream methodsFor: 'open / close' stamp: 'jmv 11/17/2016 11:13:30'!
                         openOnHandle: aFileID name: streamName
	"Initialize the instance with the given file handle.
	 N.B. Do _not_ register the stream.  We do not want it to be
	 closed implicitly (e.g. on GC).  There may be multiple instances
	 accessing the same stream.  The stream is not a file."

	fileID _ aFileID.
	name _ streamName.
	buffer1 _ String new: 1.
	peeked _ false! !

!StdIOReadStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 11:28:44'!
        next
	"Answer the next byte from this stream, or wait until one becomes available.
	Warning: all Smalltalk processes are essentially suspended until that happens!!"

	"If last call was #peek, not #next, then just answer cached value."
	peeked
		ifFalse: [ self privateRead ]
		ifTrue: [ peeked _ false ].

	"peeked is always false on exit"
	^buffer1 at: 1! !

!StdIOReadStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 11:28:43'!
             peek
	"Answer the next byte from this stream, or wait until one becomes available.
	Warning: all Smalltalk processes are essentially suspended until that happens!!
	
	Do not advance the stream!!"

	"Multiple calls to #peek don't make new reads"
	peeked ifFalse: [
		self privateRead.
		peeked _ true ].

	"peeked is always true on exit"
	^buffer1 at: 1! !

!StdIOReadStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 11:33:22'!
                peekFor: aCharacter 
	"Answer false and do not move over the next element if it is not equal to the argument, aCharacter 
	Answer true and increment the position for accessing elements, if the next element is equal to anObject."

	| nextChar |
	nextChar _ self peek.
	aCharacter = nextChar ifTrue: [
		self next.
		^ true].
	^ false! !

!StdIOReadStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 11:24:52'!
    privateRead
	"Read one Character.
	Private."
	| count |
	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.
	count = 1 ifFalse: [ buffer1 at: 1 put: nil ]! !

!StdIOReadStream methodsFor: 'printing' stamp: 'jmv 11/17/2016 09:47:10'!
      printOn: aStream
	"Put a printed version of the receiver onto aStream."

	aStream nextPutAll: self class name; nextPutAll: ': '; print: name! !

!StdIOReadStream methodsFor: 'primitives' stamp: 'jmv 11/17/2016 09:45:28'!
   primRead: id into: byteArray startingAt: startIndex count: count
	"Read up to count bytes of data from this file into the given string or byte array starting at the given index. Answer the number of bytes actually read."

	<primitive: 'primitiveFileRead' module: 'FilePlugin'>
	self error: 'File read failed'! !

!StdIOReadStream commentStamp: '<historical>' prior: 0!
               Standard Input Stream.

A basic problem/restriction with this code is that currently the VM runs multiple VM threads within a single OS thread.

This means that waiting on StdIn blocks the VM, suspending all Smalltalk code.!

StdIOReadStream class
	instanceVariableNames: ''!

!StdIOReadStream class methodsFor: 'instance creation' stamp: 'jmv 11/17/2016 11:45:39'!
                  stdin
	StdIn ifNil: [
		StdIn _ self basicNew.
		StdIn 
			openOnHandle: self stdinHandle 
			name: 'stdin' ].
	^StdIn! !

!StdIOReadStream class methodsFor: 'accessing' stamp: 'jmv 11/17/2016 09:26:47'!
                    stdinHandle

	^ StdIOWriteStream stdioHandles at: 1! !

!StdIOReadStream class methodsFor: 'cached state access' stamp: 'jmv 11/17/2016 11:45:00'!
             releaseClassCachedState

	StdIn _ nil! !


Stream subclass: #StdIOWriteStream
	instanceVariableNames: 'fileID name buffer1'
	classVariableNames: 'StdErr StdOut'
	poolDictionaries: ''
	category: 'System-Support'!

!StdIOWriteStream methodsFor: 'open / close' stamp: 'jmv 11/17/2016 10:14:32'!
                            openOnHandle: aFileID name: streamName
	"Initialize the instance with the given file handle.
	 N.B. Do _not_ register the stream.  We do not want it to be
	 closed implicitly (e.g. on GC).  There may be multiple instances
	 accessing the same stream.  The stream is not a file."

	fileID _ aFileID.
	name _ streamName.
	buffer1 _ String new: 1! !

!StdIOWriteStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 10:19:51'!
                        flush
	"Flush pending changes"
	^self primFlush: fileID! !

!StdIOWriteStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 10:18:42'!
                        nextPut: char
	"Write the given character to this file."

	buffer1 at: 1 put: char.
	self primWrite: fileID from: buffer1 startingAt: 1 count: 1.
	^ char
! !

!StdIOWriteStream methodsFor: 'printing' stamp: 'jmv 11/17/2016 09:35:56'!
                      printOn: aStream
	"Put a printed version of the receiver onto aStream.  1/31/96 sw"

	aStream nextPutAll: self class name; nextPutAll: ': '; print: name! !

!StdIOWriteStream methodsFor: 'primitives' stamp: 'jmv 11/17/2016 10:20:17'!
                      primFlush: id
	"Flush pending changes to the disk"

	<primitive: 'primitiveFileFlush' module: 'FilePlugin'>! !

!StdIOWriteStream methodsFor: 'primitives' stamp: 'jmv 11/17/2016 10:19:14'!
   primWrite: id from: stringOrByteArray startingAt: startIndex count: count
	"Write count bytes onto this file from the given string or byte array starting at the given index. Answer the number of bytes written."

	<primitive: 'primitiveFileWrite' module: 'FilePlugin'>
	(FileWriteError fileName: name)
		signal: (self closed
			ifTrue: [ 'File [', name, '] is closed' ]
			ifFalse: [ 'File [', name, '] write failed' ])! !

!StdIOWriteStream methodsFor: 'character writing' stamp: 'jmv 11/17/2016 10:48:18'!
     newLine
	"Append a newLine character to the receiver.
	The Cuis convention is to use lf on output."

	self nextPut: Character newLineCharacter! !

!StdIOWriteStream methodsFor: 'character writing' stamp: 'jmv 11/17/2016 11:08:02'!
                         space
	"Append a space character to the receiver."

	self nextPut: Character space! !

!StdIOWriteStream commentStamp: '<historical>' prior: 0!
                Standard Output/Error Streams.!

StdIOWriteStream class
	instanceVariableNames: ''!

!StdIOWriteStream class methodsFor: 'instance creation' stamp: 'jmv 11/17/2016 11:46:13'!
                 stderr
	StdErr ifNil: [
		StdErr _ self basicNew.
		StdErr 
			openOnHandle: self stderrHandle 
			name: 'stderr' ].
	^StdErr! !

!StdIOWriteStream class methodsFor: 'instance creation' stamp: 'jmv 11/17/2016 11:46:37'!
    stdout
	StdOut ifNil: [
		StdOut _ self basicNew.
		StdOut 
			openOnHandle: self stdoutHandle 
			name: 'stdout' ].
	^StdOut! !

!StdIOWriteStream class methodsFor: 'accessing' stamp: 'jmv 11/17/2016 09:26:20'!
            stderrHandle

	^ self stdioHandles at: 3! !

!StdIOWriteStream class methodsFor: 'accessing' stamp: 'jmv 11/17/2016 09:26:09'!
 stdioHandles
" answer handles: #(stdin stdout stderr) "
	<primitive: 'primitiveFileStdioHandles' module: 'FilePlugin' error: ec>
	self primitiveFailed! !

!StdIOWriteStream class methodsFor: 'accessing' stamp: 'jmv 11/17/2016 09:26:12'!
                   stdoutHandle

	^ self stdioHandles at: 2! !

!StdIOWriteStream class methodsFor: 'cached state access' stamp: 'jmv 11/17/2016 11:44:50'!
                       releaseClassCachedState

	StdOut _ nil.
	StdErr _ nil! !


MorphicAlarm subclass: #StepMessage
	instanceVariableNames: 'stepTime lastEvaluationTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

!StepMessage methodsFor: 'evaluating' stamp: 'jmv 3/3/2017 11:28:02'!
                         rescheduleAfter: millisecondTimer
	"Schedule next run"
	scheduledTime _ scheduledTime + self stepTime max: millisecondTimer + 1! !

!StepMessage methodsFor: 'evaluating' stamp: 'jmv 3/3/2017 11:55:15'!
                      valueAtTime: millisecondClock

	|  nArgs millisecondsSinceLast |
	numArgs ifNil: [numArgs _ selector numArgs].
	nArgs _ arguments ifNil: [0] ifNotNil: [arguments size].
	lastEvaluationTime ifNil: [ lastEvaluationTime _ millisecondClock ].
	millisecondsSinceLast _ millisecondClock - lastEvaluationTime.
	lastEvaluationTime _ millisecondClock.
	nArgs = numArgs ifTrue: [
		"Ignore extra argument"
		^self value ].
	^arguments
		ifNil: [ receiver perform: selector with: millisecondsSinceLast]
		ifNotNil: [ receiver perform: selector withArguments: (arguments copyWith: millisecondsSinceLast) ]! !


Object subclass: #Stream
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:42'!
                              nextDouble64BigEndian: bigEndian
	"Store the given number as a 32 bit Float on this (binary) stream.

	Float pi hex '400921FB54442D18'
	Float pi negated hex 'C00921FB54442D18'

	(ByteArray streamContents: [ :strm |
		strm nextDouble64Put: Float pi bigEndian: false ])
			readStream nextDouble64BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextDouble64Put: Float pi bigEndian: true ])
			readStream nextDouble64BigEndian: true
	"
	| bytes |
	bytes _ self next: 8.
	^ bytes doubleAt: 1 bigEndian: bigEndian! !

!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:40'!
           nextDouble64Put: aFloat bigEndian: bigEndian
	"Store the given number as a 32 bit Float on this (binary) stream.

	Float pi hex '400921FB54442D18'
	Float pi negated hex 'C00921FB54442D18'

	(ByteArray streamContents: [ :strm |
		strm nextDouble64Put: Float pi bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextDouble64Put: Float pi bigEndian: true ]) hex
	"
	| bytes |
	bytes _ ByteArray new: 8.
	bytes doubleAt: 1 put: aFloat bigEndian: bigEndian.
	self nextPutAll: bytes! !

!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:38'!
     nextFloat32BigEndian: bigEndian
	"Store the given number as a 32 bit Float on this (binary) stream.

	Float pi hex '400921FB54442D18'
	Float pi negated hex 'C00921FB54442D18'
	Float pi asIEEE32BitWord hex '16r40490FDB'
	Float pi negated asIEEE32BitWord hex '16rC0490FDB'

	(ByteArray streamContents: [ :strm |
		strm nextFloat32Put: Float pi bigEndian: false ])
			readStream nextFloat32BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextFloat32Put: Float pi bigEndian: true ])
			readStream nextFloat32BigEndian: true
	"
	| bytes |
	bytes _ self next: 4.
	^ bytes floatAt: 1 bigEndian: bigEndian! !

!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:34'!
                 nextFloat32Put: aFloat bigEndian: bigEndian
	"Store the given number as a 32 bit Float on this (binary) stream.

	Float pi hex '400921FB54442D18'
	Float pi negated hex 'C00921FB54442D18'
	Float pi asIEEE32BitWord hex '16r40490FDB'
	Float pi negated asIEEE32BitWord hex '16rC0490FDB'

	(ByteArray streamContents: [ :strm |
		strm nextFloat32Put: Float pi bigEndian: false ]) hex 'DB0F4940'

	(ByteArray streamContents: [ :strm |
		strm nextFloat32Put: Float pi bigEndian: true ]) hex '40490FDB'
	"
	| bytes |
	bytes _ ByteArray new: 4.
	bytes floatAt: 1 put: aFloat bigEndian: bigEndian.
	self nextPutAll: bytes! !

!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:26'!
                   nextSignedInt16BigEndian: bigEndian
	"Answer the next  signed, 16-bit integer from this (binary) stream.

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt16Put: -12345 bigEndian: false ]) 
			readStream nextSignedInt16BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt16Put: -12345 bigEndian: true ]) 
			readStream nextSignedInt16BigEndian: true
	"
	| bytes |
	bytes _ self next: 2.
	^ bytes shortAt: 1 bigEndian: bigEndian! !

!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:26'!
         nextSignedInt16Put: aNumber bigEndian: bigEndian
	"Store the given number as a signed, 16-bit integer on this (binary) stream.

	(16r10000-12345) hex '16rCFC7'

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt16Put: -12345 bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt16Put: -12345 bigEndian: true ]) hex
	"
	| bytes |
	bytes _ ByteArray new: 2.
	bytes shortAt: 1 put: aNumber bigEndian: bigEndian.
	self nextPutAll: bytes! !

!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:26'!
                               nextSignedInt32BigEndian: bigEndian
	"Answer the next signed, 32-bit integer from this (binary) stream.

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt32Put: -123456 bigEndian: false ]) 
			readStream nextSignedInt32BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt32Put: -123456 bigEndian: true ]) 
			readStream nextSignedInt32BigEndian: true
	"
	| bytes |
	bytes _ self next: 4.
	^ bytes longAt: 1 bigEndian: bigEndian! !

!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:27'!
         nextSignedInt32Put: aNumber bigEndian: bigEndian
	"Store the given number as a signed, 32-bit integer on this (binary) stream.

	(16r100000000-123456) hex '16rFFFE1DC0'

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt32Put: -123456 bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt32Put: -123456 bigEndian: true ]) hex
	"
	| bytes |
	bytes _ ByteArray new: 4.
	bytes longAt: 1 put: aNumber bigEndian: bigEndian.
	self nextPutAll: bytes! !

!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:18'!
                     nextUnsignedInt16BigEndian: bigEndian
	"Answer the next unsigned, 16-bit integer from this (binary) stream.

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt16Put: 12345 bigEndian: false ]) 
			readStream nextUnsignedInt16BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt16Put: 12345 bigEndian: true ]) 
			readStream nextUnsignedInt16BigEndian: true
	"
	| bytes |
	bytes _ self next: 2.
	^ bytes unsignedShortAt: 1 bigEndian: bigEndian! !

!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:27'!
                        nextUnsignedInt16Put: aNumber bigEndian: bigEndian
	"Store the given number as a unsigned, 16-bit integer on this (binary) stream.

	12345 hex  '16r3039'

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt16Put: 12345 bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt16Put: 12345 bigEndian: true ]) hex
	"
	| bytes |
	bytes _ ByteArray new: 2.
	bytes unsignedShortAt: 1 put: aNumber bigEndian: bigEndian.
	self nextPutAll: bytes! !

!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:19'!
                           nextUnsignedInt32BigEndian: bigEndian
	"Answer the next unsigned, 32-bit integer from this (binary) stream.

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt32Put: 123456 bigEndian: false ]) 
			readStream nextUnsignedInt32BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt32Put: 123456 bigEndian: true ]) 
			readStream nextUnsignedInt32BigEndian: true
	"
	| bytes |
	bytes _ self next: 4.
	^ bytes unsignedLongAt: 1 bigEndian: bigEndian! !

!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:27'!
                       nextUnsignedInt32Put: aNumber bigEndian: bigEndian
	"Store the given number as a unsigned, 32-bit integer on this (binary) stream.

	123456 hex '16r1E240'

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt32Put: 123456 bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt32Put: 123456 bigEndian: true ]) hex
	"
	| bytes |
	bytes _ ByteArray new: 4.
	bytes unsignedLongAt: 1 put: aNumber bigEndian: bigEndian.
	self nextPutAll: bytes! !

!Stream methodsFor: 'nonhomogeneous accessing' stamp: 'jmv 6/14/2013 20:02'!
                  nextNumber
	"Answer a number from the stream."

	|element|
	[(element := self next) isNil or: [element isDigit or: [element = $- or: [element = $)]]]] whileFalse.
	element ifNil: [^nil].
	self skip: -1.
	element = $) ifTrue: [^nil].
	^Number readFrom: self! !

!Stream methodsFor: 'nonhomogeneous accessing' stamp: 'jmv 2/29/2016 11:04'!
              nextNumber: n 
	"Answer the next n bytes as a positive Integer or LargePositiveInteger.
	Currently only for bigEndian. Consider following the convention in category 'normalized access'"
	| s |
	s _ 0.
	1 to: n do: 
		[:i | s _ (s bitShift: 8) bitOr: self next asInteger].
	^ s normalize! !

!Stream methodsFor: 'nonhomogeneous accessing' stamp: 'jmv 2/29/2016 11:04'!
                nextNumber: n put: v 
	"Append to the receiver the argument, v, which is a positive 
	SmallInteger or a LargePositiveInteger, as the next n bytes.
	Possibly pad with leading zeros.
	Currently only for bigEndian. Consider following the convention in category 'normalized access'"

	1 to: n do: [:i | self nextPut: (v digitAt: n+1-i)].
	^ v
! !

!Stream methodsFor: 'nonhomogeneous accessing' stamp: 'ls 9/14/1998 22:46'!
                            nextString
	"Read a string from the receiver. The first byte is the length of the string, unless it is greater than 192, in which case the first four bytes encode the length.  I expect to be in ascii mode when called (caller puts back to binary)."

	| aString length |

	"read the length in binary mode"
	self binary.
	length _ self next.		"first byte."
	length >= 192 ifTrue: [length _ length - 192.
		1 to: 3 do: [:ii | length _ length * 256 + self next]].
	aString _ String new: length.

	"read the characters in ASCII mode"
	self ascii.
	self nextInto: aString.
	^aString! !

!Stream methodsFor: 'nonhomogeneous accessing' stamp: 'yo 4/16/2001 17:56'!
                nextStringPut: s 
	"Append the string, s, to the receiver.  Only used by DataStream.  Max size of 64*256*256*256."

	| length |
	(length _ s size) < 192
		ifTrue: [self nextPut: length]
		ifFalse: 
			[self nextPut: (length digitAt: 4)+192.
			self nextPut: (length digitAt: 3).
			self nextPut: (length digitAt: 2).
			self nextPut: (length digitAt: 1)].
	self nextPutAll: s asByteArray.
	^s! !


AbstractFont subclass: #StrikeFont
	instanceVariableNames: 'characterToGlyphMap xTable glyphs name type minAscii maxAscii maxWidth ascent descent subscript superscript emphasis baseFont derivativeFonts pointSize'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Text'!

!StrikeFont methodsFor: 'accessing' stamp: 'jmv 9/25/2017 20:45:55'!
             baseKern
	"Return the base kern value to be used for all characters.
	What follows is some 'random' text used to visually adjust this method.
	HaHbHcHdHeHfHgHhHiHjHkHlHmHnHoHpHqHrHsHtHuHvHwHxHyHzH
	HAHBHCHDHEHFHGHHHIHJHKHLHMHNHOHPHQHRHSHTHUHVHWHXHYHXZH
	wok yuyo	wuwu	vuvu	rucu	tucu	WUWU	VUVU	huevo	HUEVO	to
											k y mate	runico ridiculo	ARABICO	AAAAA	TOMATE
	TUTU
	tatadalajafua
	abacadafagahaqawaearatayauaiaoapasadafagahajakalazaxacavabanama
	kUxUxa
	q?d?h?l?t?f?j?"
	
	| italic baseKern |
	italic _ self isItalic.
	
	"Assume synthetic will not affect kerning (i.e. synthetic italics are not used)"
	"After all, DejaVu Sans are the only StrikeFonts used in Cuis..."
"	self familyName = 'DejaVu Sans'
		ifTrue: ["
			baseKern _ (italic or: [ pointSize < 9 ])
				ifTrue: [ -1 ]
				ifFalse: [ 0 ].
			pointSize >= 13 ifTrue: [
				baseKern _ baseKern +1 ].
			pointSize >= 20 ifTrue: [
				baseKern _ baseKern +1 ]"]
		ifFalse: [
			baseKern _ pointSize < 12
				ifTrue: [ -1 ]
				ifFalse: [ 0 ].
			italic ifTrue: [
				baseKern _ baseKern - 1]]".
	
	"If synthetic italic"
	"See makeItalicGlyphs"
	(self isSynthetic and: [ italic and: [ self isBold ]]) ifTrue: [
		baseKern _ baseKern - ((self height-1-self ascent+4)//4 max: 0)  
		- (((self ascent-5+4)//4 max: 0)) ].
	^baseKern! !

!StrikeFont methodsFor: 'emphasis' stamp: 'jmv 4/10/2015 23:21'!
                makeBoldGlyphs
	"Make a bold set of glyphs with same widths by ORing 1 bit to the right
		(requires at least 1 pixel of intercharacter space)"
	| g bonkForm |
	g _ glyphs copy.
	bonkForm _ (Form extent: 1@16) fillBlack offset: -1@0.
	self bonk: g with: bonkForm.
	glyphs depth = 1 ifTrue: [
		g copyBits: g boundingBox from: g at: (1@0)
			clippingBox: g boundingBox rule: Form under ]
		ifFalse: [
			0 to: g width - 2 do: [ :x | 0 to: g height-1 do: [ :y |
				(glyphs colorAt:  x@y) = Color white ifFalse: [
					g colorAt: x+1@y put: 
						((glyphs colorAt: x+1@y) = Color white 
							ifTrue: [glyphs colorAt:  x@y]
							ifFalse: [Color black])]]]].
	glyphs _ g.
	self isSynthetic: true! !

!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 9/2/2016 11:03:22'!
   makeControlCharsVisible
	| glyph |
	self characterToGlyphMap.
	glyph _ self glyphAt: (Character space).
	glyph border: glyph boundingBox width: 1 fillColor: Color blue.
	self glyphAt: (Character numericValue: 134) put: glyph.
	
	"Keep tab(9), lf(10), cr(13) and space(32) transparent or whatever the user chose"
	#(0 1 2 3 4 5 6 7 8 11 12 14 15 16 17 18 19 20 21 22 23 24 25 26 27)
		do: [ :ascii |
			characterToGlyphMap at: ascii + 1 put: 134 ]! !

!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 9/24/2017 22:08:45'!
                           makeCrInvisible
	| glyph |
	glyph _ self glyphAt: Character cr.
	glyph fillWhite.
	self glyphAt: Character cr put: glyph! !

!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 9/24/2017 22:07:50'!
 makeCrVisible
	| glyph |
	glyph _ self glyphAt: (Character numericValue: 182).
	glyph border: glyph boundingBox width: 1 fillColor: Color blue.
"	glyph _ glyph reverse."
	self glyphAt: Character cr put: glyph! !

!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 9/24/2017 22:09:18'!
         makeLfInvisible
	| glyph |
	glyph _ self glyphAt: Character lf.
	glyph fillWhite.
	self glyphAt: Character lf put: glyph! !

!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 9/24/2017 22:07:44'!
 makeLfVisible
	| glyph |
	glyph _ self glyphAt: (Character numericValue: 163).
	glyph border: glyph boundingBox width: 1 fillColor: Color blue.
"	glyph _ glyph reverse."
	self glyphAt: Character lf put: glyph! !

!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 9/24/2017 20:24:03'!
         makeTabInvisible
	self characterToGlyphMap.
	characterToGlyphMap at: 10 put: (10 < minAscii ifFalse: [10] ifTrue: [maxAscii+1])! !

!StrikeFont methodsFor: 'building' stamp: 'jmv 9/24/2017 20:49:47'!
                        buildFromForm: allGlyphs data: data name: aString

	| x shortUnderscore firstGlyphInFiles |
	pointSize _ data first asNumber.
	ascent _ data second asNumber.
	descent _ data third asNumber.

	firstGlyphInFiles _ 257-(data size-3).
	minAscii _ 1.
	maxAscii _ 255.
	name _ aString.
	type _ 0.  "ignored for now"
	superscript _ ascent - descent // 3.	
	subscript _ descent - ascent // 3.	
	emphasis _ 0.

	xTable _ (Array new: 258) atAllPut: 0.
	maxWidth _ 0.
	glyphs _ allGlyphs depth > 16 ifTrue: [ allGlyphs asFormOfDepth: 16 ] ifFalse: [ allGlyphs ].
	x _ 0.
	4 to: data size do: [ :i |
		x _ (data at: i) asNumber.
		xTable at: i+firstGlyphInFiles+1-4 put: x].
	xTable at: 258 put: x.
	self reset.
	derivativeFonts _ nil.

	self makeCrVisible.

	"Replace glyph for 127 (a box) with a short version of the underscore (used to optionally mark subscript in code)"
	shortUnderscore _ self glyphAt: $_.
	shortUnderscore _ shortUnderscore copy: (0@0 extent: 1@shortUnderscore height).
	self glyphAt: (Character numericValue: 127) put: shortUnderscore! !

!StrikeFont methodsFor: 'synthetic derivatives' stamp: 'jmv 9/25/2017 20:44:21'!
                    syntheticSubscript
	"Build and answer a derivative that is Subscript."

	| derivative |
	derivative _ ((AbstractFont familyName: Preferences defaultFontFamily aroundPointSize: pointSize * 0.58)
		emphasized: emphasis)
			copy.
	derivative useShortUnderscore.
	^ derivative

"
StrikeFont allInstances do: [ :a | a reset ].
('Hi ', (Text string: 'there' attribute: TextEmphasis superscript), ' how ', (Text string: 'are' attribute: TextEmphasis subscript), ' you?') edit.

que todos, menos estos, tengan superscript y subscript en cero. Y en estos, apropiado. y en 'aca' usarlo. y listo
"! !

!StrikeFont methodsFor: 'synthetic derivatives' stamp: 'jmv 9/25/2017 20:44:26'!
syntheticSuperscript
	"Build and answer a derivative that is Superscript."

	| derivative |
	derivative _ ((AbstractFont familyName: Preferences defaultFontFamily aroundPointSize: pointSize * 0.58)
		emphasized: emphasis)
			copy.
	derivative name: self name , 'Sup'.
	^ derivative

"
StrikeFont allInstances do: [ :a | a reset ].
('Hi ', (Text string: 'there' attribute: TextEmphasis superscript), ' how ', (Text string: 'are' attribute: TextEmphasis subscript), ' you?') edit.
"! !


StrikeFont class
	instanceVariableNames: ''!

!StrikeFont class methodsFor: 'instance creation' stamp: 'jmv 9/25/2017 20:17:15'!
                         create: fontName size: pointSize bold: includeBold italic: includeItalic boldItalic: includeBoldItalic
	"
	self create: 'DejaVu Sans Mono' size: 12 bold: true italic: true boldItalic: true
	"
	| folder base bold oblique boldOblique point |
	folder _ DirectoryEntry smalltalkImageDirectory / 'AdditionalFontData'.
	point _ pointSize asString.
	base _ [ (StrikeFont new
		buildFromForm: ((Form fromFileEntry: folder // (fontName, '-0-', point, '.bmp')) asFormOfDepth: 16)
		data: (folder // (fontName, '-0-', point, '.txt')) fileContents substrings
		name: fontName, ' ', point)
			pointSize: pointSize ] on: FileDoesNotExistException do: [ : ex | ex print. nil ].
	includeBold ifTrue: [
		bold _ [ (StrikeFont new
			buildFromForm: ((Form fromFileEntry: folder // (fontName, '-1-', point, '.bmp')) asFormOfDepth: 16)
			data: (folder // (fontName, '-1-', point, '.txt')) fileContents substrings
			name: fontName, ' ', point, 'B')
				emphasis: 1;
				pointSize: pointSize ] on: FileDoesNotExistException do: [ : ex | ex print. nil ]].
	includeItalic ifTrue: [
		oblique _ [ (StrikeFont new
			buildFromForm: ((Form fromFileEntry: folder // (fontName, '-2-', point, '.bmp')) asFormOfDepth: 16)
			data: (folder // (fontName, '-2-', point, '.txt')) fileContents substrings
			name: fontName, ' ', point, 'I')
				emphasis: 2;
				pointSize: pointSize ] on: FileDoesNotExistException do: [ : ex | ex print. nil ]].
	includeBoldItalic ifTrue: [
		boldOblique _ [ (StrikeFont new
			buildFromForm: ((Form fromFileEntry: folder // (fontName, '-3-', point, '.bmp')) asFormOfDepth: 16)
			data: (folder // (fontName, '-3-', point, '.txt')) fileContents substrings
			name: fontName, ' ', point, 'BI')
				emphasis: 3;
				pointSize: pointSize ] on: FileDoesNotExistException do: [ : ex | ex print. nil ]].
	"We have a regular, base font. Make others derivatives of it"
	base ifNotNil: [
		bold ifNotNil: [
			base derivativeFont: bold at: 1 ].
		oblique ifNotNil: [
			base derivativeFont: oblique at: 2].
		boldOblique ifNotNil: [
			base derivativeFont: boldOblique at: 3 ].
		^base ].
	"We don't have a base, regular font."
	oblique ifNotNil: [
		oblique emphasis: 0.	"Hacky. Non regular fonts can not have derivatives. Should change this?"
		bold ifNotNil: [
			oblique derivativeFont: bold at: 1 ].
		boldOblique ifNotNil: [
			oblique derivativeFont: boldOblique at: 3 ].
		^oblique ].
	bold ifNotNil: [
		bold emphasis: 0.	"Hacky. Non regular fonts can not have derivatives. Should change this?"
		boldOblique ifNotNil: [
			bold derivativeFont: boldOblique at: 3 ].
		^bold ].
	boldOblique ifNotNil: [
		^boldOblique ].
	^nil! !

!StrikeFont class methodsFor: 'instance creation' stamp: 'jmv 9/25/2017 20:48:55'!
       install: aString
"
StrikeFont install: 'DejaVu Sans'.
StrikeFont buildLargerPunctuation: 'DejaVu Sans'.
Preferences setDefaultFontFamilyTo: 'DejaVu Sans'.
Preferences standardFonts.
Character initialize.
"
"
StrikeFont install: 'DejaVu Sans Mono'.
Preferences setDefaultFontFamilyTo: 'DejaVu Sans Mono'.
Preferences bigFonts.
Character initialize.
"
"
StrikeFont install: 'Inconsolata'
StrikeFont install: '#PilGi'
StrikeFont install: 'Optima'
StrikeFont install: 'Herculanum'
StrikeFont install: 'Papyrus'
StrikeFont install: 'Handwriting - Dakota'
StrikeFont install: 'Times New Roman'
StrikeFont install: 'Apple Chancery'
StrikeFont install: 'Cochin'
StrikeFont install: 'Cracked'
StrikeFont install: 'Zapfino'
StrikeFont install: 'Brush Script MT'
StrikeFont install: 'Chalkboard'
"
	| fontDict |
	fontDict _ Dictionary new.
	#(5 6 7 8 9 10 11 12 14 17 22) do: [ :s |
		(self create: aString size: s bold: true italic: true boldItalic: false) ifNotNil: [ :font |
			fontDict
				at: s
				put: font ]].
	fontDict notEmpty ifTrue: [
		AvailableFonts at: aString put: fontDict ].
	Preferences restoreDefaultFonts! !

!StrikeFont class methodsFor: 'removing' stamp: 'jmv 9/25/2017 20:41:27'!
                       removeForPDA
"
StrikeFont removeForPDA
"
	| familyDict |
	familyDict _ AvailableFonts at: Preferences defaultFontFamily.
	familyDict keys do: [ :k |
		(#(5 6 7 8 9) includes: k) 
			ifTrue: [
				(familyDict at: k) derivativeFont: nil at: 0 ]
			ifFalse: [
				familyDict removeKey: k ]].
	
	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 8)
			(setListFontTo: 6)
			(setMenuFontTo: 7)
			(setWindowTitleFontTo: 9)
			(setCodeFontTo: 7)
			(setButtonFontTo: 7))! !

!StrikeFont class methodsFor: 'removing' stamp: 'jmv 9/25/2017 20:42:25'!
                       removeMostFonts
"
StrikeFont removeMostFonts
"
	| familyDict |
	Preferences disable: #italicsInShout.
	SHTextStylerST80 initialize.
	familyDict _ AvailableFonts at: Preferences defaultFontFamily.
	familyDict keys do: [ :k |
		(#(8 10 12) includes: k) 
			ifTrue: [
				(familyDict at: k) derivativeFont: nil at: 0 ]
			ifFalse: [
				familyDict removeKey: k ]].

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 10)
			(setListFontTo: 10)
			(setMenuFontTo: 10)
			(setWindowTitleFontTo: 12)
			(setCodeFontTo: 10)
			(setButtonFontTo: 10))! !

!StrikeFont class methodsFor: 'removing' stamp: 'jmv 9/25/2017 20:42:49'!
         removeSomeFonts
"
StrikeFont removeSomeFonts
"
	| familyDict |
	familyDict _ AvailableFonts at: Preferences defaultFontFamily.
	familyDict keys do: [ :k |
		"No boldItalic for the followint"
		(#(5 6 7 8 9 10 11 12 14 17 22) includes: k)
			ifTrue: [ (familyDict at: k) derivativeFont: nil at: 3 ].
		"No derivatives at all for the following"
		(#() includes: k)
			ifTrue: [ (familyDict at: k) derivativeFont: nil at: 0 ].
		"Sizes to keep"
		(#(5 6 7 8 9 10 11 12 14 17 22) includes: k) 
			ifFalse: [ familyDict removeKey: k ]].

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 9)
			(setListFontTo: 9)
			(setMenuFontTo: 10)
			(setWindowTitleFontTo: 12)
			(setCodeFontTo: 9)
			(setButtonFontTo: 9))! !

!StrikeFont class methodsFor: 'character shapes' stamp: 'jmv 9/25/2017 20:45:01'!
                           buildLargerPunctuation: familyName
	"
	StrikeFont buildLargerPunctuation: 'DejaVu Sans'
	"
	| form form2 f10 f11 f12 f9 |

	f9 _ AbstractFont familyName: familyName pointSize: 9.
	f10 _ AbstractFont familyName: familyName pointSize: 10.
	f11 _ AbstractFont familyName: familyName pointSize: 11.
	f12 _ AbstractFont familyName: familyName pointSize: 12.


	f9 takeGlyphFor: $. from: $. in: f12.
	f9 takeGlyphFor: $, from: $, in: f12.
	
	form _ f9 glyphAt: $..
	form copy: (0@9 extent: 3@14) from: form to: 0@4 rule: Form and.
	f9 glyphAt: $: put: form.

	form _ f9 glyphAt: $,.
	form2 _ f9 glyphAt: $..
	form copy: (0@9 extent: 3@14) from: form2 to: 1@4 rule: Form and.
	f9 glyphAt: $; put: form.



	f10 takeGlyphFor: $. from: $. in: f12.
	f10 takeGlyphFor: $, from: $, in: f12.

	form _ f10 glyphAt: $. .
	form copy: (0@9 extent: 3@14) from: form to: 0@4 rule: Form and.
	f10 glyphAt: $: put: form.

	form _ f10 glyphAt: $,.
	form2 _ f10 glyphAt: $..
	form copy: (0@9 extent: 3@14) from: form2 to: 1@4 rule: Form and.
	f10 glyphAt: $; put: form.



	f11 takeGlyphFor: $. from: $. in: f12.
	f11 takeGlyphFor: $, from: $, in: f12.
	f11 takeGlyphFor: $: from: $: in: f12.
	f11 takeGlyphFor: $; from: $; in: f12! !


ArrayedCollection variableByteSubclass: #String
	instanceVariableNames: ''
	classVariableNames: 'CSLineEnders CSNonSeparators CSSeparators CaseInsensitiveOrder CaseSensitiveOrder LowercasingTable Tokenish UppercasingTable'
	poolDictionaries: ''
	category: 'Kernel-Text'!

!String methodsFor: 'converting' stamp: 'HAW 8/22/2017 10:14:02'!
                aOrAnPrefix

	^self isEmpty 
		ifTrue: [ self ]
		ifFalse: [ self first isVowel ifTrue: ['an'] ifFalse: ['a'] ]
! !

!String methodsFor: 'converting' stamp: 'jmv 5/12/2017 11:22:17'!
         asDate
	"Many allowed forms, see Date>>#readFrom:
		'2014/6/30' asDate.
		'70/12/30' asDate.
		'12/30/70' asDate.
		'30/12/70' asDate.
		'4/5/6' asDate.
		'15 April 1982' asDate.
	"

	^ Date fromString: self! !

!String methodsFor: 'converting' stamp: 'jmv 5/12/2017 11:24:09'!
          asMonth
	"Many allowed forms, see Month>>#readFrom:
		'July 1998' asMonth.
		'1998/7'asMonth.
	"

	^ Month fromString: self! !

!String methodsFor: 'converting' stamp: 'jmv 5/12/2017 16:39:13'!
                              asWeek
	"
		'2008-W52' asWeek.
		'2008-W53' asWeek. 'Invalid format!!'.
		'2009-W01' asWeek
		'2009-W02' asWeek
		'2009-W53' asWeek
		'2010-W01' asWeek
		'2010-W02' asWeek
		'2008-W52' asWeek start.
		'2009-W01' asWeek start
		'2009-W02' asWeek start
		'2009-W53' asWeek start
		'2010-W01' asWeek start
		'2010-W02' asWeek start
	"

	^ Week fromString: self! !

!String methodsFor: 'converting' stamp: 'jmv 5/12/2017 16:37:23'!
                    asYear
	"
		'2008' asYear.
		'2008' asYear start.
	"

	^ Year fromString: self! !

!String methodsFor: 'converting' stamp: 'HAW 8/22/2017 10:14:46'!
           prefixedWithAOrAn

	^self aOrAnPrefix, self! !

!String methodsFor: 'displaying' stamp: 'jmv 6/19/2017 16:12:23'!
              displayOn: aDisplayMedium
	"Display the receiver on the given DisplayMedium.  5/16/96 sw"

	self displayOn: aDisplayMedium at: `0 @ 0`! !

!String methodsFor: 'displaying' stamp: 'jmv 5/12/2015 15:52'!
                      displayOn: aDisplayMedium at: aPoint 
	"Show a representation of the receiver as a DisplayText at location aPoint on aDisplayMedium, using black-colored text."

	^self displayOn: aDisplayMedium at: aPoint textColor: Color black
	"
	'Display' displayOn: Display at: 10@10
	"! !

!String methodsFor: 'displaying' stamp: 'jmv 7/17/2017 15:41:46'!
        displayProgressAt: aPoint from: minVal to: maxVal during: workBlock
	"Display this string as a caption over a progress bar while workBlock is evaluated.

EXAMPLE (Select next 6 lines and Do It)

'Now here''s some Real Progress'
	displayProgressAt: Sensor mousePoint
	from: 0 to: 100
	during: [:barBlock |
		1 to: 100 do: [:x | 
			(Delay forMilliseconds: 10) wait.
			barBlock value: x.]].

['Now here''s some Real Progress'
	displayProgressAt: Sensor mousePoint
	from: 0 to: 100
	during: [:barBlock |
	1 to: 100 do: [:x | barBlock value: x.
			(Delay forMilliseconds: 100) wait]].] fork
	
['Now here''s some Real Progress'
	displayProgressAt: Sensor mousePoint
	from: 0 to: 10
	during: [:barBlock |
	1 to: 30 do: [:x | barBlock value: x \\ 11.
			(Delay forMilliseconds: 100) wait]]] fork

'Now here''s some Real Progress'
	displayProgressAt: Sensor mousePoint
	from: 0 to: 10
	during: [:barBlock |
	1 to: 30 do: [:x | barBlock value: nil.
			(Delay forMilliseconds: 200) wait]].

HOW IT WORKS (Try this in any other language :-)
Since your code (the last 2 lines in the above example) is in a block,
this method gets control to display its heading before, and clean up 
the screen after, its execution.
The key, though, is that the block is supplied with an argument,
named 'bar' in the example, which will update the bar image every 
it is sent the message value: x, where x is in the from:to: range.

The use of ProgressInitiationException allows for avoiding actual
progress display, by catching the exception.
"
	^ProgressInitiationException 
		display: self
		at: aPoint 
		from: minVal 
		to: maxVal 
		during: workBlock! !

!String methodsFor: 'private' stamp: 'jmv 1/13/2017 09:58:04'!
replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !

!String methodsFor: 'testing' stamp: 'len 11/26/2016 09:05:35'!
  isAlphaNumeric
	"Answer true if the receiver contains only letters or digits."
	^ self allSatisfy: [:each| each isAlphaNumeric]! !


RectangleLikeMorph subclass: #StringMorph
	instanceVariableNames: 'font emphasis contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Basic'!

!StringMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:57:40'!
                 drawOn: aCanvas
	aCanvas
		drawString: (contents ifNil: [ '' ])
		at: `0@0`
		font: self fontToUse
		color: color
		! !

!StringMorph methodsFor: 'initialization' stamp: 'jmv 12/9/2016 09:09:45'!
                            initialize
	super initialize.
	font _ nil.
	emphasis _ 0.
	self contents: 'String Morph'
! !

!StringMorph methodsFor: 'geometry' stamp: 'jmv 6/19/2017 15:57:44'!
                             fitContents
	"Measures contents later at #minimumExtent"
	self morphExtent: `0@0`! !

!StringMorph methodsFor: 'geometry' stamp: 'jmv 1/15/2017 14:22:53'!
     measureContents
	| f |
	f _ self fontToUse.
	^((f widthOfString: contents) max: 3)  @ f height! !


StringMorph class
	instanceVariableNames: ''!

!StringMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:55:41'!
                     categoryInNewMorphMenu
	^ 'Basic'! !


Object subclass: #SyntaxTreeNode
	instanceVariableNames: 'node properties children'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Extensions'!

!SyntaxTreeNode methodsFor: 'adding' stamp: 'pb 6/12/2015 21:15'!
                     addChild: aNode
	children add: aNode! !

!SyntaxTreeNode methodsFor: 'adding' stamp: 'pb 6/13/2015 02:21'!
                     addChildren: nodes
	nodes do: [ :curNode |
		children add: curNode ].! !

!SyntaxTreeNode methodsFor: 'converting' stamp: 'pb 6/14/2015 02:42'!
                asArray
	^ self collect: [:ea| ea]! !

!SyntaxTreeNode methodsFor: 'accessing' stamp: 'pb 6/13/2015 19:10'!
                    at: key
	^ properties at: key.! !

!SyntaxTreeNode methodsFor: 'accessing' stamp: 'pb 6/13/2015 19:09'!
                        at: key put: value
	^ properties
		at: key
		put: value.! !

!SyntaxTreeNode methodsFor: 'accessing' stamp: 'pb 6/13/2015 18:32'!
                              node
	^ node! !

!SyntaxTreeNode methodsFor: 'accessing' stamp: 'pb 6/12/2015 21:18'!
          node: aNode
	node := aNode! !

!SyntaxTreeNode methodsFor: 'accessing' stamp: 'pb 6/13/2015 19:09'!
                            properties: propColl
	propColl do: [ :prop |
		self
			at: prop key
			put: prop value ].! !

!SyntaxTreeNode methodsFor: 'private' stamp: 'pb 6/14/2015 01:51'!
                               children
	^ children! !

!SyntaxTreeNode methodsFor: 'private' stamp: 'pb 6/14/2015 02:46'!
    collectDepthFirst: aBlock with: node
	"Recurse the tree depth-first collecting the result of calling aBlock for each element"
	| results |
	results := OrderedCollection new.
	results add: (aBlock value: node).
	node childrenDo: [ :cnode |
		results addAll:
			(self
				collectDepthFirst: aBlock
				with: cnode) ].
	^ results.! !

!SyntaxTreeNode methodsFor: 'private' stamp: 'pb 6/14/2015 02:46'!
                 doDepthFirst: aBlock with: node
	"Recurse the tree depth-first calling aBlock for each element"
	aBlock value: node.
	node childrenDo: [ :cnode |
		self
			doDepthFirst: aBlock
			with: cnode ].! !

!SyntaxTreeNode methodsFor: 'private' stamp: 'pb 6/16/2015 17:23'!
                      properties
	^ properties! !

!SyntaxTreeNode methodsFor: 'enumerating' stamp: 'pb 6/14/2015 02:54'!
                            childrenDo: aBlock
	"Call aBlock for each direct child"
	children do: aBlock.! !

!SyntaxTreeNode methodsFor: 'enumerating' stamp: 'pb 6/14/2015 02:46'!
       collect: aBlock
	"Recurse the tree depth-first collecting the result of calling aBlock for each element"
	^ self
		collectDepthFirst: aBlock
		with: self.! !

!SyntaxTreeNode methodsFor: 'enumerating' stamp: 'pb 6/14/2015 02:46'!
                          do: aBlock
	"Recurse the tree depth-first calling aBlock for each element"
	^ self
		doDepthFirst: aBlock
		with: self.! !

!SyntaxTreeNode methodsFor: 'initialization' stamp: 'pb 6/13/2015 01:52'!
                          initialize
	super initialize.
	properties := Dictionary new.
	children := OrderedCollection new.! !

!SyntaxTreeNode methodsFor: 'printing' stamp: 'pb 10/1/2017 15:23:45'!
                    printOn: aStream
	| title |
	title := self class name.
	aStream
		nextPutAll:
			(title first isVowel
				ifTrue: [ 'an ' ]
				ifFalse: [ 'a ' ]);
		nextPutAll: title;
		nextPut: $(;
		nextPutAll: node asString;
		nextPut: $).! !

!SyntaxTreeNode commentStamp: '<historical>' prior: 0!
 A simple, generic syntax tree node which can be used for both concrete and abstract trees.!

SyntaxTreeNode class
	instanceVariableNames: ''!

!SyntaxTreeNode class methodsFor: 'instance creation' stamp: 'pb 6/13/2015 02:14'!
                              node: aNode
	^ (self
		new)
		node: aNode;
		yourself.! !

!SyntaxTreeNode class methodsFor: 'private' stamp: 'pb 6/14/2015 02:01'!
                            testTree
	| child node |
	node := self node: 1.
	child := self node: 2.
	5
		to: 7
		do: [ :idx | | gChild |
			gChild := self node: idx.
			gChild addChild: (self node: idx * 10).
			child addChild: gChild ].
	node addChild: child.
	child := self node: 3.
	8
		to: 10
		do: [ :idx |
			child addChild: (self node: idx) ].
	node addChild: child.
	child := self node: 4.
	11
		to: 13
		do: [ :idx |
			child addChild: (self node: idx) ].
	node addChild: child.
	^ node.! !


IdentityDictionary subclass: #SystemDictionary
	instanceVariableNames: 'cachedClassNames cachedNonClassNames startUpScriptArguments startUpArguments'
	classVariableNames: 'EndianCache LastImageName LastQuitLogPosition LowSpaceProcess LowSpaceSemaphore ShutDownList SourceFileVersionString SpecialSelectors StartUpList StartupStamp WordSize'
	poolDictionaries: ''
	category: 'System-Support'!

!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 6/20/2017 13:47:09'!
               browseObsoleteMethodReferences
	"Open a browser on all referenced behaviors that are obsolete
		Smalltalk browseObsoleteMethodReferences
	Remember that if no methods reference obsoletes, but
		Smalltalk obsoleteBehaviors inspect
	still finds them, maybe they are referenced by ChangeSets!!
	"
	| list |
	list _ self obsoleteMethodReferences.
	self browseMessageList: list name:'Method referencing obsoletes' autoSelect: nil! !

!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 7/17/2017 15:46:10'!
      condenseChanges
	"Move all the changes onto a compacted sources file."
	"
	Smalltalk condenseChanges
	"

	| oldChanges classCount oldChangesLocalName oldChangesPathName |
	DirectoryEntry smalltalkImageDirectory // 'ST80.temp' forceWriteStreamDo: [ :f |
		f timeStamp.
		'Condensing Changes File...'
			displayProgressAt: Sensor mousePoint
			from: 0 to: Smalltalk classNames size
			during: [ :barBlock |
				classCount _ 0.
				Smalltalk allClassesDo: [ :class | 
					barBlock value: (classCount _ classCount + 1).
					class moveChangesTo: f.
					class putClassCommentToCondensedChangesFile: f.
					class class moveChangesTo: f ]].
		LastQuitLogPosition _ f position ].

	CompiledMethod allInstancesDo: [ :e | 
		e isInstalled ifFalse: [ e destroySourcePointer ] ].

	oldChanges _ SourceFiles at: 2.
	oldChangesPathName _ oldChanges name.
	oldChangesLocalName _ oldChanges localName.
	oldChanges close.
	(oldChangesPathName, '.old') asFileEntry delete.
	oldChangesPathName asFileEntry rename: oldChangesLocalName, '.old'.
	DirectoryEntry smalltalkImageDirectory // 'ST80.temp' rename: oldChangesLocalName.
	
	SourceFiles
			at: 2 put: oldChangesPathName asFileEntry appendStream.

	self inform: 'Changes file has been rewritten!!

Check that all is well, and then save/quit.
 
Otherwise, remove new changes,
replace it with the former one, and
exit without saving the image.
 '! !

!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 7/17/2017 15:46:14'!
       condenseSources	
	"Move all the changes onto a compacted sources file."
	"Smalltalk condenseSources"

	| classCount newVersionString oldChanges oldChangesLocalName oldChangesPathName newChangesPathName newSourcesName |
	newVersionString _ FillInTheBlankMorph request: 'Please name the new sources file' initialAnswer: SourceFileVersionString.
	newVersionString ifNil: [^ self].
	newVersionString = SourceFileVersionString ifTrue: [
		^ self error: 'The new source file must not be the same as the old.'].
	SourceFileVersionString _ newVersionString.

	"Write all sources with fileIndex 1"
	newSourcesName _ self defaultSourcesName.
	newSourcesName asFileEntry writeStreamDo: [ :f |
		f timeStamp.
		'Condensing Sources File...'
			displayProgressAt: Sensor mousePoint
			from: 0 to: Smalltalk classNames size
			during: [ :barBlock |
				classCount _ 0.
				Smalltalk allClassesDo: [ :class |
					barBlock value: (classCount _ classCount + 1).
					class fileOutOn: f moveSource: true toFile: 1]]].

	CompiledMethod allInstancesDo: [ :e | 
		e isInstalled ifFalse: [ e destroySourcePointer ] ].

	"Make a new empty changes file"
	oldChanges _ SourceFiles at: 2.
	oldChangesPathName _ oldChanges name.
	oldChangesLocalName _ oldChanges localName.
	self closeSourceFiles.
	oldChangesPathName ifNotNil: [
		(oldChangesPathName, '.old') asFileEntry delete.
		oldChangesPathName asFileEntry rename: oldChangesLocalName, '.old' ].
	newChangesPathName _ self defaultChangesName.
	newChangesPathName asFileEntry writeStreamDo: [ :stream |
		stream timeStamp ].
	LastQuitLogPosition _ 0.

	self openSourceFiles.
	self inform: 'Source files have been rewritten!!
 
Check that all is well, and then save/quit.
 
Otherwise, remove new sources/changes,
replace them with the former ones, and
exit without saving the image.
 '! !

!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 7/17/2017 15:41:56'!
                        macroBenchmark1    "Smalltalk macroBenchmark1"
	"Decompiles and prettyPrints the source for every method in the system (or less depending on the *FILTER*, and then compiles that source and verifies that it generates (and decompiles to) identical code.  This currently fails in a number of places because some different patterns (esp involving conditionals where the first branch returns) decompile the same.  Because it never installs the new method, it should not cause any flusing of the method cache."
	 | methodNode oldMethod newMethod badOnes oldCodeString n classes |
	classes _ Smalltalk allClasses select: [:c | c name < 'B3'].
	badOnes _ OrderedCollection new.
'Decompiling and recompiling...'
displayProgressAt: Sensor mousePoint
from: 0 to: (classes detectSum: [:c | c selectors size])
during: [:barBlock | n _ 0.
	classes do:
		[:cls | 
		"Transcript cr; show: cls name."
		cls selectors do:
			[:selector | barBlock value: (n _ n+1).
			oldMethod _ cls compiledMethodAt: selector.
			oldCodeString _ (cls decompilerClass new
								decompile: selector in: cls method: oldMethod)
							decompileString.
			methodNode _ cls compilerClass new
						compile: oldCodeString
						in: cls notifying: nil ifFail: nil.
			newMethod _ methodNode generate: #(0 0 0 0).
			oldCodeString = (cls decompilerClass new
								decompile: selector in: cls method: newMethod)
							decompileString ifFalse: [badOnes add: cls name , ' ' , selector]]].
].
	^ badOnes size! !

!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 7/17/2017 15:46:19'!
                  macroBenchmark3   "Smalltalk macroBenchmark3"
	| testBlock tallies prev receiver |
	"Runs the stepping simulator with the messageTally tree (like tallySends)."
	testBlock _
		['Running the context step simulator'
			displayProgressAt: Sensor mousePoint
			from: 0 to: 200
			during:
				[:barBlock |
				1 to: 200 do:
				[:x | barBlock value: x.
				Float pi printString.
				15 factorial printString]]].
	tallies _ MessageTally new class: testBlock receiver class
							method: testBlock method.
	receiver _ nil.
	prev _ testBlock.
	thisContext sender
		runSimulated: testBlock
		contextAtEachStep:
			[:current |
			current == prev ifFalse: [
				"call or return"
				prev sender ifNotNil: [
					"call only"
					(receiver == nil or: [current receiver == receiver])
						ifTrue: [tallies tally: current by: 1]].
				prev _ current]].
! !

!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 6/20/2017 13:46:17'!
     obsoleteBehaviors
	"
	Smalltalk obsoleteBehaviors inspect
	Find all obsolete behaviors including meta classes
	"
	| obs |
	obs _ OrderedCollection new.
	Smalltalk garbageCollect.
	self allObjectsDo: [ :cl |
		(cl isBehavior and: [cl isObsolete]) ifTrue: [obs add: cl]].
	^ obs asArray! !

!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 7/17/2017 15:46:24'!
                 obsoleteMethodReferences
	"
	Smalltalk obsoleteMethodReferences
	Smalltalk browseObsoleteMethodReferences
	Open a browser on all referenced behaviors that are obsolete"
	| obsClasses obsRefs references |
	references _ WriteStream on: Array new.
	obsClasses _ self obsoleteBehaviors.
	'Scanning for methods referencing obsolete classes' displayProgressAt: Sensor mousePoint
		from: 1 to: obsClasses size during: [ :barBlock |
	obsClasses keysAndValuesDo: [ :index :each |
		barBlock value: index.
		obsRefs _ self pointersTo: each except: obsClasses.
		obsRefs do: [ :ref |
			"Figure out if it may be a global"
			(ref isVariableBinding and: [ ref key isString "or Symbol" ]) ifTrue: [
				(self pointersTo: ref) do: [ :meth |
					(meth is: #CompiledMethod) ifTrue: [
						meth methodReference ifNotNil: [ :mref |
							(mref isValid and: [ mref compiledMethod == meth]) ifTrue: [
								references nextPut: mref ]]]]]]].
	].
	^references contents! !

!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 7/17/2017 15:46:30'!
                      testDecompiler
	"
	Smalltalk testDecompiler
	"
	"Decompiles the source for every method in the system, and then compiles that source and verifies that it generates (and decompiles to) identical code.  This currently fails in a number of places because some different patterns (esp involving conditionals where the first branch returns) decompile the same."
	| methodNode oldMethod newMethod badOnes oldCodeString n |
	badOnes _ OrderedCollection new.
	'Decompiling all classes...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: CompiledMethod instanceCount
		during: [ :barBlock |
			n _ 0.
			Smalltalk allBehaviorsDo: [ :cls |
				"Transcript cr; show: cls name."
				cls selectors do: [ :selector |
					(n _ n + 1) \\ 100 = 0 ifTrue: [ barBlock value: n ].
					oldMethod _ cls compiledMethodAt: selector.
					oldCodeString _ (cls decompilerClass new
						decompile: selector
						in: cls
						method: oldMethod) decompileString.
					methodNode _ cls compilerClass new
						compile: oldCodeString
						in: cls
						notifying: nil
						ifFail: nil.
					newMethod _ methodNode generate: #(0 0 0 0 ).
					oldCodeString =
						(cls decompilerClass new
							decompile: selector
							in: cls
							method: newMethod) decompileString ifFalse: [
						Transcript
							 newLine;
							 show: '***' , cls name , ' ' , selector.
						badOnes add: (MethodReference class: cls selector: selector) ]]]].
	Smalltalk
		browseMessageList: badOnes asArray sort
		name: 'Decompiler Discrepancies'.! !

!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 7/17/2017 15:46:37'!
      testFormatter
	"Smalltalk testFormatter"
	"Reformats the source for every method in the system, and then compiles that source and verifies that it generates identical code.
	The formatting used will be classic monochrome."
	| newCodeString methodNode oldMethod newMethod badOnes n |
	badOnes _ OrderedCollection new.
	'Formatting all classes...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: CompiledMethod instanceCount
		during: [ :barBlock |
			n _ 0.
			Smalltalk allBehaviorsDo: [ :cls |
				"Transcript cr; show: cls name."
				cls selectors do: [ :selector |
					(n _ n + 1) \\ 100 = 0 ifTrue: [ barBlock value: n ].
					newCodeString _ cls compilerClass new
						format: (cls sourceCodeAt: selector)
						in: cls
						notifying: nil.
					methodNode _ cls compilerClass new
						compile: newCodeString
						in: cls
						notifying: nil
						ifFail: nil.
					newMethod _ methodNode generate: #(0 0 0 0 ).
					oldMethod _ cls compiledMethodAt: selector.
					oldMethod = newMethod ifFalse: [
						Transcript
							 newLine;
							 show: '***' , cls name , ' ' , selector.
						badOnes add: cls name , ' ' , selector ]]]].
	Smalltalk
		browseMessageList: badOnes asArray sort
		name: 'Formatter Discrepancies'.! !

!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 7/17/2017 15:46:43'!
                       testFormatter2
	"Smalltalk testFormatter2"
	"Reformats the source for every method in the system, and then verifies that the order of source tokens is unchanged.
	The formatting used will be classic monochrome"
	| newCodeString badOnes n oldCodeString oldTokens newTokens |
	badOnes _ OrderedCollection new.
	'Formatting all classes...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: CompiledMethod instanceCount
		during: [ :barBlock |
			n _ 0.
			Smalltalk allBehaviorsDo: [ :cls |
				"Transcript cr; show: cls name."
				cls selectors do: [ :selector |
					(n _ n + 1) \\ 100 = 0 ifTrue: [ barBlock value: n ].
					oldCodeString _ (cls sourceCodeAt: selector) asString.
					newCodeString _ cls compilerClass new
						format: oldCodeString
						in: cls
						notifying: nil.
					oldTokens _ oldCodeString findTokens: Character separators.
					newTokens _ newCodeString findTokens: Character separators.
					oldTokens = newTokens ifFalse: [
						Transcript
							 newLine;
							 show: '***' , cls name , ' ' , selector.
						badOnes add: cls name , ' ' , selector ]]]].
	Smalltalk
		browseMessageList: badOnes asArray sort
		name: 'Formatter Discrepancies'.! !

!SystemDictionary methodsFor: 'memory space' stamp: 'jmv 12/17/2016 22:37:27'!
               lowSpaceThreshold 
	"Answer the low space threshold. When the amount of free memory (after garbage collection)
	 falls below this limit, the system is in serious danger of completely exhausting memory and
	 crashing. This limit should be made high enough to allow the user open a debugger to diagnose
	 a problem or to save the image.  In a stack-based VM such as Cog contexts for activations in
	 the stack zone will have to be created as the debugger opens, requiring additional headroom."

	| slotsForDebugger slotsForContextsOnStackPages |
	slotsForDebugger := 65536. "Arbitrary guess"
	slotsForContextsOnStackPages :=
		(self vmParameterAt: 42)
			ifNil: [0]
			ifNotNil:
				[:numStackPages| | headerSize numActivationsPerPage maxContextSize |
				numActivationsPerPage := 40. "Design goal of the Cog VM"
				headerSize := 2. "64-bytes for Spur"
				maxContextSize := MethodContext instSize + CompiledMethod fullFrameSize + headerSize.
				numStackPages * numActivationsPerPage * maxContextSize].
	^slotsForDebugger + slotsForContextsOnStackPages * self wordSize! !

!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 1/14/2017 08:52:09'!
 knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 					'Colin Putney')
	#('acg' 					'Andrew C. Greenberg')
	#('ads' 					'Adam Spitz')
	#('AFi' 					'Alain Fischer')
	#('ajh' 					'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('aoy' 					'Andres Otaduy')
	#('apb' 					'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 					'Alejandro Magistrello')
	#('avi' 					'Avi Bryant')
	#('BenComan' 			'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 					'Boris Gaertner')
	#('BJP' 					'Bijan Parsia')
	#('bkv' 					'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 					'Brent Pinkney')
	#('cbc' 					'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 					'Chris Norton')
	#('cmm' 					'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 					'Colin Putney')
	#('das' 					'David A Smith')
	#('dc' 						'Damien Cassou')
	#('dew' 					'Doug Way')
	#('dgd' 					'Diego Gomez Deck')
	#('dkh'					'Dale Henrichs')
	#('dhn'	 				'Dan Norton')
	#('dhhi' 					'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 					'David J. Pennell')
	#('DKL'					'Daniel K Lyons ')
	#('DM' 					'Duncan Mak')
	#('DSM' 					'Duane Maxwell')
	#('DSG'					'David Graham')
	#('dtl' 						'Dave Lewis')
	#('dvf' 					'Daniel Vainsencher')
	#('eat' 					'Eric Arseneau Tremblay')
	#('eem'					'Eliot Emilio Miranda')
	#('eliot'					'Eliot Emilio Miranda')
	#('efc' 					'Eddie Cottongim')
	#('em' 					'Ernest Micklei?')
	#('emm' 					'Ernest Micklei')
	#('fbs' 					'Frank Shearar')
	#('FBS' 					'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 					'Frank Sergeant')
	#('FernandoOlivero' 		'Fernando Olivero')
	#('FernanodOlivero' 		'Fernando Olivero')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('gera' 					'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 					'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 					'German Arduino')
	#('HAW' 					'Hernan Wilkinson')
	#('HB' 					'Hari Balaraman')
	#('hjh' 					'Hannes Hirzel')
	#('hmm' 					'Hans-Martin Mosner')
	#('hsj' 					'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 					'Ian Piumarta')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 					'Joshua Gargus')
	#('jdr' 					'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jhm' 					'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' '					John Maloney')
	#('jmb' 					'Hans Baveco')
	#('JMG'					'Jeff Gonis')
	#('JMM' 					'John McIntosh')
	#('jmv' 					'Juan Vuletich')
	#('JMV' 					'Juan Vuletich')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 					'John-Reed Maffeo')
	#('jrp' 					'John Pierce')
	#('jsp' 					'Jeff Pierce')
	#('KenD' 					'Ken Dickey')
	#('kfr' 					'Karl Ramberg')
	#('KLC'			 		'Ken Causey')
	#('kph'					'Keith Hodges')
	#('KTT' 					'Kurt Thams')
	#('laza' 					'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('len' 					'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 					'Marcus Denker')
	#('MarcusDenker' 		'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 					'Mike Rutenberg')
	#('mga' 					'Markus Galli')
	#('mha' 					'Michael Haupt')
	#('mir' 					'Michael Rueger')
	#('mjg' 					'Mark Guzdial')
	#('mk' 					'Matej Kosik')
	#('MPH' 					'Michael Hewner')
	#('mpw' 					'Marcel Weiher')
	#('MPW' 					'Marcel Weiher')
	#('mrm' 					'Martin McClure')
	#('mtf' 					'Matthew Fulmer')
	#('mu' 					'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'				 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('nop' 					'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('panda' 					'Michael Rueger')
	#('pb'						'Phil Bellalouna')
	#('PHK' 					'Peter Keeler')
	#('Pmm' 					'Philippe Marschall')
	#('pnm' 					'Paul McDonough')
	#('r++' 					'Gerardo Richarte')
	#('raa' 					'Bob Arning')
	#('RAA' 					'Bob Arning')
	#('raok' 					'Richard A. O''Keefe')
	#('rca' 					'Russell Allen')
	#('reThink'			 	'Paul McDonough')
	#('rew' 					'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 					'Ron Teitelbaum')
	#('rr' 						'Romain Robbes')
	#('rss' 					'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 					'Robert Withers')
	#('Sames' 				'Samuel S. Shuster')
	#('sbw' 					'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 					'Stephane Ducasse')
	#('sge' 					'Steve Elkins')
	#('sma' 					'Stefan Matthias Aust')
	#('sps' 					'Steven Swerling')
	#('SqR' 					'Andres Valloud')
	#('sqr' 					'Andres Valloud')
	#('sr' 						'Stephan Rudlof')
	#('SSS' 					'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse' 	'Stephane Ducasse')
	#('stp' 					'Stephen Travis Pope')
	#('sumim' 				'Masato Sumi')
	#('svp' 					'Stephen Vincent Pair')
	#('sw' 					'Scott Wallace')
	#('TAG' 					'Travis Griggs')
	#('tak' 					'Takashi Yamamiya')
	#('tao' 					'Tim Olson')
	#('TBn' 					'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 					'Tim Rowledge')
	#('TPR' 					'Tim Rowledge')
	#('tween' 				'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('ward' 					'Ward Cunningham')
	#('wiz' 					'Jerome Peace')
	#('wod' 					'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

!SystemDictionary methodsFor: 'retrieving' stamp: 'len 11/26/2016 09:03:25'!
                   allCallsOn: aLiteral   "Smalltalk browseAllCallsOn: #open:label:."
	"Answer a Collection of all the methods that call on aLiteral."
	| aCollection special aList byte |

	#(23 48 'fred' (new open:label:)) size.
"Example above should find #open:label:, though it is deeply embedded here."

	aCollection _ OrderedCollection new.
	special _ self hasSpecialSelector: aLiteral ifTrueSetByte: [:b | byte _ b ].
	self allBehaviorsDo: [:class |
		aList _ class whichSelectorsReferTo: aLiteral special: special byte: byte.
		aList do: [ :sel |
			"For special selectors, look for the literal in the source code.
			Otherwise, for example, searching for senders of #== will include senders of #ifNil.
			Except for #at:put:, because it has two arguments and won't find it in the source code like that."
			(byte isNil or: [aLiteral = #at:put: or: [
				((class sourceCodeAt: sel)
					findString: aLiteral) > 0]]) ifTrue: [

				aCollection add: (
					MethodReference new
						setStandardClass: class 
						methodSymbol: sel
				)
			]
		]
	].
	^ aCollection! !

!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 7/17/2017 15:45:58'!
                     allMethodsSourceStringMatching: aString
	"Answer a sorted Collection of all the methods that contain, in source code, aString as a substring. 
	Search the class comments also.
	Argument might include $*, that matches any subsequence.
	For example, try:
		ensure:*[*close*]
	"
	| list classCount adder |
	list _ Set new.
	adder _ [ :mrClass :mrSel |
	list add:
		(MethodReference new
			setStandardClass: mrClass
			methodSymbol: mrSel) ].
	'Searching all source code...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: Smalltalk classNames size
		during: [ :barBlock |
			classCount _ 0.
			Smalltalk allClassesDo: [ :class |
				barBlock value: (classCount _ classCount + 1).
				(Array
					with: class
					with: class class) do: [ :cl |
					cl selectorsDo: [ :sel |
						(aString match: (cl sourceCodeAt: sel)) ifTrue: [
							adder
								value: cl
								value: sel ]].
					
					(aString match: cl organization classComment asString) ifTrue: [
						adder
							value: cl
							value: #Comment ]]]].
	^ list asArray sort.! !

!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 7/17/2017 15:46:02'!
                            allMethodsWithSourceString: aString matchCase: caseSensitive
	"Answer a sorted Collection of all the methods that contain, in source code, aString as a substring.  Search the class comments also"
	| list classCount adder |
	list _ Set new.
	adder _ [ :mrClass :mrSel |
	list add:
		(MethodReference new
			setStandardClass: mrClass
			methodSymbol: mrSel) ].
	'Searching all source code...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: Smalltalk classNames size
		during: [ :barBlock |
			classCount _ 0.
			Smalltalk allClassesDo: [ :class |
				barBlock value: (classCount _ classCount + 1).
				(Array
					with: class
					with: class class) do: [ :cl |
					cl selectorsDo: [ :sel |
						((cl sourceCodeAt: sel)
							findString: aString
							startingAt: 1
							caseSensitive: caseSensitive) > 0 ifTrue: [
							adder
								value: cl
								value: sel ]].
					(cl organization classComment asString
						findString: aString
						startingAt: 1
						caseSensitive: caseSensitive) > 0 ifTrue: [
						adder
							value: cl
							value: #Comment ]]]].
	^ list asArray sort.! !

!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 7/17/2017 15:45:48'!
    abandonSources
	"
	Smalltalk abandonSources
	"
	 | m bTotal bCount |
	(self confirm:
'This method will detach the image fom source code.
A fresh changes file will be created to record further changes.
-- CAUTION --
If you have backed up your system and
are prepared to face the consequences of
abandoning source code files, choose Yes.
If you have any doubts, you may choose No
to back out with no harm done.')
		==  true ifFalse: [^ self inform: 'Okay - no harm done'].
	bTotal _ 0.  bCount _ 0.
	Smalltalk allBehaviorsDo: [: b | bTotal _ bTotal + 1].
'Doing #destroySourcePointer ...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: bTotal
	during: [ :barBlock |
		Smalltalk allBehaviorsDo: [ :cl |
		"for testing"
		"{ EllipseMorph } do: [ :cl |"
			barBlock value: (bCount _ bCount + 1).
			cl selectors do: [:selector |
				m _ cl compiledMethodAt: selector.
				m destroySourcePointer ]]].
	Smalltalk allBehaviorsDo: [:b | b zapOrganization].
	Smalltalk closeSourceFiles.
	Preferences disable: #warnIfNoChangesFile.
	Preferences disable: #warnIfNoSourcesFile! !

!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 4/25/2016 15:31'!
        reduceCuis
	"
	Smalltalk reduceCuis
	"
	| keep n unused newDicts oldDicts |

	self nominallyUnsent: #reduceCuis.
	
	"Remove icons"
	Smalltalk at: #ClassicTheme ifPresent: [ :cls | cls beCurrent ].
	PasteUpMorph allInstancesDo: [ :w |
		w backgroundImageData: nil.
		w  submorphsDo: [ :a | a delete ]].
	Preferences useNoIcons.
	Theme current initialize.
	Theme content: nil.
	Color shutDown.
	BitBltCanvas releaseClassCachedState.

	Transcript clear.
	Clipboard default initialize.


	"Remove some methods, even if they have senders."
"	ColorPickerMorph class removeSelector: #buildEyedropperIcon."
	Theme removeSelector: #miscellaneousIcons.
	Utilities removeSelector: #vmStatisticsReportString.
	SystemDictionary removeSelector: #recreateSpecialObjectsArray.

	StrikeFont removeMostFonts.
	StrikeFont saveSpace.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.

	keep := OrderedCollection new.
	keep addAll: #(SpaceTally).
	AppLauncher appGlobalName ifNotNil: [ :any |
		keep add: any ].
	unused := Smalltalk unusedClasses copyWithoutAll: keep.
	[
		#hereWeGo print.
		unused do: [:c | 
			c print.
			(Smalltalk at: c) removeFromSystem]. 
		n := Smalltalk removeAllUnSentMessages.
		unused := Smalltalk unusedClasses copyWithoutAll: keep.
		n > 0 or: [ 
			unused notEmpty ]] whileTrue.
	ChangeSet zapAllChangeSets.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.
	Symbol rehash.

	"Shrink method dictionaries."
	Smalltalk garbageCollect.
	oldDicts _ MethodDictionary allInstances.
	newDicts _ Array new: oldDicts size.
	oldDicts withIndexDo: [:d :index | 
		newDicts at: index put: d rehashWithoutBecome ].
	oldDicts elementsExchangeIdentityWith: newDicts.
	oldDicts _ newDicts _ nil.

	 SmalltalkCompleter initialize .

   "Sanity checks"
"   Undeclared
   Smalltalk cleanOutUndeclared
   Smalltalk browseUndeclaredReferences
   Smalltalk obsoleteClasses
   Smalltalk obsoleteBehaviors 
   Smalltalk browseObsoleteMethodReferences
   SmalltalkImage current fixObsoleteReferences
   Smalltalk browseAllUnimplementedCalls"! !

!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 7/17/2017 15:42:02'!
removeAllUnSentMessages
	"Smalltalk removeAllUnSentMessages"
	"[Smalltalk unusedClasses do: [:c | (Smalltalk at: c) removeFromSystem]. 
	Smalltalk removeAllUnSentMessages > 0] whileTrue."
	"Remove all implementations of unsent messages."
	| sels n |
	sels _ self allUnSentMessages.
	self presumedSentMessages
		do: [:sel | sels
				remove: sel
				ifAbsent: nil].
	sels size = 0
		ifTrue: [^ 0].
	n _ 0.
	Smalltalk
		allBehaviorsDo: [:x | n _ n + 1].
	'Removing ' , sels size printString , ' messages . . .'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: n
		during: [:barBlock | 
			n _ 0.
			self
				allBehaviorsDo: [:class | 
					barBlock value: (n _ n + 1).
					sels
						do: [:sel | class removeSelector: sel]]].
	^ sels size! !

!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 9/4/2017 08:48:40'!
   logSnapshot: save andQuit: quit
	"Log quitting to changes file"
	| msg |
	(SourceFiles at: 2) ifNotNil: [
		msg _ self snapshotMessageFor: save andQuit: quit.
		self assureStartupStampLogged.
		save ifTrue: [
			LastQuitLogPosition _ (SourceFiles at: 2)
				 setToEnd;
				 position ].
		self logChange: msg.
		Transcript
			 newLine;
			 show: msg;
			 newLine ]! !

!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 9/4/2017 08:42:57'!
                              nopTag

	^ 'NOP'! !

!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/6/2017 09:53:30'!
                         processStartUpList: isARealStartup
	"Send #startUp to each class that needs to run initialization after a snapshot."

	EndianCache _ self calcEndianness.
	self send: #startUp: toClassesNamedIn: StartUpList with: isARealStartup! !

!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 9/4/2017 08:42:27'!
       quitNoSaveTag

	^ 'QUIT/NOSAVE' ! !

!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 9/4/2017 08:40:45'!
         quitTag
		
	^'QUIT'! !

!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 5/25/2017 21:56:04'!
                     saveAsNewVersion
	"Save the image/changes using the next available version number."
	"
	Smalltalk saveAsNewVersion
	"
	| fileName newName changesName systemVersion |
	self okayToSave ifFalse: [ ^ self ].
	systemVersion _ SystemVersion current.
	fileName _ String streamContents: [ :strm |
		strm
			nextPutAll: 'Cuis';
			print: systemVersion versionMajor;
			nextPut: $.;
			print: systemVersion versionMinor;
			nextPut: $-;
			print: systemVersion highestUpdate.
		Smalltalk isSpur
			ifTrue: [	
				Smalltalk wordSize = 4 ifTrue: [
					strm nextPutAll: '-32' ]]
			ifFalse: [
				strm nextPutAll: '-v3' ]].
	newName _ fileName, '.image'.
	(DirectoryEntry smalltalkImageDirectory // newName) exists ifTrue: [
		newName _ DirectoryEntry smalltalkImageDirectory
			nextNameFor: fileName
			extension: 'image' ].
	changesName _ self fullNameForChangesNamed: newName.
	"Check to see if there is a .changes file that would cause a problem if we saved a new .image file with the new version number"
	changesName asFileEntry exists ifTrue: [
		^ self inform:
'There is already .changes file of the desired name,
', newName, '
curiously already present, even though there is
no corresponding .image file.   Please remedy
manually and then repeat your request.' ].
	"Try to clear all user state, including all class vars, preferences, etc"
	self saveAs: newName andQuit: false clearAllClassState: true! !

!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/6/2017 09:55:41'!
                     send: startUpOrShutDown toClassesNamedIn: startUpOrShutDownList with: argument
	"Send the message #startUp: or #shutDown: to each class named in the list.
	The argument indicates if the system is about to quit (for #shutDown:) or if
	the image is ia real startup (or just continue after image save) (for #startUp:).
	If any name cannot be found, then remove it from the list."

	| removals class |
	removals _ OrderedCollection new.
	startUpOrShutDownList do:
		[:name |
		class _ self at: name ifAbsent: nil.
		class
			ifNil: [removals add: name]
			ifNotNil: [
				class isInMemory ifTrue: [
					class perform: startUpOrShutDown with: argument]]].

	"Remove any obsolete entries, but after the iteration"
	"Well, not. Better just ignore them. Maybe it is stuff, like SoundPlayer, that was moved to optional packages, and can be loaded again anytime."
	"startUpOrShutDownList removeAll: removals"! !

!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 9/4/2017 08:46:37'!
      snapshot: save andQuit: quit embedded: embeddedFlag clearAllClassState: clearAllStateFlag
"WARNING: Current process will be killed.
UI Process will be restarted
"
	"Mark the changes file and close all files as part of #processShutdownList.
	If save is true, save the current state of this Smalltalk in the image file.
	If quit is true, then exit to the outer OS shell.
	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."
	"
	To test the full cleanup and startup procedures, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: true

	To test the cleanup done when saving the image, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: false
	"
| activeProc |
activeProc _ Processor activeProcess.
[ 
	| isARealStartup world reopenTranscript |
	self logSnapshot: save andQuit: quit.

	reopenTranscript _ false.
	clearAllStateFlag ifTrue: [
		TranscriptWindow allInstancesDo: [ :each | each isInWorld ifTrue: [ each delete. reopenTranscript _ true ]].
		Transcript logToFile: false ].
	ActiveModel flushEventSystem.
	self processShutDownList: quit.


	"Lo que sigue aca podria ir al shutdown de alguien... (se levantan en startup!!)"
	Smalltalk stopLowSpaceWatcher.
	WeakArray stopFinalizationProcess.
	ProcessorScheduler stopBackgroundProcess.
	
	"Cosas que levanto explicitamente abajo"
	world _ ProjectX ui.
	"Replace with this to create a new world at startup after 'saveAsNewVersion'"
	"world _ clearAllStateFlag ifFalse: [ ProjectX ui ]."
	ProjectX stopUIProcess.
	activeProc isTerminated ifFalse: [
		activeProc terminate ].

	"Clean Globals"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: nil.
	Smalltalk closeSourceFiles. Smalltalk at: #SourceFiles put: nil.
	Smalltalk allClassesDo: [ :cls | cls releaseClassCachedState ].
	clearAllStateFlag ifTrue: [	
		Smalltalk allClassesDo: [ :cls | cls releaseClassState ]].
	"Ojo con los pool dicts. Creo que no hay ninguno..."
	
	"To keep cleaning stuff that shouldn't be saved..."
	clearAllStateFlag ifTrue: [ Smalltalk printStuffToCleanOnImageSave ].


	"Do image save & quit as apropriate"
	Cursor write activateCursor.
	save
		ifTrue: [
			isARealStartup _ embeddedFlag
				ifTrue: [ self snapshotEmbeddedPrimitive ]
				ifFalse: [ self snapshotPrimitive ]]
		ifFalse: [ isARealStartup _ false ].
	quit & (isARealStartup == false) ifTrue: [ self quitPrimitive ].


	"If starting from absolute scratch, this would be a good time to recreate Global names"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: (DisplayScreen extent: `1024@768` depth: 32).
	Smalltalk at: #SourceFiles put: (Array new: 2).
	Smalltalk openSourceFiles.

	"Here, startup begins!! (isARealStartup might be nil)"
	Smalltalk allClassesDo: [ :cls | cls initClassCachedState ].
	self doStartUp: isARealStartup == true.
	
	
	ProjectX spawnNewMorphicProcessFor: (world ifNil: [ PasteUpMorph newWorld ]).

	reopenTranscript ifTrue: [
		WorldState addDeferredUIMessage: [
			TranscriptWindow openTranscript ]].
	"
	WorldState addDeferredUIMessage: [
		world fullRepaintNeeded ].
	"

	"If system is coming up (VM and image just started)"
	isARealStartup == true ifTrue: [	
		WorldState addDeferredUIMessage: [
			self processCommandLineArguments.
			AppLauncher launchApp ]].

	"Now it's time to raise an error"
	isARealStartup ifNil: [ self error: 'Failed to write image file (disk full?)' ].

] forkAt: Processor timingPriority-1 named: 'Startup process'.! !

!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 9/4/2017 08:51:51'!
                     snapshotMessageFor: save andQuit: quit
		
	^String streamContents: [ :stream |
		stream 
			nextPutAll: self tagHeader;
			nextPutAll: (self snapshotTagFor: save andQuit: quit);
			nextPutAll: self tagTail;
			print: Date dateAndTimeNow;
			space;
			nextPutAll: self imageName asFileEntry name;
			nextPutAll: ' priorSource: ';
			print: LastQuitLogPosition ].! !

!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 9/4/2017 08:41:19'!
snapshotTag
		
	^'SNAPSHOT'! !

!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 9/4/2017 08:51:20'!
              snapshotTagFor: save andQuit: quit
		
	^save
		ifTrue: [ quit
			ifTrue: [ self quitTag ]
			ifFalse: [ self snapshotTag ]]
		ifFalse: [ quit
			ifTrue: [ self quitNoSaveTag ]
			ifFalse: [ self nopTag ]]! !

!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 9/4/2017 08:45:54'!
                             tagHeader

	^ '----'! !

!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 9/4/2017 08:46:02'!
                     tagTail

	^ self tagHeader! !

!SystemDictionary methodsFor: 'browsing' stamp: 'HAW 2/4/2017 20:49:09'!
                        browseAllCallsOnClass: aClass
	"Create and schedule a message browser on each method that refers to 
	aClass. For example, Smalltalk browseAllCallsOnClass: Object."
	self
		browseMessageList: aClass allCallsOn asArray sort
		name: 'Users of class ' , aClass theNonMetaClass name
		autoSelect: aClass theNonMetaClass name.! !

!SystemDictionary methodsFor: 'browsing' stamp: 'len 6/9/2016 23:23'!
                    browseAllPrimitives
	self browseAllSelect: [:each| each primitive ~= 0 and: [(each primitive between: 256 and: 291) not]]
! !

!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 5/24/2017 00:29:09'!
                       browseClassesWithNamesContaining: aString caseSensitive: caseSensitive 
	"Smalltalk browseClassesWithNamesContaining: 'eMorph' caseSensitive: true "
	"Launch a class-list list browser on all classes whose names containg aString as a substring."

	| suffix aList |
	suffix _ caseSensitive
				ifTrue: [' (case-sensitive)']
				ifFalse: [' (use shift for case-sensitive)'].
	aList _ OrderedCollection new.
	Smalltalk allClassesDo: [ :class |
		(class name includesSubstring: aString caseSensitive: caseSensitive)
			ifTrue: [aList add: class name]].
	aList size > 0
		ifTrue: [HierarchyBrowserWindow forClassesNamed: aList asSet sorted title: 'Classes whose names contain ' , aString , suffix]! !

!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 12/16/2016 15:05:52'!
                             browseMyChanges
	"Browse only the changes (in the changes file) by the current author.
	Smalltalk browseMyChanges
	"
	self browseAllSelect: [ :method |
       method fileIndex > 1 "only look at changes file"
               and: [ method timeStamp beginsWith: Utilities authorInitials, ' ' ]]! !

!SystemDictionary methodsFor: 'system attributes' stamp: 'jmv 5/14/2017 23:20:19'!
     isRunningCogit
	"Returns true if we're running on the Cog JIT
	 (vmParameterAt: 46 is the size of the machine code zone)
	Smalltalk isRunningCogit
	"

	^(self vmParameterAt: 46)
		ifNotNil: [ :machineCodeZoneSize  | machineCodeZoneSize > 0 ]
		ifNil: [ false ]! !

!SystemDictionary methodsFor: 'system attributes' stamp: 'jmv 5/14/2017 23:20:40'!
    isSpur
	"Answer true if we are a Spur ObjectMemory.
	Spur introduces a new format of header for objects, new format for classes, etc.
	Smalltalk isSpur
	"

	^ self compactClassesArray isNil! !

!SystemDictionary methodsFor: 'startup' stamp: 'HAW 9/4/2017 06:14:44'!
                      doStartUp: isARealStartup
	"
	isARealStartup
		true: system is coming up (VM and image just started)
		false: we have just saved an image snapshot, but didn't quit.
	"

	"Here, startup begins!!"
	Cursor normal activateCursor.
	self setGCParameters.
	isARealStartup ifTrue: [
		self clearExternalObjects ].
	self readCommandLineArguments.
	self processStartUpList: isARealStartup.
	isARealStartup ifTrue: [
		self setPlatformPreferences.
		self setStartupStamp.
		self restoreLostChangesIfNecessary ]! !

!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/9/2017 12:09:32'!
         hasToRestoreChanges

	^Preferences checkLostChangesOnStartUp and: [ 
		self withChangesFileDo: [ :changesFile | self hasToRestoreChangesFrom: changesFile ]].
	! !

!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/9/2017 12:09:46'!
                             hasToRestoreChangesFrom: changesFile

	| chunk  |
	
	changesFile position: self lastQuitLogPosition.
	[ changesFile atEnd ] whileFalse: [ chunk := changesFile nextChunk ].
	
	^(self isSnapshotQuitOrQuitNoSaveRecord: chunk) not
! !

!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 08:56:02'!
                         isQuitNoSaveRecord: chunk

	^chunk beginsWith: self tagHeader, self quitNoSaveTag
	! !

!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 08:55:51'!
         isQuitRecord: chunk

	^chunk beginsWith: self tagHeader, self quitTag ! !

!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 16:34:34'!
                      isSnapshotQuitOrQuitNoSaveRecord: chunk

	^(self isSnapshotRecord: chunk) 
		or: [ (self isQuitRecord: chunk) 
		or: [ self isQuitNoSaveRecord: chunk ]]! !

!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 08:57:09'!
    isSnapshotRecord: chunk

	^chunk beginsWith: self tagHeader, self snapshotTag 
	! !

!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 09:07:35'!
            lostChangesDetectedCaption
	
	^
'Last changes may have been lost
(maybe the VM crashed or you had to kill it)
What do you want to do?'! !

!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 06:25:45'!
                      restoreLostChanges

 	| decision |
	
	decision := PopUpMenu withCaption: self lostChangesDetectedCaption chooseFrom: self restoreLostChangesOptions.

	decision = 1 ifTrue: [ ^self restoreLostChangesAutomatically ].
	decision = 2 ifTrue: [ ^self restoreLostChangesManually ]! !

!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 06:13:01'!
           restoreLostChangesAutomatically
	
	self withChangesFileDo: [ :aChangesFile | self restoreLostChangesAutomaticallyFrom: aChangesFile ]! !

!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 10:15:16'!
                       restoreLostChangesAutomaticallyFrom: aChangesFile

	| changeList |

	changeList := ChangeListWithFileInErrors new.
	changeList scanFile: aChangesFile from: LastQuitLogPosition to: aChangesFile size.
	changeList fileInAllKeepingErrors.
	(changeList hasFileInErrors and: [ self shouldShowFileInErrors ]) ifTrue: [ changeList showChangesWithFileInErrors ]
! !

!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 06:09:39'!
                           restoreLostChangesIfNecessary

	"
	Smalltalk restoreLostChangesIfNecessary
	"
	
	self hasToRestoreChanges ifTrue: [ WorldState addDeferredUIMessage: [self restoreLostChanges ]].
! !

!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/6/2017 19:59:40'!
          restoreLostChangesManually

	ChangeList browseFrom: LastQuitLogPosition on: self currentChangesName labeled: 'Lost changes'
! !

!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 06:25:55'!
restoreLostChangesOptions
	
	^{'Restore lost changes automatically'. 'Restore lost changes manually'. 'Nothing'}.! !

!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 06:29:46'!
           restoringChangesHasErrorsCaption
	
	^'There were errors filing in the lost changes. Do you want to see them?'! !

!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 09:37:34'!
               shouldShowFileInErrors
	
 	^self confirm: self restoringChangesHasErrorsCaption
	! !

!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 06:11:39'!
           withChangesFileDo: aBlock

	^self currentChangesName asFileEntry readStreamDo: aBlock! !

!SystemDictionary methodsFor: 'image' stamp: 'jmv 12/19/2016 13:04:12'!
                              wordSize
	"Answer the size in bytes of an object pointer or word in the object memory.
	The value does not change for a given image, but may be modified by a SystemTracer
	when converting the image to another format. The value is cached in WordSize to
	avoid the performance overhead of repeatedly consulting the VM."

	"Smalltalk wordSize"

	^ WordSize ifNil: [
		SmallInteger initMinValAndMaxVal.
		WordSize := [self vmParameterAt: 40] on: Error do: [4]]! !


SystemDictionary class
	instanceVariableNames: ''!

!SystemDictionary class methodsFor: 'copyright' stamp: 'jmv 5/14/2017 23:13:07'!
             copyright
	"The Cuis Smalltalk copyright.
	Parts are copyright of many contributors to Squeak and Cuis projects."

	^
'Portions of Cuis are:
Copyright (c) Xerox Corp. 1981, 1982.
Copyright (c) Apple Computer, Inc. 1985-1996.
Copyright (c) Contributors to Squeak and Cuis projects. 1997-2017.'! !


PluggableMorph subclass: #SystemWindow
	instanceVariableNames: 'labelString layoutMorph adjusters'
	classVariableNames: 'TopWindow'
	poolDictionaries: ''
	category: 'Morphic-Views'!

!SystemWindow methodsFor: 'change reporting' stamp: 'jmv 6/19/2017 15:58:02'!
                 invalidateTitleArea

	"not really pretty... also invalidating the top border, regardless of it being above or below the title area
	(Different themes use various looks, this covers them all)"
	self invalidateLocalRect: (`0@0` extent: extent x @ (self labelHeight + borderWidth))! !

!SystemWindow methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:57:54'!
drawClassicFrameOn: aCanvas color: titleColor
	"Window border encompasses title area. No round corners. No title gradient."

	aCanvas fillRectangle: (`0@0` extent: extent) color: color borderWidth: borderWidth borderStyleSymbol: #simple baseColorForBorder: self widgetsColor.

	"A border was drawn at the left, top and right of the title area.
	The look is that the title area is inside the window"
	aCanvas fillRectangle: (borderWidth@borderWidth extent: extent x - (2*borderWidth)@ self labelHeight) color: titleColor! !

!SystemWindow methodsFor: 'drawing' stamp: 'jmv 1/22/2017 21:25:10'!
               drawOn: aCanvas

	| titleColor roundCorners |

	titleColor _ self widgetsColor.
	self isTopWindow
		ifTrue: [ titleColor _ titleColor lighter ].

	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			"Round corners. Optional title gradient."
			self drawRoundedFrameOn: aCanvas color: titleColor ]
		ifFalse: [
			"No round corners. No title gradient."
			self drawClassicFrameOn: aCanvas color: titleColor ].
	Theme current minimalWindows
		ifFalse: [
			labelString ifNotNil: [self drawLabelOn: aCanvas]]! !

!SystemWindow methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:57:58'!
   drawRoundedFrameOn: aCanvas color: widgetsColor
	"Title area is not inside window borders"
	| bottomFactor topFactor |
	Theme current useWindowTitleGradient
		ifTrue: [
			topFactor _ Theme current titleGradientTopFactor.
			bottomFactor _ Theme current titleGradientBottomFactor ]
		ifFalse: [
			topFactor _ 1.
			bottomFactor _ 1 ].
	aCanvas
		windowFrame: (`0@0` extent: extent)
		color: widgetsColor * Theme current titleGradientExtraLightness
		radius: Theme current roundedWindowRadius
		border: borderWidth
		labelHeight: self labelHeight + borderWidth
		gradientTop: topFactor
		gradientBottom: bottomFactor
		insideColor: color! !

!SystemWindow methodsFor: 'drawing' stamp: 'jmv 6/19/2017 16:37:43'!
                         makeMeFullyVisible 

	self world morphExtent > `0@0` ifFalse: [^ self].

	(self morphPosition >= `0@0` and: [ self morphPosition < (self world morphExtent-self morphExtent)]) ifTrue: [
		^ self "OK -- visible"].

	self morphPosition: (RealEstateAgent initialFrameFor: self initialExtent: self morphExtentInWorld world: self world) topLeft! !

!SystemWindow methodsFor: 'drawing' stamp: 'jmv 6/19/2017 16:37:53'!
    makeMeVisible 

	self world morphExtent > `0@0` ifFalse: [^ self].

	(self morphPosition >= `0@0` and: [ self morphPosition < (self world morphExtent-self labelHeight)]) ifTrue: [
		^ self "OK -- at least my top left is visible"].

	"window not on screen (probably due to reframe) -- move it now"
	self morphPosition: (RealEstateAgent initialFrameFor: self initialExtent: extent world: self world) topLeft! !

!SystemWindow methodsFor: 'geometry' stamp: 'jmv 6/19/2017 16:12:56'!
minimumExtent

	^`160@80`! !

!SystemWindow methodsFor: 'geometry' stamp: 'jmv 6/19/2017 16:13:07'!
                            rescaleButtons
	"boxExtent changed.  Update my buttons."
	| buttonExtent buttonPos buttonDelta |
	buttonExtent := self boxExtent.
	buttonPos := `2@2`.
	buttonDelta := self boxExtent x + 2.
	self submorphsReverseDo: [ :aMorph |
		(aMorph is: #PluggableButtonMorph) 
		  ifTrue: [ 
				aMorph morphExtent: buttonExtent. 
				aMorph morphPosition: buttonPos.
				buttonPos := (buttonPos x  + buttonDelta) @ 2.
		].
	].
! !

!SystemWindow methodsFor: 'initialization' stamp: 'jmv 6/19/2017 15:57:49'!
               boxExtent
	"answer the extent to use in all the buttons. 
	 
	the label height is used to be proportional to the fonts preferences"
	| e |
	Theme current minimalWindows ifTrue: [^`0@0`].
	e _ Preferences windowTitleFont height.
	^e@e! !

!SystemWindow methodsFor: 'initialization' stamp: 'cbr 11/7/2010 18:58'!
         defaultColor
	"answer the default color/fill style for the receiver"
	^ Color white! !

!SystemWindow methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:12:42'!
                            initialize
	"Initialize a system window. Add label, stripes, etc., if desired"

	super initialize.
	labelString ifNil: [ labelString _ 'Untitled Window'].
	
	self initializeLabelArea.
	extent _ `300 @ 200`.

	adjusters _ Dictionary new.
	adjusters at: #topAdjuster put: WindowEdgeAdjustingMorph forTop.
	adjusters at: #bottomAdjuster put: WindowEdgeAdjustingMorph forBottom.
	adjusters at: #leftAdjuster put: WindowEdgeAdjustingMorph forLeft.
	adjusters at: #rightAdjuster put: WindowEdgeAdjustingMorph forRight.
	adjusters at: #topLeftAdjuster put: WindowEdgeAdjustingMorph forTopLeft.
	adjusters at: #bottomLeftAdjuster put: WindowEdgeAdjustingMorph forBottomLeft.
	adjusters at: #topRightAdjuster put: WindowEdgeAdjustingMorph forTopRight.
	adjusters at: #bottomRightAdjuster put: WindowEdgeAdjustingMorph forBottomRight.
	adjusters do: [ :m |
		self addMorphFront: m ].

	"by default"
	self beColumn! !

!SystemWindow methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:12:52'!
        initializeLabelArea
	"Initialize the label area (titlebar) for the window."

	| spacing |
	spacing _ self boxExtent x + 2.
	self addMorph: self createCloseBox position: `2@2`.
	self addMorph: self createCollapseBox position: spacing+2@2.
	self addMorph: self createExpandBox position: spacing*2+2@2.
	self addMorph: self createMenuBox position: spacing*3+2@2! !

!SystemWindow methodsFor: 'layout' stamp: 'jmv 6/19/2017 15:58:05'!
                 layoutSubmorphs
	"Compute a new layout of submorphs based on the given layout bounds."

	| h thickness w cornerExtent wh ww pos |
	thickness _ 4.
	cornerExtent _ 20.
	ww _ extent x.
	wh _ extent y.
	w _ ww - cornerExtent - cornerExtent.
	h _ wh - cornerExtent - cornerExtent.
	(adjusters at: #topAdjuster) morphPosition: cornerExtent@0 extent: w@thickness.
	(adjusters at: #bottomAdjuster) morphPosition: cornerExtent@(wh-thickness) extent: w@thickness.
	(adjusters at: #leftAdjuster) morphPosition: 0@cornerExtent extent: thickness@h.
	(adjusters at: #rightAdjuster) morphPosition: ww-thickness@cornerExtent extent: thickness@h.
	(adjusters at: #topLeftAdjuster) morphPosition: `0@0` extent: cornerExtent@cornerExtent.
	(adjusters at: #bottomLeftAdjuster) morphPosition: 0@(wh-cornerExtent) extent: cornerExtent@cornerExtent.
	(adjusters at: #topRightAdjuster) morphPosition: ww-cornerExtent@0 extent: cornerExtent@cornerExtent.
	(adjusters at: #bottomRightAdjuster) morphPosition: ww@wh-cornerExtent extent: cornerExtent@cornerExtent.

	layoutMorph ifNotNil: [
		pos _ borderWidth @ (borderWidth + self labelHeight).
		layoutMorph
			morphPosition: pos
			extent: extent - pos - borderWidth ].
	
	layoutNeeded _ false! !

!SystemWindow methodsFor: 'menu' stamp: 'bp 10/11/2015 21:42'!
                         buildWindowMenu

	| aMenu |

	aMenu _ MenuMorph new defaultTarget: self.

	aMenu 
		add: 'change title...' action: #relabel;
		add: 'window color...' action: #setWindowColor;
		addLine;
		add: 'send to back' action: #sendToBack;
		add: 'make next-to-topmost' action: #makeSecondTopmost;
		addLine;
		add: (self isSticky ifTrue: [ 'make draggable' ] ifFalse: [ 'make undraggable' ]) action: #toggleStickiness;
		addLine;
		add: 'close' action: #delete;
		add: 'collapse' action: #collapse;
		add: 'expand / contract' action: #expandBoxHit;
		addLine;
		add: 'resize...' action: #resize;
		add: 'resize full' action: #resizeFull;
		add: 'resize top' action: #resizeTop;
		add: 'resize left' action: #resizeLeft;
		add: 'resize bottom' action: #resizeBottom;
		add: 'resize right' action: #resizeRight;
		add: 'resize top left' action: #resizeTopLeft;
		add: 'resize top right' action: #resizeTopRight;
		add: 'resize bottom left' action: #resizeBottomLeft;
		add: 'resize bottom right' action: #resizeBottomRight.

	^ aMenu! !

!SystemWindow methodsFor: 'menu' stamp: 'jmv 6/7/2013 23:23'!
setWindowColor: incomingColor
	| existingColor aColor |
	incomingColor ifNil: [^ self].  "it happens"
	aColor _ incomingColor asNontranslucentColor.
	aColor = Color black ifTrue: [^ self].
	existingColor _ self widgetsColor.
	existingColor ifNil: [^ Smalltalk beep].
	self widgetsColor: aColor.
	self redrawNeeded! !

!SystemWindow methodsFor: 'open/close' stamp: 'jmv 1/2/2017 14:11:03'!
                           initialFrameIn: aWorld
	^RealEstateAgent initialFrameFor: self world: aWorld! !

!SystemWindow methodsFor: 'open/close' stamp: 'jmv 1/2/2017 14:11:12'!
        openInWorld: aWorld
	"This msg and its callees result in the window being activeOnlyOnTop"
	| frameRect |
	frameRect _ self initialFrameIn: aWorld.
	self morphExtent: frameRect extent.
	aWorld addMorph: self position: frameRect topLeft.
	"Do it deferred. Was needed for text cursor to start blinking if (Preferences disable: #focusFollowsMouse) "
	WorldState addDeferredUIMessage: [ self activate ]! !

!SystemWindow methodsFor: 'resize/collapse' stamp: 'jmv 6/19/2017 16:13:13'!
resize
	| resizeMorph |
	resizeMorph _ ResizeMorph new morphExtent: `200@150`.
	resizeMorph action: [self resize: (resizeMorph selectionRectangle: Display extent)].
	resizeMorph morphPosition: self world activeHand morphPosition.
	resizeMorph openInWorld
	! !


LayoutMorph subclass: #TaskbarMorph
	instanceVariableNames: 'viewBox scale'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Taskbar'!

!TaskbarMorph methodsFor: 'accessing' stamp: 'jmv 1/15/2017 14:49:41'!
                            buttonFor: aMorph
	
	viewBox ifNotNil: [
		viewBox submorphs do: [ :button | 
			button model == aMorph
				ifTrue: [ ^button ]]
	].
	^nil! !

!TaskbarMorph methodsFor: 'accessing' stamp: 'jmv 1/15/2017 14:49:30'!
          scale

	 ^ scale ifNil: [ self defaultScale ] ifNotNil: [ scale ]! !

!TaskbarMorph methodsFor: 'events' stamp: 'jmv 1/8/2017 16:48:00'!
                       notifyDisplayResize
	Display
		when: #screenSizeChanged
		send: #screenSizeChanged
		to: self.
	self screenSizeChanged! !

!TaskbarMorph methodsFor: 'events' stamp: 'jmv 1/8/2017 16:48:14'!
  screenSizeChanged
	"Respond to change in screen size by repositioning self to bottom of screen"
	
"	Transcript newLine; print: 'Taskbar screenSizeChanged'.
"
	| y e |
	WorldState addDeferredUIMessage: [
		self world ifNotNil: [ :w |
			y _ w morphExtent y - self defaultHeight.
			e _ self internalizeDistance: w morphExtent x @ self defaultHeight.
			self morphPosition: 0@y extent: e ]]! !

!TaskbarMorph methodsFor: 'initialization' stamp: 'jmv 1/15/2017 14:49:51'!
           defaultHeight

	^ Preferences windowTitleFont height * 2 * self scale! !

!TaskbarMorph methodsFor: 'initialization' stamp: 'jmv 1/15/2017 14:49:19'!
          defaultScale

	 ^ 1! !

!TaskbarMorph methodsFor: 'initialization' stamp: 'jmv 1/8/2017 16:57:33'!
                             initialize
	super initialize.
	viewBox _ LayoutMorph newRow color: self defaultColor.
	self
		addMorph: UpdatingStringMorph initializedInstance
		layoutSpec:  (LayoutSpec morphWidthProportionalHeight: 1.0).
	self
		addMorph: viewBox 
		layoutSpec: (LayoutSpec
			proportionalWidth: 1.0
			proportionalHeight: 1.0 
			minorDirectionPadding: #right).
	viewBox separation: 5
! !

!TaskbarMorph methodsFor: 'testing' stamp: 'jmv 1/8/2017 16:44:53'!
   is: aSymbol
	^ aSymbol == #TaskbarMorph or: [ super is: aSymbol ]! !

!TaskbarMorph methodsFor: 'testing' stamp: 'jmv 1/8/2017 16:47:41'!
                      isSticky
	"answer whether the receiver is Sticky"
	^true! !

!TaskbarMorph methodsFor: 'services' stamp: 'jmv 3/30/2017 08:54:49'!
                             aboutToCollapse: aMorph
	"Add a button for aMorph if not already there (see #taskbarIncludesAllWindows)"

	(self buttonFor: aMorph) ifNil: [
		self addButtonFor: aMorph ]! !

!TaskbarMorph methodsFor: 'services' stamp: 'jmv 3/30/2017 08:41:28'!
           addButtonFor: aMorph

	| button |
	aMorph == self ifFalse: [
		button _ PluggableButtonMorph
			model: aMorph
			stateGetter: nil
			action: #toggleCollapseOrShow.
		button
			color: self color;
			icon: (aMorph imageForm: 32);
			setBalloonText: aMorph label.
		button icon: button magnifiedIcon.
		viewBox
			addMorph: button
			fixedWidth: self defaultHeight ]! !

!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:20:11'!
          removeButtonFor: aMorph

	(self buttonFor: aMorph) ifNotNil: [ :b |
		b delete ]! !

!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:49:21'!
     restoreAll
	viewBox ifNotNil: [
		viewBox submorphs do: [ :button | 
			button model showAndComeToFront ]	]! !

!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:25:27'!
          wasDeleted: aMorph
	"aMorph was deleted. Remove button for aMorph"

	self removeButtonFor: aMorph! !

!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:19:22'!
                    wasMadeVisible: aMorph
	"aMorph is now visible. Remove button for aMorph if appropriate (see #taskbarIncludesAllWindows)"

	Preferences taskbarIncludesAllWindows ifFalse: [
		self removeButtonFor: aMorph ]! !

!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:21:15'!
        wasOpened: aMorph
	"aMorph was added to the world. Add button for aMorph if appropriate (see #taskbarIncludesAllWindows)"
	
	Preferences taskbarIncludesAllWindows ifTrue: [
		self addButtonFor: aMorph ]! !

!TaskbarMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 1/15/2017 18:57:58'!
                               delete

	| w |
	self restoreAll.
	super delete.
	w _ self world ifNil: [ self runningWorld ].
	Display removeActionsWithReceiver: self.
	w ifNotNil: [ w taskbarDeleted ]! !

!TaskbarMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 1/18/2017 10:35:05'!
noteNewOwner: aMorph
	"I have just been added as a submorph of aMorph"
	super noteNewOwner: aMorph.
	Preferences taskbarIncludesAllWindows ifTrue: [
		aMorph submorphsDo: [ :m |
			self addButtonFor: m ]].
	self notifyDisplayResize! !

!TaskbarMorph methodsFor: 'menus' stamp: 'jmv 1/15/2017 19:14:11'!
                 handlesMouseDown: aMouseButtonEvent

	^ true! !

!TaskbarMorph methodsFor: 'menus' stamp: 'jmv 1/15/2017 19:10:57'!
            mouseButton2Activity

	| menu |
	menu _ MenuMorph new defaultTarget: self.
	menu
		addLine;
		add: 'Normal Height' action: #scaleNormal;
		add: 'Scale x 2' action: #scaleX2;
		add: 'Scale x 4' action: #scaleX4.
	menu popUpInWorld! !

!TaskbarMorph methodsFor: 'resize' stamp: 'jmv 1/15/2017 19:01:25'!
                  scale: anInteger

	(anInteger between: 1 and: 4) ifFalse: [ self error: 'scale should be 1 2 or 4' ].
	scale := anInteger.
	self screenSizeChanged. "rescale self"
	viewBox ifNotNil: [ "rescale buttons"
		viewBox submorphs do: [ :button | 
			button layoutSpec fixedWidth: self defaultHeight
		]
	]! !

!TaskbarMorph methodsFor: 'resize' stamp: 'jmv 1/15/2017 19:00:49'!
              scaleNormal

	self scale: 1! !

!TaskbarMorph methodsFor: 'resize' stamp: 'jmv 1/15/2017 19:00:52'!
                            scaleX2

	self scale: 2! !

!TaskbarMorph methodsFor: 'resize' stamp: 'jmv 1/15/2017 19:00:55'!
scaleX4

	self scale: 4! !

!TaskbarMorph commentStamp: '<historical>' prior: 0!
               A simple task bar written for Cuis.

dashBoard contains views/controls
viewBox contains graphic buttons of "iconized" windows/morphs.
scale allows 1x 2x 4x tarkbar height. [scale= 1,2,4]!

TaskbarMorph class
	instanceVariableNames: ''!

!TaskbarMorph class methodsFor: 'system startup' stamp: 'jmv 1/8/2017 16:47:17'!
  initClassCachedState

	"Should use some other way to find relevant instances"
	self flag: #jmvVer2.
	self allInstancesDo: [ :each |
		each notifyDisplayResize ]! !


Object subclass: #TestCase
	instanceVariableNames: 'testSelector failureString raisedError'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 11:01:27'!
                 defaultFailDescription

	^'Test failed'! !

!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 11:02:09'!
                  fail

	^self failWith: self defaultFailDescription ! !

!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 11:02:55'!
      failWith: aDescription

	self signalFailure: aDescription ! !

!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 10:58:09'!
                               should: aBlock

	self assert: aBlock value
			! !

!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 10:58:16'!
           should: aBlock description: aString

	self assert: aBlock value description: aString
			! !

!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 10:54:56'!
 should: aBlock raise: anExceptonHandlingCondition 

	^self should: aBlock raise: anExceptonHandlingCondition withExceptionDo: [ :anException | ]
			! !

!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 11:00:17'!
     should: aBlock raise: anExceptonHandlingCondition description: aFailDescription

	^self should: aBlock raise: anExceptonHandlingCondition withExceptionDo: [:anException | ] description: aFailDescription! !

!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 10:57:59'!
               should: aBlock raise: anExceptonHandlingCondition withExceptionDo: assertionsBlock

	^self should: aBlock raise: anExceptonHandlingCondition withExceptionDo: assertionsBlock description: self defaultFailDescription! !

!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 10:57:13'!
   should: aBlock raise: anExceptonHandlingCondition withExceptionDo: assertionsBlock description: aFailDescription

	^[aBlock value.
 	self failWith: aFailDescription ] 
		on: anExceptonHandlingCondition
		do: assertionsBlock ! !

!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 11:09:25'!
                         shouldnt: aBlock

	self deny: aBlock value
			! !

!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 11:09:20'!
           shouldnt: aBlock description: aString

	self deny: aBlock value description: aString
			! !

!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 11:10:31'!
 shouldnt: aBlock raise: anExceptonHandlingCondition 

	^self shouldnt: aBlock raise: anExceptonHandlingCondition description: anExceptonHandlingCondition printString, ' was not expected to be raised'! !

!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 11:06:04'!
                  shouldnt: aBlock raise: anExceptonHandlingCondition description: aFailDescription

	^aBlock 
		on: anExceptonHandlingCondition 
		do: [ :anException | self failWith: aFailDescription ]
! !

!TestCase methodsFor: 'Running' stamp: 'HAW 5/28/2017 20:01:57'!
 debug

	self setUpResources.
	
	[(self class selector: testSelector) runCase] ensure: [self tearDownResources]
			! !

!TestCase methodsFor: 'Running' stamp: 'HAW 3/3/2017 18:49:24'!
         debugAsFailure
	
	^self debugAsFailureIfCanNot: [ self signalCanNotDebugMethod ]! !

!TestCase methodsFor: 'Running' stamp: 'HAW 5/28/2017 20:06:48'!
          debugAsFailureIfCanNot: handler
	
	self ifCanNotDebugDo: [ ^handler value].
	
	(self class selector: testSelector) runCaseAsFailure! !

!TestCase methodsFor: 'Running' stamp: 'HAW 5/28/2017 20:01:43'!
                       setUpResources
			
	self resources do: [:res | res isAvailable ifFalse: [^res signalInitializationError]].
! !

!TestCase methodsFor: 'Running' stamp: 'HAW 5/28/2017 20:02:07'!
               tearDownResources
	
	self resources do: [:each | each reset]! !

!TestCase methodsFor: 'Private' stamp: 'HAW 3/3/2017 14:13:09'!
                               canNotDebugMethodErrorDescription

	^self class canNotDebugMethodErrorDescription! !

!TestCase methodsFor: 'Private' stamp: 'HAW 3/6/2017 14:55:38'!
          ifCanNotDebugDo: handler

	^self methodForTest isQuick ifTrue: handler! !

!TestCase methodsFor: 'Private' stamp: 'HAW 3/6/2017 14:55:23'!
                     methodForTest

	"Can not call it testMethod because it will be detected as test - Hernan" 

	^self class lookupSelector: self selector! !

!TestCase methodsFor: 'Private' stamp: 'HAW 5/28/2017 20:03:03'!
                    openDebuggerOnFailingTestMethod

	| processToDebug context compiledMethod debugger |

	compiledMethod _ self methodForTest.
	
	processToDebug _ [ [ self performTest ] ensure: [
		self tearDown.
		self tearDownResources]] newProcess.
	context _ processToDebug suspendedContext.
	
	debugger _ Debugger new
		process: processToDebug 
		context: context.
	debugger openFullNoSuspendLabel: 'Debug failed test ', self printString.

	[debugger interruptedContext method == compiledMethod] whileFalse: [debugger send].
! !

!TestCase methodsFor: 'Private' stamp: 'HAW 5/28/2017 20:03:22'!
                           runCaseAsFailure

	self setUpResources.
	self setUp.
	
	self openDebuggerOnFailingTestMethod! !

!TestCase methodsFor: 'Private' stamp: 'HAW 3/3/2017 14:13:37'!
                               signalCanNotDebugMethod 

	self error: self canNotDebugMethodErrorDescription! !

!TestCase methodsFor: 'Testing' stamp: 'HAW 6/3/2017 20:26:43'!
              isSameAs: aTestCase

	^self class = aTestCase class and: [ testSelector = aTestCase selector ]! !


TestCase class
	instanceVariableNames: ''!

!TestCase class methodsFor: 'Instance Creation' stamp: 'HAW 3/3/2017 18:51:38'!
debugAsFailure: aSymbol ifCanNot: handler

	^(self selector: aSymbol) debugAsFailureIfCanNot: handler
	! !

!TestCase class methodsFor: 'Testing' stamp: 'HAW 2/10/2017 16:32:10'!
             is: aSymbol

	^self ~= TestCase 
		and: [ aSymbol == #TestCaseClass or: [ super is: aSymbol ]]! !

!TestCase class methodsFor: 'Testing' stamp: 'pb 6/11/2017 20:10:43'!
                       isAbstract
	"Override to true if a TestCase subclass is Abstract and should not have
	TestCase instances built from it"
	^ thisContext methodClass == self class.! !

!TestCase class methodsFor: 'Testing' stamp: 'HAW 2/1/2017 19:35:57'!
                    shouldInheritSelectors
	"I should inherit from an Abstract superclass but not from a concrete one by default, unless I have no testSelectors in which case I must be expecting to inherit them from my superclass.  If a test case with selectors wants to inherit selectors from a concrete superclass, override this to true in that subclass."

	^self ~= TestCase 
		and: [ self superclass isAbstract or: [self testSelectors isEmpty]]

"$QA Ignore:Sends system method(superclass)$"
			! !

!TestCase class methodsFor: 'Error Descriptions' stamp: 'HAW 3/3/2017 16:33:00'!
           canNotDebugMethodErrorDescription

	^'Quick methods can not be debugged'! !


TestResource class
	instanceVariableNames: 'current'!

!TestResource class methodsFor: 'Testing' stamp: 'pb 6/11/2017 20:10:52'!
                 isAbstract
	"Override to true if a TestResource subclass is Abstract and should not have
	TestCase instances built from it"
	^ thisContext methodClass == self class.! !


Object subclass: #TestResult
	instanceVariableNames: 'failures errors passed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

!TestResult methodsFor: 'Accessing' stamp: 'HAW 6/3/2017 20:27:28'!
                        removeFromDefectsAndAddToPassed: aPassed 

	errors 
		detect: [ :anError | anError isSameAs: aPassed ]
		ifFound: [ :anError | errors remove: anError ]
		ifNone: [ 
			failures 
				detect: [ :aFail | aFail isSameAs: aPassed ]
				ifFound: [ :aFail | failures remove: aFail ]
				ifNone: [ self error: aPassed printString, ' is not an error nor a failure' ]].
	passed add: aPassed
! !


MessageSetWindow subclass: #TestResultWindow
	instanceVariableNames: 'testResult'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

!TestResultWindow methodsFor: 'actions' stamp: 'HAW 6/3/2017 20:51:08'!
                        debug

	model selection ifNotNil: [ :selection | | test |
		test := selection actualClass selector: selection selector.
		test debug.
		testResult removeFromDefectsAndAddToPassed: test.
		model removeMessageFromBrowserKeepingLabel. 
		self setLabel: testResult printString ]! !

!TestResultWindow methodsFor: 'actions' stamp: 'HAW 6/3/2017 20:51:12'!
 runSuite

	| suite |
	 
	suite := TestSuite new.
	suite addTests: testResult tests.
	self delete.
	(ProgessiveTestRunner for: suite) value.
	! !

!TestResultWindow methodsFor: 'button creation' stamp: 'HAW 6/3/2017 20:51:16'!
                              createDebugButton

	^PluggableButtonMorph 
		model: self
		stateGetter: #isMessageSelected
		action: #debug
		label: 'Debug'.
! !

!TestResultWindow methodsFor: 'button creation' stamp: 'HAW 6/3/2017 20:51:20'!
             createReRunButton

	^PluggableButtonMorph 
		model: self
		stateGetter: nil
		action: #runSuite
		label: 'Run Suite'.
! !

!TestResultWindow methodsFor: 'GUI building' stamp: 'HAW 6/3/2017 20:51:24'!
                        addButton: button to: row color: buttonColor

	button color: buttonColor.
	row addMorph: button proportionalWidth: 10! !

!TestResultWindow methodsFor: 'GUI building' stamp: 'HAW 6/3/2017 20:51:28'!
                         addButtonsTo: row color: buttonColor

	self addButton: self createDebugButton to: row color: buttonColor.
	self addButton: self createReRunButton to: row color: buttonColor.
	! !

!TestResultWindow methodsFor: 'GUI building' stamp: 'HAW 6/3/2017 20:51:32'!
                               buildLowerPanes

	| codeAndButtons  |

	codeAndButtons _ LayoutMorph newColumn.
	codeAndButtons
		addMorph: self buttonsRow fixedHeight: self defaultButtonPaneHeight;
		addAdjusterMorph;
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	
	^codeAndButtons ! !

!TestResultWindow methodsFor: 'GUI building' stamp: 'HAW 6/3/2017 20:51:36'!
 buttonsRow

	| buttonColor row |

	buttonColor := self buttonColor.
	row := LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.

	self addButtonsTo: row color: buttonColor.
	
	^row
	
	! !

!TestResultWindow methodsFor: 'initialization' stamp: 'HAW 6/3/2017 20:51:40'!
 initializeFor: aTestResult 

	testResult := aTestResult ! !

!TestResultWindow methodsFor: 'testing' stamp: 'HAW 6/3/2017 20:51:46'!
                           isMessageSelected

	^model selection notNil ! !


TestResultWindow class
	instanceVariableNames: ''!

!TestResultWindow class methodsFor: 'instance creation' stamp: 'HAW 6/3/2017 20:50:29'!
  methodReferencesOf: tests

	^tests collect: [:aTest | MethodReference class: aTest class selector: aTest selector].
! !

!TestResultWindow class methodsFor: 'instance creation' stamp: 'HAW 6/3/2017 20:50:25'!
               openFor: aTestResult

	| window |

	window := self openMessageList: (self methodReferencesOf: aTestResult defects) label: aTestResult printString.
	window initializeFor: aTestResult.
	
	^window 

! !


SystemWindow subclass: #TestRunnerWindow
	instanceVariableNames: 'passFailText detailsText progress'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!

!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 6/19/2017 16:13:18'!
                        buildMorphicWindow

	self layoutMorph
		addMorph: self buildUpperControls proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.75.
	self setLabel: 'SUnit Test Runner'.
	self refreshWindow.
	self morphExtent: `460 @ 400`! !

!TestRunnerWindow methodsFor: 'constants' stamp: 'jmv 4/16/2011 13:57'!
                 runButtonColor
	^ Color green lighter duller! !


Object subclass: #TestSuite
	instanceVariableNames: 'tests resources name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

!TestSuite methodsFor: 'Running' stamp: 'HAW 5/28/2017 20:04:59'!
                      run

	| result |
 
	result := TestResult new.
	self setUpResources.	
	[self run: result] ensure: [self tearDownResources].
	
	^result
			! !

!TestSuite methodsFor: 'Running - Private' stamp: 'HAW 5/28/2017 20:04:46'!
      setUpResources
			
	self resources do: [ :res | res isAvailable ifFalse: [^res signalInitializationError]].
	! !

!TestSuite methodsFor: 'Running - Private' stamp: 'HAW 5/28/2017 20:05:08'!
  tearDownResources
			
	self resources do: [:each | each reset]! !


TestSuite class
	instanceVariableNames: ''!

!TestSuite class methodsFor: 'Creation' stamp: 'HAW 2/4/2017 20:31:47'!
       forClass: aClass

	^(aClass is: #TestCaseClass) 
		ifTrue: [ self forTestCaseClass: aClass ]
		ifFalse: [ self forNoTestCaseClass: aClass ]
! !

!TestSuite class methodsFor: 'Creation' stamp: 'HAW 2/4/2017 21:53:12'!
       forCompiledMethod: aCompiledMethod

	^aCompiledMethod isTestMethod 
		ifTrue: [ self forTestMethod: aCompiledMethod ]
		ifFalse: [ self forNoTestMethod: aCompiledMethod ]
	! !

!TestSuite class methodsFor: 'Creation' stamp: 'HAW 2/1/2017 18:43:22'!
       forMessageCategoryNamed: aMessageCategoryName of: aClass categorizedWith: aClassOrganizer

	| suite |
	
	suite _ self named: aClass name, ' tests categorized under ',aMessageCategoryName.
	(aClassOrganizer listAtCategoryNamed: aMessageCategoryName) do: [ :selector |
		(aClass compiledMethodAt: selector) isTestMethod ifTrue: [ suite addTest: (aClass selector: selector) ]].
	
	^suite
	! !

!TestSuite class methodsFor: 'Creation' stamp: 'HAW 2/7/2017 10:24:12'!
                 forSystemCategoryNamed: aCategoryName  using: aSystemOrganizer 

	| testCaseClasses |
	
	testCaseClasses _ aSystemOrganizer testCaseClassesAt: aCategoryName.
	
	^testCaseClasses isEmpty 
		ifTrue: [ self forClasses: (aSystemOrganizer classesAt: aCategoryName) named: aCategoryName, ' infered tests' ]
		ifFalse: [ self forTestCaseClasses: testCaseClasses named: aCategoryName, ' tests' ]
		
! !

!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 10:25:51'!
  allTestCaseClassesReferencing: aClass

	^(aClass allCallsOn 
		collect: [ :aMethodReference | aMethodReference actualClass ]
		thenSelect: [ :aPotentialTestCaseClass | aPotentialTestCaseClass is: #TestCaseClass ]) asSet.! !

!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 10:27:27'!
             allTestsSending: aSelector
	
	^(Smalltalk allCallsOn: aSelector) select: [:aMethodReference | 
		(aMethodReference actualClass is: #TestCaseClass) and: [aMethodReference compiledMethod isTestMethod ]].! !

!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 09:08:23'!
forClasses: classes named: name

	| suite |
	
	suite _ classes
		inject: (self named: name)
		into: [ :partialSuite :aClass | partialSuite addTests: (self forClass: aClass) tests ].
		
	^suite
		
! !

!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 10:32:17'!
     forNoTestCaseClass: aClass 

	^aClass 
		withTestCaseClassDo: [ :aTestCaseClass | self forTestCaseClass: aTestCaseClass ]
		ifNone: [ self forReferencesToClass: aClass ]

! !

!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 11:28:55'!
                              forNoTestMethod: aCompiledMethod 
	
	| allTestSenders testCaseClassesReferencingClass reducedTestSenders suite |
	
	allTestSenders _ self allTestsSending: aCompiledMethod selector.
	testCaseClassesReferencingClass _ aCompiledMethod methodClass 
		withTestCaseClassDo:  [:aTestCaseClass | Array with: aTestCaseClass ]
		ifNone: [ self allTestCaseClassesReferencing: aCompiledMethod methodClass ].
		
	reducedTestSenders _ allTestSenders select: [ :aMethodReference | testCaseClassesReferencingClass includes: aMethodReference actualClass ].
	reducedTestSenders isEmpty 
		ifTrue: [ suite _ self forClass: aCompiledMethod methodClass ]
		ifFalse: [ 
			suite _ self named: 'Tests senders of ', aCompiledMethod selector.
			reducedTestSenders do: [ :aMethodReference | suite addTest: (aMethodReference actualClass selector: aMethodReference selector)]].
	
	^suite! !

!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 10:33:27'!
             forReferencesToClass: aClass 

	| testCaseClasses |
	
	testCaseClasses _ self allTestCaseClassesReferencing: aClass.
		
	^testCaseClasses 
		inject: (self named: aClass name, ' all test references')
		into: [ :suite :aTestCaseClass | aTestCaseClass addToSuiteFromSelectors: suite ]
	

! !

!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 10:34:27'!
            forTestCaseClass: aTestCaseClass 

	| suite |
	
	suite _ aTestCaseClass buildSuite.
	suite name: aTestCaseClass name, ' tests'.
	
	^suite! !

!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 09:04:48'!
forTestCaseClasses: testCaseClasses named: aName

	| suite |
	
	suite _ testCaseClasses
		inject: (self named: aName) 
		into: [:partialSuite :aTestCaseClass | aTestCaseClass addToSuiteFromSelectors: partialSuite ].
		
	^suite! !

!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/4/2017 21:53:22'!
       forTestMethod: aCompiledMethod
	
	| suite |
	
	suite _ self named: 'Test'.
	suite addTest: (aCompiledMethod methodClass selector: aCompiledMethod selector).
	
	^suite
		! !


SequenceableCollection subclass: #Text
	instanceVariableNames: 'string runs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!Text methodsFor: 'emphasis' stamp: 'jmv 9/10/2017 16:32:21'!
                             alignmentAt: characterIndex

	self
		withAttributeValues: (self attributesAt: characterIndex)
		do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
			^ alignment ]! !

!Text methodsFor: 'emphasis' stamp: 'jmv 9/10/2017 16:33:17'!
 characterStyleOrNilAt: characterIndex

	self
		withAttributeValues: (self attributesAt: characterIndex)
		do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
			^ characterStyle ]! !

!Text methodsFor: 'emphasis' stamp: 'jmv 9/10/2017 16:33:23'!
                  characterStyleOrNilIfApplying: textAttributes
	"Answer the ParagraphStyle for characters as specified by the argument."
	
	self withAttributeValues: textAttributes do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
		^characterStyle ]! !

!Text methodsFor: 'emphasis' stamp: 'jmv 9/10/2017 16:33:30'!
                          emphasisAt: characterIndex
	"Answer the emphasis for characters in the run beginning at characterIndex."

	self
		withAttributeValues: (self attributesAt: characterIndex)
		do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
			^ emphasis ]! !

!Text methodsFor: 'emphasis' stamp: 'jmv 9/10/2017 16:33:36'!
                     fontIfApplying: textAttributes default: defaultFont
	"Answer the font for characters as specified by the argument."

	self withAttributeValues: textAttributes do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
		^((AbstractFont familyName: familyName pointSize: pointSize) ifNil: [ defaultFont baseFont ])
			emphasized: emphasis ]! !

!Text methodsFor: 'emphasis' stamp: 'jmv 9/10/2017 16:33:42'!
                         paragraphStyleOrNilAt: characterIndex

	self
		withAttributeValues: (self attributesAt: characterIndex)
		do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
			^ paragraphStyle ]! !

!Text methodsFor: 'emphasis' stamp: 'jmv 9/10/2017 16:33:48'!
                  paragraphStyleOrNilIfApplying: textAttributes
	"Answer the ParagraphStyle for characters as specified by the argument."
	
	self
		withAttributeValues: textAttributes
		do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
			^paragraphStyle ]! !

!Text methodsFor: 'emphasis' stamp: 'jmv 9/10/2017 16:34:25'!
                     withAttributeValues: attributes do: aBlock
	"Evaluate aBlock with the values of various attributes that affect text formatting, applied in the correct order
	The order is (each overwriting the previous one)
	1) basic defaults
	2) ParagraphStyleReferene
	3) CharacterStyleReference
	4) TextFontReference
	5) TextEmphasis"

	| paragraphStyle characterStyle familyName pointSize emphasis alignment color backgroundColor |
	paragraphStyle _ nil.
	characterStyle _ nil.
	familyName _ nil.
	pointSize _ nil.
	emphasis _ 0.
	alignment _ 0.
	color _ nil.
	backgroundColor _ nil.
	
	"ParagraphStyle is the first to set several values"
	attributes do: [ :attribute |
		attribute forParagraphStyleReferenceDo: [ :s |
			paragraphStyle _ s.
			familyName _ s familyName.
			pointSize _ s pointSize.
			emphasis _ s emphasis.
			alignment _ s alignment.
			s color ifNotNil: [ :c | color _ c ]]].

	"CharacterStyle, if present, can override font and color"
	attributes do: [ :attribute |
		attribute forCharacterStyleReferenceDo: [ :s |
			characterStyle _ s.
			familyName _ s familyName.
			pointSize _ s pointSize.
			emphasis _ s emphasis.
			s color ifNotNil: [ :c | color _ c ]]].

	"These will not interfere with each other, and all of them take precedence over previous values"
	attributes do: [ :attribute |
		attribute forFontFamilyAndSizeDo: [ :fn :ps | familyName _ fn. pointSize _ ps ].
		attribute forTextEmphasisDo: [ :e | emphasis _ emphasis bitOr: e ].
		attribute forTextColorDo: [ :c | color _ c ].
		attribute forTextBackgroundColorDo: [ :c | backgroundColor _ c ].
		attribute forTextAlignmentDo: [ :a | alignment _ a ].
	].
	
	"Done. Now evaluate the block."
	^aBlock valueWithArguments: { familyName. pointSize. emphasis. color. alignment. characterStyle. paragraphStyle. backgroundColor }! !


TextAction class
	instanceVariableNames: ''!

!TextAction class methodsFor: 'as yet unclassified' stamp: 'jmv 4/19/2015 09:38'!
                   textActionColor
	^Color r: 0.4 g: 0 b: 1.0! !


Object subclass: #TextAttribute
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-TextAttributes'!

!TextAttribute methodsFor: 'iterating' stamp: 'jmv 9/7/2017 16:45:20'!
                           forTextBackgroundColorDo: aBlock
	"No action is the default"! !


TextAttribute subclass: #TextBackgroundColor
	instanceVariableNames: 'color'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-TextAttributes'!

!TextBackgroundColor methodsFor: 'accessing' stamp: 'jmv 9/7/2017 16:41:55'!
                 color
	^ color! !

!TextBackgroundColor methodsFor: 'accessing' stamp: 'jmv 9/7/2017 16:41:55'!
color: aColor
	color _ aColor! !

!TextBackgroundColor methodsFor: 'comparing' stamp: 'jmv 9/7/2017 16:41:55'!
                 = other
 	self == other ifTrue: [ ^ true ].
	^ (other class == self class) 
		and: [other color = color]! !

!TextBackgroundColor methodsFor: 'comparing' stamp: 'jmv 9/7/2017 16:41:55'!
      hash
	^ color hash! !

!TextBackgroundColor methodsFor: 'printing' stamp: 'jmv 9/7/2017 16:41:55'!
                             printOn: strm
	super printOn: strm.
	strm nextPutAll: ' code: '; print: color! !

!TextBackgroundColor methodsFor: 'scanning' stamp: 'jmv 9/7/2017 16:41:55'!
  dominates: other
	^ other class == self class! !

!TextBackgroundColor methodsFor: 'iterating' stamp: 'jmv 9/7/2017 16:45:12'!
 forTextBackgroundColorDo: aBlock
	aBlock value: color! !

!TextBackgroundColor methodsFor: 'testing' stamp: 'jmv 9/7/2017 16:44:40'!
                           isSet
	"Do not include Color black, as it is the default color."
	^color isTransparent not! !

!TextBackgroundColor commentStamp: '<historical>' prior: 0!
     A TextBackgroundColor encodes a highlight (background) color change applicable over a given range of text.!

TextBackgroundColor class
	instanceVariableNames: ''!

!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 9/7/2017 16:41:55'!
         black
	^ self new color: Color black! !

!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 9/7/2017 16:41:55'!
    blue
	^ self new color: Color blue! !

!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 9/7/2017 16:41:55'!
      cyan
	^ self new color: Color cyan! !

!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 9/7/2017 16:41:55'!
      gray
	^ self new color: Color gray! !

!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 9/7/2017 16:41:55'!
      green
	^ self new color: Color green! !

!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 9/7/2017 16:41:55'!
    magenta
	^ self new color: Color magenta! !

!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 9/7/2017 16:41:55'!
red
	^ self new color: Color red! !

!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 9/7/2017 16:41:55'!
        white 
	^ self new color: Color white! !

!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 9/7/2017 16:41:55'!
   yellow
	^ self new color: Color yellow! !

!TextBackgroundColor class methodsFor: 'instance creation' stamp: 'jmv 9/7/2017 16:41:55'!
                          color: aColor
	^ self new color: aColor! !


TextAttribute subclass: #TextColor
	instanceVariableNames: 'color'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-TextAttributes'!

!TextColor methodsFor: 'testing' stamp: 'jmv 1/21/2011 11:33'!
                              isSet
	"Do not include Color black, as it is the default color."
	^color ~= Color black! !


TextColor class
	instanceVariableNames: ''!

!TextColor class methodsFor: 'constants'!
            black
	^ self new color: Color black! !

!TextColor class methodsFor: 'constants'!
             blue
	^ self new color: Color blue! !

!TextColor class methodsFor: 'constants'!
               cyan
	^ self new color: Color cyan! !

!TextColor class methodsFor: 'constants' stamp: 'ajh 9/10/2002 02:26'!
                  gray
	^ self new color: Color gray! !

!TextColor class methodsFor: 'constants'!
               green
	^ self new color: Color green! !

!TextColor class methodsFor: 'constants'!
             magenta
	^ self new color: Color magenta! !

!TextColor class methodsFor: 'constants'!
         red
	^ self new color: Color red! !

!TextColor class methodsFor: 'constants' stamp: 'sma 3/24/2000 10:50'!
                    white 
	^ self new color: Color white! !

!TextColor class methodsFor: 'constants'!
            yellow
	^ self new color: Color yellow! !


Object subclass: #TextComposition
	instanceVariableNames: 'model extentForComposing lines maxRightX selectionStartBlocks selectionStopBlocks editor showTextCursor lastTextCursorRect'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Text Support'!

!TextComposition methodsFor: 'selection' stamp: 'jmv 6/19/2017 16:13:22'!
 defaultCharacterBlock
	^ CharacterBlock
		stringIndex: 1
		text: model actualContents
		topLeft: lines first topLeft
		extent: `0 @ 0`
		textLine: lines first! !


Editor subclass: #TextEditor
	instanceVariableNames: 'model textComposition markBlock pointBlock emphasisHere lastParenLocation selectionStartBlocks selectionStopBlocks initialSelectionStart initialSelectionStop doWordSelection doParagraphSelection defaultFont'
	classVariableNames: 'ChangeText FindText'
	poolDictionaries: ''
	category: 'System-Text'!

!TextEditor methodsFor: 'accessing' stamp: 'jmv 9/6/2017 10:02:22'!
                      replaceSelectionWith: aTextOrString
	"Deselect, and replace the selection text by aText."
	"This is a user command, and generates undo"

	| start stop replacement |

	morph disablesEditing ifTrue: [
		^ self ].

	start _ self startIndex.
	stop _ self stopIndex.
	(aTextOrString isEmpty and: [stop > start]) ifTrue: [
		"If deleting, then set emphasisHere from 1st character of the deletion"
		emphasisHere _ (model actualContents attributesAt: start) select: [:att |
			att mayBeExtended]].

	(start = stop and: [ aTextOrString isEmpty ]) ifFalse: [
		replacement _ self addAttributesForPasting: aTextOrString.
		model logUndoAndReplaceFrom: start to: stop - 1 with: replacement.
		textComposition
			recomposeFrom: start
			to:  start + replacement size - 1
			delta: replacement size - (stop-start).
		self deselectAndPlaceCursorAt: start + replacement size.
		selectionStartBlocks _ #().
		selectionStopBlocks _ #().
		self userHasEdited  " -- note text now dirty" ].

	morph possiblyChanged! !

!TextEditor methodsFor: 'attributes' stamp: 'jmv 12/12/2014 15:53'!
                     offerColorMenu
	"Present a menu of available colors, and if one is chosen, apply it to the current selection."
	"This is a user command, and generates undo"

	| attribute colors index thisSel |
	thisSel _ self selection.
	colors _ #(#black #magenta #red #yellow #green #blue #cyan #white ).
	index _ (PopUpMenu
		labelArray: colors , #('choose color...' )
		lines: (Array with: colors size + 1)) startUpMenu.
	index = 0 ifTrue: [ ^ true ].
	index <= colors size
		ifTrue: [ attribute _ TextColor color: (Color perform: (colors at: index)) ]
		ifFalse: [
			index _ index - colors size - 1.
			"Re-number!!!!!!"
			index = 0 ifTrue: [ attribute _ self chooseColor ].
			thisSel ifNil: [ ^ true ]].
	attribute ifNotNil: [ self applyAttribute: attribute ].
	^ true.! !

!TextEditor methodsFor: 'editing keys' stamp: 'jmv 12/30/2016 10:34:01'!
                        enclose: aKeyboardEvent
	"Insert or remove bracket characters around the current selection."
	"This is a user command, and generates undo"

	| left right startIndex stopIndex oldSelection which |
	startIndex _ self startIndex.
	stopIndex _ self stopIndex.
	oldSelection _ self selection.
	which _ '([<{"''`' indexOf: aKeyboardEvent keyCharacter ifAbsent: [ ^true ].
	left _ '([<{"''`' at: which.
	right _ ')]>}"''`' at: which.
	((startIndex > 1 and: [stopIndex <= model textSize])
			and: [ (model actualContents at: startIndex-1) = left and: [(model actualContents at: stopIndex) = right]])
		ifTrue: [
			"already enclosed; strip off brackets"
			self selectFrom: startIndex-1 to: stopIndex.
			self replaceSelectionWith: oldSelection]
		ifFalse: [
			"not enclosed; enclose by matching brackets"
			self replaceSelectionWith:
				(Text string: (String with: left) attributes: emphasisHere),
				oldSelection,
				(Text string: (String with: right) attributes: emphasisHere).
			self selectFrom: startIndex+1 to: stopIndex].
	^true! !

!TextEditor methodsFor: 'menu messages' stamp: 'HernanWilkinson 1/10/2017 16:00:24'!
                             acceptContents
	"Save the current text of the text being edited as the current acceptable version for purposes of canceling.  Allow my morph to take appropriate action"
	^morph acceptContents! !

!TextEditor methodsFor: 'menu messages' stamp: 'jmv 4/16/2017 19:53:14'!
                   compareToClipboard
	"Check to see if whether the receiver's text is the same as the text currently on the clipboard, and inform the user."
	| s1 s2 |
	s1 _ self clipboardStringOrText string.
	s2 _ self selection ifEmpty: [self privateCurrentString].
	s1 = s2 ifTrue: [^ self inform: 'Exact match'].

	(TextModel new contents:
		(DifferenceFinder displayPatchFrom: s1 to: s2 tryWords: true))
			openLabel: 'Comparison to Clipboard Text'! !

!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 7/24/2017 09:10:47'!
                       forwardDelete: aKeyboardEvent
	"Delete forward over the next character."
	"This is a user command, and generates undo"

	| startIndex stopIndex |

	"If there was a selection"
	self hasSelection ifTrue: [
		self replaceSelectionWith: self nullText.
		^ false].

	"Exit if at end"
	startIndex _ self markIndex.
	startIndex > model textSize ifTrue: [
		^ false].

	"Null selection - do the delete forward"
	stopIndex _ startIndex.
	(aKeyboardEvent keyValue = 127 and: [ aKeyboardEvent shiftPressed ])
		ifTrue: [stopIndex := (self nextWordStart: stopIndex) - 1].
	self selectFrom: startIndex to: stopIndex.
	self replaceSelectionWith: self nullText.
	self deselectAndPlaceCursorAt: startIndex.
	^false! !

!TextEditor methodsFor: 'private' stamp: 'jmv 9/6/2017 10:02:19'!
                               applyAttribute: aTextAttribute
	"The user selected aTextAttribute via shortcut, menu or other means.
	If there is a selection, apply the attribute to the selection.
	In any case use the attribute for the user input (emphasisHere)"
	"This generates undo"
	| anythingDone |

	morph disablesEditing ifTrue: [
		^ self ].

	anythingDone _ false.
	emphasisHere _ Text addAttribute: aTextAttribute toArray: emphasisHere.
	self selectionIntervalsDo: [ :interval |
		(interval notEmpty or: [ aTextAttribute isParagraphAttribute ])
			ifTrue: [
				anythingDone _ true.
				model logUndoAndAddAttribute: aTextAttribute from: interval first to: interval last.
				textComposition recomposeFrom: interval first to: interval last delta: 0 ]].
	anythingDone ifTrue: [
		self recomputeSelection.	"Needed so visible selection is updated to reflect new visual extent of selection"
		self userHasEdited ].

	"Even if nothing done, emphasisHere might have changed"
	morph possiblyChanged! !

!TextEditor methodsFor: 'undo & redo' stamp: 'jmv 9/6/2017 10:02:20'!
            redo

	morph disablesEditing ifTrue: [
		^ self ].

	model redoAndEvaluate: [ :modelUpdated :newCursorPos |
		newCursorPos
			ifNil: [ self recomputeSelection ]
			ifNotNil: [ self markIndex: newCursorPos pointIndex: newCursorPos ].
		modelUpdated ifTrue: [
			self userHasEdited.
			textComposition composeAll.			"this could be made more specific..."
			morph possiblyChanged ]]! !

!TextEditor methodsFor: 'undo & redo' stamp: 'jmv 9/6/2017 10:02:24'!
                          undo

	morph disablesEditing ifTrue: [
		^ self ].

	model undoAndEvaluate: [ :modelUpdated :newCursorPos |
		newCursorPos
			ifNil: [ self recomputeSelection ]
			ifNotNil: [ self markIndex: newCursorPos pointIndex: newCursorPos ].
		modelUpdated ifTrue: [
			self userHasEdited.
			textComposition composeAll.				"this could be made more specific..."
			morph possiblyChanged ]]! !


TextEditor class
	instanceVariableNames: 'menu'!

!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 12/30/2016 10:33:45'!
                 basicCmdShortcutsSpec
	"
	Editor initialize
	"

	"arranged in QWERTY keyboard order"
	^#(
		#(		$( 	#enclose:					'Enclose within ( and ), or remove enclosing ( and )')
		#(		$[ 	#enclose:					'Enclose within [ and ], or remove enclosing [ and ]')
		#(		${ 	#enclose:					'Enclose within { and }, or remove enclosing { and }')
		#(		$' 	#enclose:					'Enclose within single quotes, or remove enclosing single quotes')
		#(		$" 	#enclose:					'Enclose within double quotes, or remove enclosing double quotes')
		#(		$` 	#enclose:					'Enclose within backticks, or remove enclosing backticks')
		#(		$< #enclose:					'Enclose within < and >, or remove enclosing < and >')

		#(		$a 	#selectAll:					'Select all')
		#(		$f 	#find:						'Find')
		#(		$g 	#findAgain:				'Find again')
		#(		$h 	#help:						'Open this help')
		#(		$j 	#setSearchString:		'Set selection as search string for find again')

		#(		$z 	#undo:						'Undo (multiple levels)')
		#(		$x 	#cut:							'Cut selection and store it in the Clipboard')
		#(		$c 	#copySelection:			'Copy selection to the Clipboard')
		#(		$v 	#paste:						'Paste Clipboard contents')

		#(		$R	#indent:						'Indent (move selection one tab-stap right)')
		#(		$Y	#makeUppercase:		'Force selection to uppercase')
		#(		$U	#changeLineEndsToLf:	'Convert line endings to LF characters (Cuis convention) in selection')

		#(		$H	#cursorTopHome:		'Move cursor to start of text')
		#(		$L	#outdent:					'Outdent (move selection one tab-stop left)')

		#(		$Z	#redo:						'Redo (multiple levels)')
		#(		$X	#makeLowercase:		'Force selection to lowercase')
		#(		$C	#compareToClipboard:	'Compare argument to clipboard')

		#(		$ 	#selectWord:				'Select the current word as with double clicking')
	)! !


ActiveModel subclass: #TextModel
	instanceVariableNames: 'actualContents undoRedoCommands lastEditTimeStamp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!TextModel methodsFor: 'user interface support' stamp: 'jmv 8/26/2017 19:19:29'!
           formatAndStyleIfNeededWith: anSHTextStyler
	anSHTextStyler ifNotNil: [
		(self shouldStyle: self actualContents with: anSHTextStyler) ifTrue: [
			anSHTextStyler formatAndStyle: self actualContents allowBackgroundStyleProcess: true.
			self basicActualContents: anSHTextStyler formattedText ]]! !


PluggableScrollPane subclass: #TextModelMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!TextModelMorph methodsFor: 'accessing' stamp: 'jmv 9/6/2017 10:01:18'!
                         disableEditing
	self textMorph disableEditing! !

!TextModelMorph methodsFor: 'accessing' stamp: 'jmv 9/6/2017 10:03:26'!
      enableEditing

	self textMorph enableEditing! !

!TextModelMorph methodsFor: 'drawing' stamp: 'cbr 10/10/2012 23:04'!
          drawOn: aCanvas 
	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"


	| bw bc |

	self flag: #todo. "Integrate this method with the Theme system. --cbr"


	super drawOn: aCanvas.
	bw _ Preferences focusIndicatorWidth.
	bc _ nil.
	self wantsFrameAdornments ifTrue: [
		model refusesToAccept
			ifTrue: [  "Put up feedback showing that code cannot be submitted in this state"
				bc _ Color tan]
			ifFalse: [
				self textMorph hasEditingConflicts
					ifTrue: [
						bw _ 3.
						bc _ Color red ] 
					ifFalse: [
						self textMorph hasUnacceptedEdits
							ifTrue: [
								bc _ Color red]]]].

	(drawKeyboardFocusIndicator and: [ self textMorph hasKeyboardFocus ]) ifTrue: [
		bc ifNil: [
			bc _ Theme current focusIndicator ]]
	ifFalse: [
		bc ifNotNil: [
			bc _ bc alphaMixed: 0.4 with: Color white ]].
	bc ifNotNil: [
		aCanvas frameRectangle: self focusIndicatorRectangle borderWidth: bw color: bc ]! !


Object subclass: #TheWorldMenu
	instanceVariableNames: 'myWorld myHand'
	classVariableNames: 'ExtraOpenCommands'
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!TheWorldMenu methodsFor: 'commands' stamp: 'pb 6/5/2017 00:35:30'!
                splitNewMorphList: list depth: d
	| middle c prev next out |
	d <= 0 ifTrue: [ ^ Array with: list ].
	middle := list size // 2 + 1.
	c := (list at: middle) name first: 3.
	prev := middle - 1.
	[
	prev > 0 and: [ ((list at: prev) name first: 3) = c ]] whileTrue: [ prev := prev - 1 ].
	next := middle + 1.
	[
	next <= list size and: [ ((list at: next) name first: 3) = c ]] whileTrue: [ next := next + 1 ].
	"Choose the better cluster"
	middle := middle - prev < (next - middle)
		ifTrue: [ prev + 1 ]
		ifFalse: [ next ].
	middle = 1 ifTrue: [ middle := next ].
	middle >= list size ifTrue: [ middle := prev + 1 ].
	(middle = 1 or: [ middle >= list size ]) ifTrue: [ ^ Array with: list ].
	out := WriteStream on: Array new.
	out nextPutAll:
		(self
			splitNewMorphList:
				(list
					copyFrom: 1
					to: middle - 1)
			depth: d - 1).
	out nextPutAll:
		(self
			splitNewMorphList:
				(list
					copyFrom: middle
					to: list size)
			depth: d - 1).
	^ out contents.! !

!TheWorldMenu methodsFor: 'construction' stamp: 'pb 6/5/2017 00:38:53'!
         alphabeticalMorphMenu
	| list splitLists menu firstChar lastChar subMenu |
	list := Morph withAllSubclasses select: [ :m |
		m includeInNewMorphMenu ].
	list := list asArray sort: [ :c1 :c2 |
		c1 name < c2 name ].
	splitLists := self
		splitNewMorphList: list
		depth: 4.
	menu := MenuMorph new defaultTarget: self.
	1
		to: splitLists size
		do: [ :i |
			firstChar := i = 1
				ifTrue: [ $A ]
				ifFalse: [ 
					(splitLists at: i) first name first: 3 ].
			lastChar := i = splitLists size
				ifTrue: [ $Z ]
				ifFalse: [ 
					(splitLists at: i) last name first: 3 ].
			subMenu := MenuMorph new.
			(splitLists at: i) do: [ :cl |
				subMenu
					add: cl name
					target: self
					selector: #newMorphOfClass:event:
					argument: cl ].
			menu
				add: firstChar asString , ' - ' , lastChar asString
				subMenu: subMenu ].
	^ menu.! !

!TheWorldMenu methodsFor: 'construction' stamp: 'HAW 3/18/2017 20:26:59'!
       buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu _ MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: {
				{ 'Open...'. { self. #openWindow}}.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'}.
				{ 'Preferences...'. { self. #preferencesDo}.
					'put up a menu offering many controls over appearance and system preferences.'}.
				{ 'Windows...'. { self. #windowsDo}}.
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				nil.
				{ 'Changes...'. { self. #changesDo}}.
				{ 'Debug...'. { self. #debugDo}.
					'a menu of debugging items'}.
				{ 'Restore Display (r)'. { myWorld. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name\and save it under that name on disk.\Clear all user preferences and user state (class vars).' withNewLines}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the image and quit out of Cuis.'}.				
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !

!TheWorldMenu methodsFor: 'construction' stamp: 'pb 6/9/2017 00:11:33'!
                newMorph
	"The user requested 'new morph' from the world menu.  Put up a menu that allows many ways of obtaining new morphs.  If the preference #classicNewMorphMenu is true, the full form of yore is used; otherwise, a much shortened form is used."
	| menu subMenu catDict |
	menu _ self menu: 'Add a new morph'.
	menu
		
			add: 'From Clipboard'
			target: myHand
			action: #pasteMorph;
		
			add: 'From Alphabetical List'
			subMenu: self alphabeticalMorphMenu.
	menu addLine.
	"Add 'Classic' New Morph menu"
	catDict _ Dictionary new.

	Morph allSubclassesDo: [ :eaSubclass |
		eaSubclass includeInNewMorphMenu ifTrue: [ | category |
			(eaSubclass respondsTo: #categoryInNewMorphMenu)
				ifTrue: [ category _ eaSubclass categoryInNewMorphMenu ]
				ifFalse: [ category _ 'Unknown' ].
			(catDict includesKey: category)
				ifTrue: [ (catDict at: category) add: eaSubclass ]
				ifFalse: [
					catDict
						at: category
						put: (OrderedCollection with: eaSubclass) ]]].
	catDict keys sort do: [ :categ |
		subMenu _ MenuMorph new.
		((catDict at: categ) asArray sort: [ :c1 :c2 |
			c1 name < c2 name ]) do: [ :cl |
			subMenu
				add: cl name
				target: self
				selector: #newMorphOfClass:event:
				argument: cl ].
		menu
			add: categ
			subMenu: subMenu ].
	self doPopUp: menu.! !


Object subclass: #Theme
	instanceVariableNames: 'menuItemIcons'
	classVariableNames: 'Content CurrentTheme'
	poolDictionaries: ''
	category: 'Theme-Core'!

!Theme methodsFor: 'colors' stamp: 'jmv 11/19/2010 14:06'!
                       background
	^ Color r: 0.7 g: 0.72 b: 0.83! !

!Theme methodsFor: 'colors' stamp: 'jmv 11/23/2010 09:42'!
                      buttonColorFrom: aColor
	^ Display depth <= 8
			ifTrue: [ Color transparent ]
			ifFalse: [ aColor paler ]! !

!Theme methodsFor: 'colors' stamp: 'jmv 3/14/2011 08:50'!
                      buttonLabel
	^Color gray: 0.18! !

!Theme methodsFor: 'colors' stamp: 'len 6/9/2016 17:38'!
    errorColor
	^ Color red lighter! !

!Theme methodsFor: 'colors' stamp: 'len 6/9/2016 17:40'!
   failureColor
	^ Color yellow lighter! !

!Theme methodsFor: 'colors' stamp: 'len 11/14/2015 02:34'!
                            scrollbarButtonColor
	^Color gray: 0.95! !

!Theme methodsFor: 'colors' stamp: 'len 11/17/2015 23:55'!
                         scrollbarColor
	^Color white! !

!Theme methodsFor: 'colors' stamp: 'len 11/14/2015 02:34'!
    scrollbarSliderShadowColor
	^Color white! !

!Theme methodsFor: 'colors' stamp: 'len 6/9/2016 17:38'!
                          successColor
	^ Color green lighter! !

!Theme methodsFor: 'colors' stamp: 'cbr 11/7/2010 18:00'!
                              text
	^ Color black! !

!Theme methodsFor: 'colors' stamp: 'jmv 10/16/2013 22:08'!
             textCursor
	^ Display depth <= 2
		ifTrue: [ Color black ]
		ifFalse: [ self text ]! !

!Theme methodsFor: 'colors' stamp: 'jmv 5/30/2011 14:31'!
              textHighlight
	"A nice light blue."
	"
	^ Color r: 0.71 g: 0.835 b: 1.0
	^ Color hue: 214 chroma: 0.29 luminance: 0.816
	"
	^Color hue: 204 chroma: 0.29 luminance: 0.77! !

!Theme methodsFor: 'colors' stamp: 'jmv 11/23/2010 09:58'!
                        textHighlightFocused: focused
	"A nice light blue."
	| textHighlight |
	Display depth = 1 ifTrue: [^ Color veryLightGray].
	Display depth = 2 ifTrue: [^ Color gray: 0.87].
	textHighlight _ self textHighlight.
	^focused
		ifTrue: [ textHighlight ]
		ifFalse: [ self unfocusedTextHighlightFrom: textHighlight ]! !

!Theme methodsFor: 'colors' stamp: 'cbr 12/6/2010 20:08'!
             windowLabel
	^Color gray: 0.3! !

!Theme methodsFor: 'menu colors' stamp: 'jmv 5/26/2011 09:07'!
                               menu
	Display depth <= 2 ifTrue: [^ Color white].
	^Color r: 0.75 g: 0.75 b: 0.75 alpha: 0.93! !

!Theme methodsFor: 'menu colors' stamp: 'jmv 11/23/2010 09:45'!
                              menuHighlight
	^ Display depth < 8
		ifTrue: [ Color veryLightGray ]
		ifFalse: [ self textHighlight ]! !

!Theme methodsFor: 'menu colors' stamp: 'cbr 11/7/2010 18:28'!
                      menuText
	^ Color black! !

!Theme methodsFor: 'menu colors' stamp: 'jmv 11/28/2010 08:04'!
    menuTitleBar
	Display depth = 1 ifTrue: [^ Color white].
	Display depth = 2 ifTrue: [^ Color gray].
	^ self menu darker! !

!Theme methodsFor: 'tool colors' stamp: 'jmv 4/15/2011 14:59'!
     browser
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color r: 0.5 g: 0.7 b: 0.4]! !

!Theme methodsFor: 'tool colors' stamp: 'jmv 2/14/2013 11:05'!
             debugger
	^Color h: 0.0 s: 0.6 v: 0.7! !

!Theme methodsFor: 'tool colors' stamp: 'jmv 11/23/2010 09:16'!
                      defaultWindowColor
	^ Color lightGray! !

!Theme methodsFor: 'tool colors' stamp: 'jmv 11/18/2010 12:44'!
                      fileContentsBrowser
	^Color tan duller! !

!Theme methodsFor: 'tool colors' stamp: 'cbr 12/4/2010 18:44'!
                      fileList
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color r: 0.7 g: 0.55 b: 0.7 ]! !

!Theme methodsFor: 'tool colors' stamp: 'jmv 5/23/2012 19:23'!
          messageNames

	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color r: 0.53 g: 0.77 b: 0.382 ]! !

!Theme methodsFor: 'tool colors' stamp: 'cbr 12/4/2010 18:45'!
  messageSet
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color r: 0.45 g: 0.6 b: 0.85 ]! !

!Theme methodsFor: 'tool colors' stamp: 'jmv 11/18/2010 12:44'!
      object
	^Color white duller! !

!Theme methodsFor: 'tool colors' stamp: 'jmv 3/28/2012 09:41'!
 packageList
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color r: 0.63 g: 0.47 b: 0.08 ]! !

!Theme methodsFor: 'tool colors' stamp: 'jmv 11/23/2010 09:17'!
    testRunner
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ (Color r: 0.650 g: 0.753 b: 0.976) duller ]! !

!Theme methodsFor: 'tool colors' stamp: 'jmv 3/16/2011 08:15'!
                          textEditor
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color gray: 0.6 ]! !

!Theme methodsFor: 'tool colors' stamp: 'cbr 12/4/2010 18:45'!
                    transcript
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color r: 0.8 g: 0.6 b: 0.3 ]! !

!Theme methodsFor: 'tool colors' stamp: 'cbr 12/18/2010 17:56'!
        versionsBrowser
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ (Color r: 0.869 g: 0.753 b: 1.0) duller ]! !

!Theme methodsFor: 'tool colors' stamp: 'jmv 3/16/2011 08:13'!
                       workspace
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color h: 60.0 s: 0.73 v: 0.72 ]! !

!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:49'!
     acceptButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ Color r: 0.2 g: 0.6 b: 0.1 ])! !

!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:51'!
       cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ Color r: 0.8 g: 0.2 b: 0.2 ])! !

!Theme methodsFor: 'widget colors' stamp: 'cbr 10/10/2012 23:36'!
      textPane
	^Color white! !

!Theme methodsFor: 'menus' stamp: 'jmv 6/5/2017 11:46:34'!
          basicIcons

	"Minimal menu scheme.
	Theme current class beCurrent
	"

	^ { 
		#('open...') -> #openIcon.
		#('windows...' 'find window' 'Focus follows mouse' 'Click to focus') -> #windowIcon.
		#('help...' 'explain' 'about this system...' 'Terse Guide to Cuis' 'Class Comment Browser' 'Code management in Cuis' 'Using GitHub to host Cuis packages' ) -> #helpIcon.
		#('themes...') -> #appearanceIcon.
		#('do it (d)') -> #doItIcon.
		#('new morph...' 'objects (o)' 'save world as morph file') -> #morphsIcon.
		#('save' ) -> #saveIcon.
		#('Save options...' 'save as...' 'change category...' 'rename change set (r)' 'rename') -> #saveAsIcon.
		#('save as new version') -> #saveAsNewVersionIcon.
		#('quit') -> #quitIcon.
		#('save and quit' ) -> #saveAndQuitIcon.
		#('inspect it (i)' 'inspect world'  'inspect model' 'inspect morph'
		 'inspect owner chain' 'inspect' 'inspect (i)' 'basic inspect' 'message names' 'find message names' 'inspect instances' 'inspect subinstances' 'inspect change set' 'inspect context (c)' 'inspect receiver (i)' 'start CPUWatcher' 'stop CPUWatcher')
			-> #inspectIcon.
		#('explore' 'explore it (I)' 'explore world' 'explore morph' 'explore (I)' 'explore context (C)' 'explore receiver (I)' 'references finder' 'weight explorer' 'explore CompiledMethod') -> #exploreIcon.
		#('find...(f)' 'find class... (f)' 'find method...' 'find recent submissions' 'show hierarchy' 'show definition' 'show comment' 'filter' 'filter message list...' 'find context... (f)') -> #findIcon.
		#('add item...' 'new category...' 'create new change set...' 'new change set... (n)' 'add new file') -> #newIcon.
		#('remove method (x)' 'remove' 'remove class (x)' 'remove method from system (x)' 'remove class from system (x)' 'remove postscript') -> #deleteIcon.
		#('delete method from changeset (d)' 'delete class from change set (d)' 'destroy change set (X)' 'revert & remove from changes' 'delete unchanged windows' 'delete non windows' 'delete both of the above' 'reset variables' 'remove contained in class categories...' 'clear this change set' 'uninstall this change set' 'delete directory...' 'delete') -> #warningIcon.
		#('do again (j)' 'Redo - multiple (Z)') -> #redoIcon.
		#('undo (z)' 'revert to previous version' 'Undo - multiple (z)') -> #undoIcon.
		#('copy (c)' 'copy class...' 'copy class chgs to other side' 'copy method to other side' 'copy all to other side (c)' 'copy name to clipboard' 'copy selector to clipboard') -> #copyIcon.
		#('paste (v)' 'Paste without Format') -> #pasteIcon.
		#('cut (x)' 'move class chgs to other side' 'move method to other side' 'submerge into other side') -> #cutIcon.
		#('paste...' 'icons...') -> #worldIcon.
}! !

!Theme methodsFor: 'menus' stamp: 'HAW 2/10/2017 17:30:49'!
       miscellaneousIcons

	"Everything else."

	^ {
		#('restore display (r)' 'set display depth...' 'move windows onscreen' 'Utilities saveDisplay.') -> #displayIcon.
		#('changes...' 'dual change sorter' 'change sets with this method' 'find a change sorter' 'recent changes in file' 'Undo / Redo history' 'code file contents' 'package file contents') -> #changesIcon.
		#('Install New Updates' 'update' 'turn on auto-update (a)' 'update list (u)' 'install code' 'fileIn entire file' 'install package') -> #updateIcon.
		#('find again (g)' 'full stack (k)') -> #systemIcon.
		#('print it (p)' 'check change set for slips') -> #printIcon.
		#('accept (s)' 'make changes go to me (m)') -> #acceptIcon.
		#('cancel (l)' 'turn off auto-update (a)') -> #cancelIcon.
		#('debug...' 'Debug it (D)' 'toggle break on entry') -> #debugIcon.
		#('close' 'close all debuggers' 'close top window') -> #closeIcon.
		#('collapse' 'hide taskbar' 'collapse all windows') -> #collapseIcon.
		#('expand / contract' 'show taskbar' 'restore all windows') -> #expandIcon.
		#('menu') -> #windowMenuIcon.
		#('browse all' 'browser' 'browse it (b)' 'MessageTally UI and browse' 'browse recent submissions' 'browse full (b)' 'find changed browsers...' 'browse (b)' 'browse my changes') -> #editFindReplaceIcon.
		#('workspace' 'workspace with contents') -> #terminalIcon.
		#('styled text editor' 'text editor'  'basic text editor'  'unicode editor' 'edit this list' 'edit postscript...' 'add postscript...') -> #textEditorIcon.
		#('file list' 'find a fileList' 'compress file') -> #systemFileManagerIcon.
		#('transcript' 'find a transcript' 'Transcript clear.' 'log to transcript') -> #printerIcon.
		#('process browser' 'vm statistics' 'MessageTally all Processes') -> #systemMonitorIcon.
		#('emergency evaluator' 'conflicts with other change sets' 'check for slips' 'conflicts with change set opposite' 'conflicts with category opposite') -> #emblemImportantIcon.
		#('change sorter') -> #halfRefreshIcon.
		#('SUnit Test Runner' 'Accept & Run Test in Class (t)' 'Accept & Run Test in Category (y)' 'Run tests (t)' 'Run tests' 'Run test (t)' 'Accept & Debug Test (r)' 'Debug test (r)') -> #weatherFewCloudsIcon.
		#('Font Sizes...' 'system fonts...' 'set font... (k)') -> #preferencesDesktopFontIcon.
		#('full screen on') -> #viewFullscreenIcon.
		#('full screen off') -> #exitFullscreenIcon.
		#('set desktop color...') -> #wallpaperIcon.
		#('preferences...' 'All preferences...' 'what to show...' 'view as hex') -> #preferencesIcon.
		#('Editor keyboard shortcuts') -> #keyboardShortcutsIcon.
		#('world menu help') -> #globeIcon.		"currently unused, but a neat icon"
		#('useful expressions' 'class comments with it' 'check for uncommented methods' 'check for uncommented classes') -> #chatIcon.
		#('set code author...' 'check for other authors' 'check for any other authors') -> #usersIcon.
		#('space left') -> #removableMediaIcon.
		#('start drawing all again' 'window color...') -> #graphicsIcon.
		#('start stepping again') -> #mediaPlaybackStartIcon.
		#('file out current change set' 'fileOut' 'File out and remove (o)' 'File out and keep (k)') -> #fileOutIcon.
		#('recently logged changes...' 'versions (v)' 'recent classes... (r)' 'trim history' 'Profile it') -> #clockIcon.
		#('senders of it (n)' 'senders of... (n)' 'local senders of...' 'senders (n)') -> #mailForwardIcon.
		#('implementors of it (m)' 'implementors of... (m)' 'implementors of sent messages') -> #developmentIcon.
		#('references to it (N)') -> #addressBookIcon.
		#('class var refs...' 'class refs (N)' 'class variables' 'class vars' 'local implementors of...' 'subclass template') -> #classIcon.
		#('inst var refs...' 'inst var defs...' 'sample instance') -> #instanceIcon.
		#('Use Selection for Find (j)' 'rename class ...' 'rename...' 'change title...') -> #saveAsIcon.
		#('smalltalk options' 'method source with it' 'browse method (O)' 'check for uncategorized methods') -> #scriptIcon.
		#('method strings with it (E)' 'Toggle WordWrap') -> #genericTextIcon.
		#('browse hierarchy (h)' 'move to top' 'promote to top of list') -> #goTopIcon.
		#('move up' 'make next-to-topmost') -> #goUpIcon.
		#('move to bottom' 'send to back' 'send top window to back') -> #goBottomIcon.
		#('inheritance (i)' 'move down') -> #goDownIcon.
		#('browse protocol (p)' 'spawn sub-protocol') -> #spreadsheetIcon.
		#('spawn full protocol') -> #speadsheetTemplateIcon.
		#('alphabetize') -> #fontXGenericIcon.
		#('Installed Packages' 'browse' 'show category (C)' 'categorize all uncategorized' 'select change set...' 'view affected class categories') -> #packageIcon.
		#('remove from current change set' 'remove empty categories' 'subtract other side (-)' 'remove from this browser') -> #listRemoveIcon.
		#('add to current change set' 'add all meths to current chgs' 'add preamble (p)' 'More...') -> #listAddIcon.
		#('toggle diffing (D)' 'toggle selections') -> #switchIcon.
		#('reorganize' 'create inst var accessors' 'ChangeSorter reorderChangeSets.' 'reorder all change sets' 'by name' 'by size' 'by date') -> #sendReceiveIcon.
		#('unsent methods' 'unreferenced class vars' 'unreferenced inst vars' 'Undeclared inspect.' 'Undeclared removeUnreferencedKeys; inspect.' 'ChangeSorter removeEmptyUnnamedChangeSets.' 'check for unsent messages') -> #junkIcon.
		#('find changed windows...') -> #newWindowIcon.
		#('make undraggable') -> #pushPinIcon.
		#('Utilities saveScreenshot.') -> #stillCameraIcon.
		#('add new directory') -> #newFolderIcon.
		#('select all' 'deselect all') -> #selectAllIcon.
		#('sort by date') -> #dateIcon.
		#('justified') -> #formatJustifyFillIcon.
		#('centered') -> #formatJustifyCenterIcon.
		#('set alignment...' 'leftFlush') -> #formatJustifyLeftIcon.
		#('rightFlush') -> #formatJustifyRightIcon.
		#('signal Semaphore (S)') -> #haloHelpIcon.
		#('Change Paragraph Style...' 'Change Character Style...' 'Remove Character Style' 'Replace all uses of Paragraph Style...' 'Replace all uses of Character Style...' 'Set Default Font...') -> #fontXGenericIcon.
		#('Clear Font') -> #newIcon.
		#('code file browser' 'package file browser') -> #findIcon.
	}! !

!Theme methodsFor: 'keyboard shortcuts' stamp: 'jmv 8/29/2017 15:53:47'!
                    keyStroke: aKeyboardEvent morph: aMorph
	aKeyboardEvent controlKeyPressed ifTrue: [^false].
	aKeyboardEvent commandAltKeyPressed ifFalse: [^false].

	aKeyboardEvent keyValue = $w numericValue ifTrue: [
		aMorph owningWindow ifNotNil: [ :w |
			(w morphContainsPoint: (w internalizeFromWorld: aKeyboardEvent eventPosition)) ifTrue: [
				w delete. 
				^true ]	]].
"	aKeyboardEvent keyValue = $f numericValue
		ifTrue: [aMorph owningWindow ifNotNil: [ :w | w fullScreen. ^true ]].
"
	^ false! !


Theme class
	instanceVariableNames: ''!

!Theme class methodsFor: 'class initialization' stamp: 'jmv 3/26/2017 23:25:17'!
                      currentTheme: aTheme

	CurrentTheme := aTheme new.
	SHTextStylerST80 initialize.
	self runningWorld ifNotNil: [ :w |
		w backgroundImage ifNil: [
			w color: CurrentTheme background ]].
	SystemWindow initialize.
	BitBltCanvas releaseClassCachedState.
	self runningWorld ifNotNil: [ :w |
		CurrentTheme useTaskbar
			ifTrue: [w showTaskbar]
			ifFalse: [w hideTaskbar].
		w restoreMorphicDisplay ].
	
	^ CurrentTheme! !


Time class
	instanceVariableNames: ''!

!Time class methodsFor: 'primitives' stamp: 'jmv 3/7/2017 09:52:37'!
              primMillisecondClock
	"Primitive. Answer the number of milliseconds since the millisecond clock
	was last reset or rolled over. No sync to any system clock.
	Implemented by all major platforms.
	Essential. See Object documentation whatIsAPrimitive. 
	
	Time primMillisecondClock
	Time primMillisecondClock / 1000 / 60.0

	Range is  from zero to 16r1FFFFFFF.
	The VM defines MillisecondClockMask as 16r1FFFFFFF

	Overflows usually every six days.
	Still used in #localMillisecondClock if the VM doesn't implement
		Time primLocalMicrosecondClock
	"
"Not really a clock, but a timer or ticker"

	<primitive: 135>
	self primitiveFailed! !

!Time class methodsFor: 'primitives' stamp: 'jmv 3/7/2017 12:16:43'!
                              primUtcMicrosecondClock
	"Answer the number of microseconds since the UTC Smalltalk epoch, 
	i.e. 00:00 on the morning of January 1, 1901, the start of the 20th century, in UTC time.
	 The value is derived from the Posix epoch with a constant offset corresponding to elapsed microseconds
	 between the two epochs according to RFC 868.
	Answer is (at least usually) a  LargePositiveInteger
	Cog VMs implement this. Interpreters might not."
	"
	Time primUtcMicrosecondClock
	Time primUtcMicrosecondClock/ 1000 / 1000 / 60 / 60 / 24 / 365.25

	(Time primUtcMicrosecondClock / 1000 / 1000 + Time primUtcWithOffset second) / 60 / 60 / 24 / 365.25
	(DateAndTime now - (DateAndTime year: 1901 month: 1 day: 1)) totalSeconds / 60 / 60 / 24 / 365.25
	"
	<primitive: 240>
	^nil! !


Object subclass: #Timespan
	instanceVariableNames: 'start duration'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Chronology'!

!Timespan methodsFor: 'ansi protocol' stamp: 'pb 9/13/2017 06:20:49'!
  - aDurationOrTimespan

	^ aDurationOrTimespan subtractFrom: self! !

!Timespan methodsFor: 'squeak protocol' stamp: 'jmv 5/13/2017 11:13:39'!
                  includes: operand
	"Operand might be a Timespan or a DateAndtime"

	^ (operand is: #Timespan)
			ifTrue: [ (self includes: operand start)
						and: [ self includes: operand end ] ]
			ifFalse: [ operand between: start and: self end ]! !

!Timespan methodsFor: 'private' stamp: 'pb 9/13/2017 06:18:08'!
                 subtractDuration: aDuration

	^self class classDefinesDuration
		ifTrue: [ self class including: start - aDuration ]
		ifFalse: [ self class starting: start - aDuration duration: duration ]! !

!Timespan methodsFor: 'private' stamp: 'jmv 9/18/2017 18:27:11'!
                             subtractMonth: aYear

	^ self subtractTimespan: aYear! !

!Timespan methodsFor: 'private' stamp: 'jmv 9/18/2017 18:29:20'!
     subtractTimespan: aTimespan
	"
	(Month month: 'March' year: 2017) - (Month month: 'January' year: 2017)
	(Month month: 'February' year: 2017) - (Month month: 'January' year: 2017)

	(Year yearNumber: 2016) - (Year yearNumber: 2015).
	(Year yearNumber: 2017) - (Year yearNumber: 2016).
	(Year yearNumber: 2017) - (Year yearNumber: 2015).

	(Year yearNumber: 2018) - (Date today). 					'Error'.
	"
	aTimespan duration = self duration ifFalse: [
		self error: 'Can not subtract Timespans of different duration' ].
	
	^self start subtractDateAndtime: aTimespan start! !

!Timespan methodsFor: 'private' stamp: 'jmv 9/18/2017 17:22:56'!
        subtractYear: aYear

	^ self subtractTimespan: aYear! !

!Timespan methodsFor: 'double dispatching' stamp: 'jmv 5/12/2017 17:17:18'!
                           includingTimespanOf: aTimespanClass

	^ aTimespanClass includingTimespan: self! !

!Timespan methodsFor: 'double dispatching' stamp: 'pb 9/13/2017 06:21:26'!
  subtractFrom: aTimespan

	^ aTimespan subtractTimespan: self! !


Timespan class
	instanceVariableNames: ''!

!Timespan class methodsFor: 'squeak protocol' stamp: 'jmv 5/9/2017 19:54:38'!
    fromString: aString
	"Please call with specific subclass."

	^ self readFrom: aString readStream! !

!Timespan class methodsFor: 'instance creation' stamp: 'jmv 5/12/2017 17:18:23'!
          including: aDateAndTime

	^ aDateAndTime includingTimespanOf: self! !

!Timespan class methodsFor: 'instance creation' stamp: 'jmv 5/12/2017 16:48:47'!
        includingDateAndTime: aDateAndTime

	^ self starting: aDateAndTime duration: Duration zero! !

!Timespan class methodsFor: 'instance creation' stamp: 'jmv 5/13/2017 11:12:44'!
                includingTimespan: aTimespan

	| ending starting |
	starting _ self includingDateAndTime: aTimespan start.
	ending _ self includingDateAndTime: aTimespan end.
	starting = ending ifTrue: [ ^ starting ].
	self error: aTimespan printString, ' can not be included in a ', self name! !


Transcript class
	instanceVariableNames: 'entries firstIndex lastIndex accessSemaphore unfinishedEntry logToFile showOnDisplay lastDisplayPosition bounds'!

!Transcript class methodsFor: 'displaying' stamp: 'jmv 9/19/2016 20:45:55'!
                            displayOn: aForm in: aRectangle
	"
	Transcript displayOn: Display
	"
	| font count i string x y fh f canvas innerR |
	aForm fill: aRectangle fillColor: Color white.
	font _ AbstractFont default.

	innerR _ aRectangle insetBy: self padding.
	fh _ font height.
	count _ innerR height // fh-1.
	x _ innerR left.
	y _ innerR top.
	f _ firstIndex-1.
	firstIndex > lastIndex ifTrue: [ f _ f - self maxEntries ].
	i _ (lastIndex - count max: f) \\ self maxEntries + 1.
	canvas _ aForm getCanvas.
	canvas newClipRect: innerR.
	[
		string _ entries at: i.	
		canvas drawString: string at: x@y font: font color: Color veryDarkGray.
		y _ y + fh.
		i = lastIndex
	] whileFalse: [ i _ i \\ self maxEntries + 1 ].

	string _ unfinishedEntry contents.
	canvas drawString: string at: x@y font: font color: Color veryDarkGray! !

!Transcript class methodsFor: 'displaying' stamp: 'jmv 9/19/2016 20:53:35'!
      displayUnfinishedEntryOn: aForm

	| font count string x y fh canvas r innerR |
	innerR _ bounds insetBy: self padding.
	lastDisplayPosition < innerR right ifTrue: [
		font _ AbstractFont default.
		fh _ font height.
		count _ innerR height // fh-1.
		x _ innerR left.
		string _ unfinishedEntry contents.
		y _ ((lastIndex - firstIndex \\ self maxEntries) min: count-1) + 1 * font height + innerR top.
		canvas _ aForm getCanvas.
		r _ innerR left: lastDisplayPosition.
		canvas newClipRect: r.
		(canvas drawString: string at: x@y font: font color: Color veryDarkGray) ifNotNil: [ :lastPoint |
			lastDisplayPosition _ lastPoint x.
			^r ]].
	^nil! !


RectangleLikeMorph subclass: #TranscriptMorph
	instanceVariableNames: 'form workspace lastIncludedIndex workspaceWindow lastUnfinishedEntrySize doImmediateUpdates'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!TranscriptMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:58:30'!
                         drawOn: aCanvas
	Transcript
		showOnDisplay: true;
		displayOn: form in: (`0@0` extent: extent).
	aCanvas image: form at: `0@0`.
	Transcript
		bounds: self morphBoundsInWorld;
		showOnDisplay: doImmediateUpdates.
	self updateWorkspace! !


ReadWriteStream subclass: #Transcripter
	instanceVariableNames: 'frame textComposition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

!Transcripter methodsFor: 'accessing' stamp: 'jmv 6/19/2017 16:13:36'!
endEntry
	| c d cb |
	c _ self contents.
	Display extent ~= DisplayScreen actualScreenSize ifTrue: [
		"Handle case of user resizing physical window"
		DisplayScreen startUp.
		frame _ frame intersect: Display boundingBox.
		^ self clear; show: c].
	textComposition
		setModel: (TextModel withText: c asText);
		extentForComposing: frame width-8 @9999.
	textComposition composeAll.
	d _ textComposition usedHeight - frame height.
	d > 0 ifTrue: [
		"Scroll up to keep all contents visible"
		cb _ textComposition characterBlockAtPoint:
			`0@0` + (0@(d+AbstractFont default height)).
		self on: (c copyFrom: cb stringIndex to: c size).
		readLimit _ position _ collection size.
		^ self endEntry].
	Display fill: (frame insetBy: -2) fillColor: self black;
			fill: frame fillColor: self white.
	Display getCanvas
		textComposition: textComposition
		bounds: (`4@4` + frame topLeft extent: Display extent)
		color: Color black
		selectionColor: Color blue.
	DisplayScreen screenUpdateRequired: nil! !

!Transcripter methodsFor: 'private' stamp: 'di 8/14/97 12:12'!
                        black
	Display depth = 1 ifTrue: [^ Bitmap with: 16rFFFFFFFF "Works without color support"].
	^ Color black! !

!Transcripter methodsFor: 'private' stamp: 'di 8/14/97 12:12'!
                 white
	Display depth = 1 ifTrue: [^ Bitmap with: 0 "Works without color support"].
	^ Color white! !


Transcripter class
	instanceVariableNames: ''!

!Transcripter class methodsFor: 'instance creation' stamp: 'dhn 2/6/2017 13:38:40'!
                     newInFrame: frame
"
(Transcripter newInFrame: (0@0 extent: 100@200))
	nextPutAll: 'Hello there'; endEntry;
	newLine; print: 355.0/113; endEntry;
	readEvalPrint.
"
	| transcript |
	transcript _ self on: (String new: 100).
	transcript initInFrame: frame.
	^ transcript clear! !

!Transcripter class methodsFor: 'utilities' stamp: 'jmv 6/19/2017 15:58:42'!
                              emergencyEvaluator
	(Transcripter newInFrame: `0@0 corner: 320@200`)
		show: 'Type ''exit'' to exit the emergency evaluator.';
		readEvalPrint! !


Color variableWordSubclass: #TranslucentColor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Primitives'!

!TranslucentColor methodsFor: 'accessing' stamp: 'jmv 6/18/2017 20:41:17'!
       alpha
	"Return my alpha value, a number between 0.0 and 1.0 where 0.0 is completely transparent and 1.0 is completely opaque."

	^ self at: 4! !

!TranslucentColor methodsFor: 'printing' stamp: 'jmv 1/5/2014 21:06'!
        storeArrayValuesOn: aStream

	self isTransparent ifTrue: [
		^ aStream space].
	super storeArrayValuesOn: aStream.
	aStream space.
	self alpha printOn: aStream fractionDigits: 3! !

!TranslucentColor methodsFor: 'printing' stamp: 'jmv 1/5/2014 21:20'!
    storeOn: aStream

	self isTransparent ifTrue: [^ aStream nextPutAll: '(Color transparent)'].
	aStream
		nextPut: $(;
		nextPutAll: self class name;
		nextPutAll: ' r: '.
	self red printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ' g: '.
	self green printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ' b: '.
	self blue printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ' alpha: '.
	self alpha printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ')'! !

!TranslucentColor methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:55:03'!
                    alpha: alphaValue
	"Return a new TranslucentColor with the given amount of opacity ('alpha')."
	alphaValue = 1.0 ifTrue: [
		^ Color new
			setRed: self red
			green: self green
			blue: self blue].
	^ super alpha: alphaValue! !

!TranslucentColor methodsFor: 'conversions' stamp: 'sw 10/27/1999 10:51'!
                asNontranslucentColor
	^ self alpha: 1.0! !

!TranslucentColor methodsFor: 'conversions' stamp: 'jmv 4/19/2013 16:10'!
         bitPatternForDepth: depth
	"Return an appropriate bit pattern. This will almost never be meaningful for tranlucentColors, except for the degenerate case of tranparency."

	self isTransparent ifTrue: [
		^ Bitmap with: 0].
	^ super bitPatternForDepth: depth! !

!TranslucentColor methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:41:47'!
              pixelValueForDepth: d
	"Return the pixel value for this color at the given depth. Translucency only works in RGB; this color will appear either opaque or transparent at all other depths."
	| basicPixelWord |
	"In 32bpp, if alpha = 0, ignore any color components, and answer R=0, G=0, B=0, Alpha=0.
	In depths > 8 and < 32, pixelValue zero is the special value used by BitBlt to denote transparent."
	self isTransparent ifTrue: [
		^ 0].
	basicPixelWord _ super pixelValueForDepth: d.
	^d < 32
		ifTrue: [ basicPixelWord ]
		ifFalse: [ (basicPixelWord bitAnd: 16rFFFFFF) bitOr:
			((self alpha*255.0) rounded
				bitShift: 24) ]! !

!TranslucentColor methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:41:50'!
                           pixelWordForDepth: depth
	"Return the pixel value for this color at the given depth. Translucency only works in RGB; this color will appear either opaque or transparent at all other depths."

	| basicPixelWord |
	self isTransparent ifTrue: [^ 0].
	basicPixelWord _ super pixelWordForDepth: depth.
	^depth < 32
		ifTrue: [ basicPixelWord ]
		ifFalse: [ (basicPixelWord bitAnd: 16rFFFFFF) bitOr:
			((self alpha*255.0) rounded
				bitShift: 24) ]! !

!TranslucentColor methodsFor: 'private' stamp: 'jmv 6/18/2017 20:42:05'!
                      setRed: r green: g blue: b alpha: alphaValue

	self basicSetRed: r green: g blue: b.
	self at: 4 put: alphaValue! !

!TranslucentColor methodsFor: 'queries' stamp: 'jmv 6/18/2017 20:41:26'!
  isOpaque

	^self alpha = 1.0! !

!TranslucentColor methodsFor: 'queries' stamp: 'jmv 6/18/2017 20:41:54'!
                      isTransparent
	^ self alpha = 0.0! !

!TranslucentColor commentStamp: '<historical>' prior: 0!
 A TranslucentColor behaves just like a normal color, except that it will pack its alpha value into the fourth position.  This allows creating forms with translucency for use with the alpha blend function of BitBlt.  An alpha of zero is transparent, and 1.0 is opaque.!

TranslucentColor class
	instanceVariableNames: ''!

!TranslucentColor class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:54:35'!
     new
	^ self new: 4! !

!TranslucentColor class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:57:08'!
                r: r g: g b: b alpha: alphaValue
	"Return a color with the given r, g, and b components in the range [0.0..1.0]."

	^ self new
		setRed: r
		green: g
		blue: b
		alpha: alphaValue! !


Warning subclass: #UndeclaredVariableWarning
	instanceVariableNames: 'name selector class'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Support'!

!UndeclaredVariableWarning methodsFor: 'accessing' stamp: 'HAW 9/13/2017 15:16:19'!
          classImplementingSelector

	^class ! !

!UndeclaredVariableWarning methodsFor: 'accessing' stamp: 'HAW 9/13/2017 15:15:44'!
    selector

	^selector ! !

!UndeclaredVariableWarning methodsFor: 'accessing' stamp: 'HAW 9/13/2017 15:15:34'!
                  variableName

	^name ! !


Object subclass: #UndefinedObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Objects'!

!UndefinedObject methodsFor: 'class hierarchy' stamp: 'HAW 2/10/2017 17:37:23'!
            allSuperclassesUpTo: aSuperclass 

	self error: (self superclassNotValidErrorDescriptionFor: aSuperclass)! !

!UndefinedObject methodsFor: 'class hierarchy' stamp: 'HAW 2/10/2017 17:37:30'!
  superclassNotValidErrorDescriptionFor: aClass 

	^aClass name, ' not in superclasses chain'! !


StringMorph subclass: #UpdatingStringMorph
	instanceVariableNames: 'target getSelector stepTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!UpdatingStringMorph methodsFor: 'accessing' stamp: 'jmv 1/4/2013 13:15'!
       getSelector: aSymbol
	getSelector _ aSymbol! !

!UpdatingStringMorph methodsFor: 'accessing' stamp: 'jmv 1/4/2013 13:18'!
      stepTime

	^stepTime! !

!UpdatingStringMorph methodsFor: 'accessing' stamp: 'jmv 1/4/2013 13:15'!
                             stepTime: aNumber
	stepTime _ aNumber! !

!UpdatingStringMorph methodsFor: 'accessing' stamp: 'jmv 1/4/2013 13:15'!
            target: anObject
	target _ anObject! !

!UpdatingStringMorph methodsFor: 'initialization' stamp: 'jmv 9/13/2013 09:23'!
        initialize
	super initialize.
	target _ self.
	getSelector _ #contents.
	stepTime _ 50! !

!UpdatingStringMorph methodsFor: 'stepping' stamp: 'pb 7/15/2017 22:07:40'!
                         stepAt: millisecondSinceLast

	self contents: (target perform: getSelector) asString! !

!UpdatingStringMorph methodsFor: 'stepping' stamp: 'jmv 1/4/2013 13:18'!
                              wantsSteps
	"Return true if the receiver wants to its #step or #stepAt: methods be run"

	^true! !

!UpdatingStringMorph methodsFor: 'geometry' stamp: 'jmv 1/15/2017 14:25:27'!
               fitContents
	"Don't shrink each time contents change.
	Might shrink during layout"
	self morphExtent: (extent max: self measureContents)! !

!UpdatingStringMorph commentStamp: 'jmv 1/5/2013 23:49' prior: 0!
                 UpdatingStringMorph new
     target: [self runningWorld activeHand morphPosition asString];
     getSelector: #value;
     stepTime: 10;
     openInWorld!

UpdatingStringMorph class
	instanceVariableNames: ''!

!UpdatingStringMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/9/2017 00:04:50'!
             categoryInNewMorphMenu
	^ 'Widgets'! !

!UpdatingStringMorph class methodsFor: 'new-morph participation' stamp: 'jmv 9/25/2017 20:44:33'!
                      initializedInstance
	"Answer a digital clock"

	| newInst |
	newInst := self 
		contents: '' 
		font: (AbstractFont familyName: Preferences defaultFontFamily pointSize: 22) 
		emphasis: AbstractFont  boldCode.
	newInst 
		stepTime: 500; "half a second"
		target: [String streamContents: [ :strm | DateAndTime now printHMSOn: strm]] ;
		getSelector: #value.
		
	^ newInst! !


Utilities class
	instanceVariableNames: ''!

!Utilities class methodsFor: 'user interface' stamp: 'jmv 7/17/2017 15:48:35'!
            informUserDuring: barBlock 
	"Display a message above (or below if insufficient room) the cursor during execution of the given block."

	"Utilities informUserDuring:[:barBlock|
		#(one two three) do:[:info|
			barBlock value: info.
			(Delay forSeconds: 1) wait]]"

	(MVCMenuMorph from: (SelectionMenu labels: '') title: '						') 
				informUserAt: Sensor mousePoint
				during: barBlock! !


BitBlt subclass: #WarpBlt
	instanceVariableNames: 'p1x p1y p1z p2x p2y p2z p3x p3y p3z p4x p4y p4z cellSize sourceRGBmap'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Primitives'!

!WarpBlt methodsFor: 'setup' stamp: 'mtf 8/14/2009 18:21'!
                cellSize: s
	"Set the number of samples used for averaging"
	cellSize := s.
	cellSize = 1 ifTrue: [^ self].
	"Install the colorMap to used for mapping the averaged RGBA 32bit pixels to the
	destination depth. Note that we need to install the 32->32 color map explicitly because
	the VM will substitute a colorMap derived from sourceForm->destForm mapping which
	is just plain wrong for <32 source and 32bit dest depth"
	(destForm depth = 32 and: [sourceForm notNil] and: [sourceForm depth < 32])
		ifTrue:[colorMap := ColorMap shifts: #(0 0 0 0) masks:#(16rFF0000 16rFF00 16rFF 16rFF000000) colors: nil]
		ifFalse:[colorMap := Color colorMapIfNeededFrom: 32 to: destForm depth].
! !


WeakArray class
	instanceVariableNames: ''!

!WeakArray class methodsFor: 'class initialization' stamp: 'jmv 1/6/2017 09:49:16'!
                  initialize
	"
	WeakArray initialize.
	SystemDictionary initialize.
	"

	self restartFinalizationProcess! !

!WeakArray class methodsFor: 'system startup' stamp: 'jmv 1/6/2017 09:56:14'!
      startUp
	"Do it even if just continuing after image snapshot"
	self restartFinalizationProcess! !


Timespan subclass: #Week
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Chronology'!

!Week methodsFor: 'squeak protocol' stamp: 'jmv 5/13/2017 14:38:20'!
                    printOn: aStream
	"
		'2008-W52' asWeek.
		'2009-W01' asWeek
		'2009-W02' asWeek
		'2009-W53' asWeek
		'2010-W01' asWeek
		'2010-W02' asWeek
	"
	self yearNumber printOn: aStream.
	aStream nextPutAll: '-W'.
	self weekNumber printOn: aStream length: 2 zeroPadded: true! !

!Week methodsFor: 'public protocol' stamp: 'jmv 5/13/2017 14:37:37'!
            weekNumber

	| thursday |
	thursday _ self start + 3 days.
	^thursday dayOfYear-1 // 7 + 1! !

!Week methodsFor: 'public protocol' stamp: 'jmv 5/13/2017 14:37:18'!
                            yearNumber

	| thursday |
	thursday _ self start + 3 days.
	^thursday yearNumber! !


Week class
	instanceVariableNames: ''!

!Week class methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 18:05:57'!
                       includingDateAndTime: aDateAndTime
	"
	Week including: '12 May 2017 ' asDate start
	(Week including: '12 May 2017 ' asDate start) start dayOfWeekName = #Monday 
	"

	| midnight weekStart |
	midnight _ aDateAndTime midnight.
	weekStart _ midnight - (midnight dayOfWeek - 1) days.

	^ self basicNew
 		start: weekStart;
		duration: (Duration weeks: 1);
		yourself! !

!Week class methodsFor: 'squeak protocol' stamp: 'jmv 5/13/2017 14:59:27'!
       indexOfDay: aSymbol
	"
	(Week indexOfDay: #Sunday) = 7
	(Week nameOfDay: 7) = #Sunday 
	"

	^ self dayNames indexOf: aSymbol! !

!Week class methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 17:48:37'!
                    readFrom: aStream 
	"Read a Week from the stream in any of the forms:  
		<year>-W<week>			(2009-W01) (ISO8601)"
	| weekNumber yearNumber firstAsNumber firstAsNumberSign |
	firstAsNumberSign := aStream peek = $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	aStream peek isDigit ifTrue: [
		firstAsNumber := (Integer readFrom: aStream) * firstAsNumberSign.
		(firstAsNumber < 0 or: [firstAsNumber > 12])
			ifTrue: [yearNumber := firstAsNumber]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	aStream next = $W ifFalse: [
		self error: 'Invalid Format' ].

	weekNumber _ Integer readFrom: aStream.
	weekNumber < 1 ifTrue: [ self error: 'Invalid Format' ].
	(yearNumber < 100 and: [yearNumber >= 0])  ifTrue: [
		yearNumber _ yearNumber < 69 
			ifTrue: [2000 + yearNumber]
			ifFalse: [1900 + yearNumber]].

	^ self yearNumber: yearNumber weekNumber: weekNumber! !

!Week class methodsFor: 'squeak protocol' stamp: 'jmv 5/13/2017 10:54:55'!
                     yearNumber: yearNumber weekNumber: weekNumber

	| firstOfJanuary firstThursday thisThursday |
	firstOfJanuary _ DateAndTime year: yearNumber month: 1 day: 1.
	firstThursday _ firstOfJanuary + (4 - firstOfJanuary dayOfWeek \\ 7) days.
	thisThursday _ firstThursday + ((weekNumber-1) * 7) days.

	thisThursday yearNumber = yearNumber
		ifFalse: [ self error: 'Week does not exist' ].

	^ self including: thisThursday! !

!Week class methodsFor: 'smalltalk-80' stamp: 'jmv 5/12/2017 10:53:55'!
                     nameOfDay: anIndex
	"
	Week indexOfDay: #Sunday = 7
	Week nameOfDay: 7 = #Sunday 
	"

	^ self dayNames at: anIndex! !

!Week class methodsFor: 'inquiries' stamp: 'jmv 5/10/2017 22:25:02'!
    dayNames

	^ #(Monday Tuesday Wednesday Thursday Friday Saturday Sunday)! !


ArrayedCollection variableWordSubclass: #WordArray
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Arrayed'!

!WordArray methodsFor: 'accessing' stamp: 'jmv 5/31/2017 09:48:37'!
               bytesAt: index
	"Answer a ByteArray of 4 elements.
	The 32-bit word is split in 4 bytes, in little endian format
	WordArray with: 16rFF32791B :: bytesAt: 1 :: hex
	"

	| bytes word |
	bytes _ ByteArray new: 4.
	word _ self at: index. "Usually a SmallInteger, but may be a Large Integer in 32-bit images"
	1 to: 4 do: [ :i | bytes at: i put: (word digitAt: i) ].
	^ bytes! !

!WordArray methodsFor: 'accessing' stamp: 'jmv 5/31/2017 09:53:07'!
     bytesAt: index put: aByteArray
	"Takes a ByteArray of 4 elements.
	Store the 32-bit word made with those byes, in little endian format
	WordArray new: 1 :: bytesAt: 1 put: #[16r1B 16r79 16r32 16rFF] :: first hex
	"

	| word |
	word _ 0.
	4 to: 1 by: -1 do: [ :i | word _ word * 256 + (aByteArray at: i) ].
	self at: index put: word! !

!WordArray methodsFor: 'private' stamp: 'jmv 1/13/2017 09:58:38'!
              replaceFrom: start to: stop with: replacement startingAt: repStart 

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart ! !


TextModel subclass: #Workspace
	instanceVariableNames: 'bindings mustDeclareVariables shouldStyle'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!Workspace methodsFor: 'shout styling' stamp: 'jmv 8/26/2017 19:21:53'!
                           shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text."

	self shouldStyle ifFalse: [ ^false ].
	anSHTextStyler 
		classOrMetaClass: nil;
		workspace: self.
	^true! !

!Workspace methodsFor: 'testing' stamp: 'jmv 8/18/2017 17:42:35'!
                          is: aSymbol
	^ aSymbol == #providesBindings or: [ super is: aSymbol ]! !


Object subclass: #WorldState
	instanceVariableNames: 'hands viewBox canvas damageRecorder stepList lastStepTime lastStepMessage lastCycleTime alarms lastAlarmTime remoteServer drawingFailingMorphs waitDelay pause lastCycleHadAnyEvent activeHand world'
	classVariableNames: 'DeferredUIMessages'
	poolDictionaries: ''
	category: 'Morphic-Worlds'!

!WorldState methodsFor: 'alarms' stamp: 'jmv 3/3/2017 09:33:59'!
                          addAlarm: aSelector withArguments: argArray for: aTarget at: scheduledTime
	"Add a new alarm with the given set of parameters"

	alarms add: 
		(MorphicAlarm 
			receiver: aTarget
			selector: aSelector
			arguments: argArray
			at: scheduledTime)! !

!WorldState methodsFor: 'alarms' stamp: 'jmv 3/3/2017 09:34:03'!
   adjustAlarmTimes: nowTime
	"Adjust the alarm times after some clock weirdness (such as image-startup etc)"
	| deltaTime |
	deltaTime _ nowTime - lastAlarmTime.
	alarms do: [ :alarm |
		alarm scheduledTime: alarm scheduledTime + deltaTime ]! !

!WorldState methodsFor: 'alarms' stamp: 'jmv 3/3/2017 11:54:00'!
           removeAlarm: aSelector for: aTarget 
	"Remove the alarm with the given selector"

	| alarm |
	alarm _ alarms 
				detect: [ :any | any receiver == aTarget and: [any selector == aSelector]]
				ifNone: nil.
	alarm ifNotNil: [ alarms remove: alarm ]! !

!WorldState methodsFor: 'alarms' stamp: 'jmv 3/3/2017 09:35:03'!
   triggerAlarmsBefore: nowTime
	"Trigger all pending alarms that are to be executed before nowTime."

	nowTime - lastAlarmTime > 10000
		ifTrue: [ self adjustAlarmTimes: nowTime ].
	[ alarms notEmpty and: [ alarms first scheduledTime < nowTime ]]
		whileTrue: [ alarms removeFirst valueAtTime: nowTime ].
	lastAlarmTime _ nowTime! !

!WorldState methodsFor: 'canvas' stamp: 'jmv 1/17/2017 10:57:47'!
                  ensureNonDisplayCanvas
	(canvas isNil or: [
		canvas drawsOnDisplay or: [
		(canvas extent ~= world morphExtent) or: [
		canvas form depth ~= Display depth]]]) ifTrue: [
			"allocate a new offscreen canvas the size of the window"
			self setCanvas: (BitBltCanvas withExtent: world morphExtent depth: Display depth)]! !

!WorldState methodsFor: 'initialization' stamp: 'jmv 6/20/2014 20:24:55'!
                      clearWaitDelay
	waitDelay ifNotNil: [
		waitDelay unschedule.
		waitDelay _ nil ].
	"Needed if for some reason Cuis is started with an earlier DateTime than the image was saved.
	Might happen, especially on RasPi or other systems without an RTC"
	lastCycleTime _ Time localMillisecondClock.
	lastAlarmTime _ 0.! !

!WorldState methodsFor: 'initialization' stamp: 'jmv 3/3/2017 09:33:53'!
                            initialize

	activeHand _ HandMorph new.
	hands _ { activeHand }.
	damageRecorder _ DamageRecorder new.
	stepList _ Heap sortBlock: self stepListSortBlock.
	alarms _ Heap sortBlock: self alarmSortBlock.
	lastAlarmTime _ 0.
	drawingFailingMorphs _ WeakIdentitySet new.
	pause _ 20.
	lastCycleTime _ Time localMillisecondClock.
	lastCycleHadAnyEvent _ false! !

!WorldState methodsFor: 'stepping' stamp: 'jmv 3/3/2017 11:51:16'!
                     cleanseStepList
	"Remove morphs from the step list that are not in this World."

	| deletions |
	deletions _ OrderedCollection new.
	stepList do: [ :entry |
		entry receiver world == world ifFalse: [
			deletions add: entry]].
	deletions do: [ :entry|
		stepList remove: entry ].

	deletions _ OrderedCollection new.
	alarms do: [ :entry |
		((entry receiver is: #Morph) and: [ entry receiver world == world ]) ifFalse: [
			deletions add: entry]].
	deletions do: [ :entry|
		alarms remove: entry ]! !

!WorldState methodsFor: 'stepping' stamp: 'jmv 3/3/2017 09:46:37'!
      runStepMethods
	"Perform periodic activity inbetween event cycles"
	| queue msg |

	queue _ self class deferredUIMessages.
	[ (msg _ queue nextOrNil) isNil ] whileFalse: [
		msg value
	].
	self triggerAlarmsBefore: lastCycleTime.
	self runLocalStepMethods: lastCycleTime.

	"we are using a normal #step for these now"
	"aWorld allLowerWorldsDo: [ :each | each runLocalStepMethods ]."
! !

!WorldState methodsFor: 'stepping' stamp: 'jmv 3/3/2017 11:39:34'!
                        stopStepping: aMorph selector: aSelector
	"Remove the given morph from the step list."
	stepList removeAll: (stepList select:[:stepMsg| stepMsg receiver == aMorph and: [ stepMsg selector == aSelector ]])! !

!WorldState methodsFor: 'stepping' stamp: 'jmv 3/3/2017 11:39:22'!
             stopSteppingMorph: aMorph
	"Remove the given morph from the step list."
	stepList removeAll: (stepList select: [ :stepMsg | stepMsg receiver == aMorph])! !

!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/2/2017 19:34:41'!
                            displayWorldSafely
	"Update this world's display and keep track of errors during draw methods."

	[world displayWorld] ifError: [:err :rcvr |
		"Handle a drawing error"
		| errCtx errMorph |
		errCtx _ thisContext.
		[
			errCtx _ errCtx sender.
			"Search the sender chain to find the morph causing the problem"
			[errCtx notNil and: [ (errCtx receiver is: #Morph) not ]] 
				whileTrue:[errCtx _ errCtx sender].
			"If we're at the root of the context chain then we have a fatal drawing problem"
			errCtx ifNil:[^self handleFatalDrawingError: err].
			errMorph _ errCtx receiver.
			"If the morph causing the problem has already the #drawError flag set,
			then search for the next morph above in the caller chain."
			errMorph isKnownFailing
		] whileTrue.
		errMorph drawingFails.
		self clearCanvas.
		"Install the old error handler, so we can re-raise the error"
		rcvr error: err.
	]! !

!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/5/2017 00:38:27'!
                        doOneCycle
	"Do one cycle of the interaction loop. This method is called repeatedly when the world is running.
	
	Make for low cpu usage if the ui is inactive, but quick response when ui is in use.
	However, after some inactivity, there will be a larger delay before the ui gets responsive again."

	| wait waitUntil |
	waitDelay ifNil: [ waitDelay _ Delay forMilliseconds: 50 ].
	lastCycleHadAnyEvent
		ifTrue: [
			pause _ 20.				"This value will only be used when there are no more events to serve."
			wait _ 0 ]					"Don't wait"
		ifFalse: [
			pause < 200				"No events processed? Start saving CPU!! But never make the user wait more than 200ms for being responsive again."
				ifTrue: [ pause _ pause * 21//20 ].
			waitUntil _ lastCycleTime + pause.
			"Earlier if steps"
			stepList isEmpty not ifTrue: [
				waitUntil _ waitUntil min: stepList first scheduledTime ].
			"Earlier if alarms"
			alarms ifNotNil: [
				alarms isEmpty not ifTrue: [
					waitUntil _ waitUntil min: alarms first scheduledTime ]].

			wait _ waitUntil - Time localMillisecondClock ].
	Preferences serverMode
		ifTrue: [ wait _ wait max: 50 ].	"Always wait at least a bit on servers, even if this makes the UI slow."
	wait > 0
		ifFalse: [ Processor yield ]
		ifTrue: [
			waitDelay beingWaitedOn
				ifFalse: [ waitDelay setDelay: wait; wait ]
				ifTrue: [
					"If we are called from a different process than that of the main UI, we might be called in the main
					interCyclePause. In such case, use a new Delay to avoid 'This Delay has already been scheduled' errors"
					(Delay forMilliseconds: wait) wait ]].

	"Record start time of this cycle, and do cycle"
	lastCycleTime _ Time localMillisecondClock.
	lastCycleHadAnyEvent _ self doOneCycleNow! !

!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/3/2017 09:21:41'!
        doOneCycleNow
	"Immediately do one cycle of the interaction loop."

	| hadAnyEvent |
	"See #eventTickler"
	Cursor currentCursor = Cursor wait ifTrue: [
		Cursor normal activateCursor ].

	"Repair visual damage."
	DisplayScreen checkForNewScreenSize.
	self displayWorldSafely.

	"Run steps, alarms and deferred UI messages"
	self runStepMethods.

	"Process user input events. Run all event triggered code."
	hadAnyEvent _ false.
	self handsDo: [ :h |
		activeHand _ h.
		hadAnyEvent _ hadAnyEvent | h processEventQueue.
		activeHand _ nil ].

	"The default is the primary hand"
	activeHand _ self hands first.


	^hadAnyEvent! !

!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/2/2017 20:06:48'!
    doOneMinimalCycleNow
	"Immediately do one cycle of the interaction loop.
	Only repair display and process events. For modal menus and such."

	"Repair visual damage."
	self displayWorldSafely.

	"Process user input events. Run all event triggered code."
	^activeHand processEventQueue! !

!WorldState methodsFor: 'update cycle' stamp: 'jmv 6/19/2017 15:59:45'!
                       tryDeferredUpdatingAndSetCanvas
        "If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, set a non-Disply canvas and answer false.."
	| properDisplay |
	
	"As this is the only sender of #deferUpdates: , this could be done in Morphic or image startup, and never efterwards..."
	(Display deferUpdates: true) ifNil: [
		"deferred updates not supported by the VM, do them in the image!!"
		self ensureNonDisplayCanvas.
		^ false].
	
	"if no canvas, or canvas was offscreen, from a platform that didnt support defers, then fix it"
	properDisplay _ canvas notNil and: [canvas drawsOnDisplay].
	properDisplay ifFalse: [
		world morphPosition: `0@0` extent: Display extent.
		self setCanvas: Display getCanvas.
	].
	^ true! !

!WorldState methodsFor: 'drawing' stamp: 'jmv 3/2/2017 19:43:18'!
         displayWorldAndSubmorphs: submorphs
	"Update this world's display."

	| deferredUpdateVMMode worldDamageRects handsToDraw allDamage |
	self checkIfUpdateNeeded ifFalse: [ ^ self ].  "display is already up-to-date"
	"I (jmv) removed the call to 'deferUpdates: false' below. No more need to call this every time."
	deferredUpdateVMMode _ self tryDeferredUpdatingAndSetCanvas.

	"repair world's damage on canvas"
	worldDamageRects _ self drawInvalidAreasSubmorphs: submorphs.

	"Check which hands need to be drawn (they are not the hardware mouse pointer)"
	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.
	allDamage _ Array streamContents: [ :strm |
		strm nextPutAll: worldDamageRects.
		handsToDraw do: [ :h | 
			h savePatchFrom: canvas appendDamageTo: strm ]].

	"Draw hands (usually carying morphs) onto world canvas"
	canvas newClipRect: nil.
	handsToDraw reverseDo: [ :h | canvas fullDrawHand: h ].

	"quickly copy altered rects of canvas to Display:"
	deferredUpdateVMMode ifFalse: [
		"Drawing was done to off-Display canvas. Copy content to Display"
		canvas showAt: world viewBox origin invalidRects: allDamage ].

	"Display deferUpdates: false."
	"Display forceDisplayUpdate"
	Display forceDamageToScreen: allDamage.

	"Restore world canvas under hands and their carried morphs"
	handsToDraw do: [ :h | h restoreSavedPatchOn: canvas ].! !

!WorldState methodsFor: 'drawing' stamp: 'jmv 3/2/2017 19:40:12'!
       drawInvalidAreasSubmorphs: submorphs
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."

	| initialRectsToRepair currentRectsToRepair newRectsToRepair morphsToDraw rectsForEachMorph thisMorphRects reuse i n morph morphBounds morphClipRect |

	"The simple implementation is slowers as it draws morph areas that will later be covered by other morphs.
	But it works, and it is easier to understand.
	See en.wikipedia.org/wiki/Painter's_algorithm"
	true not ifTrue: [ ^self simpleDrawInvalidAreasSubmorphs: submorphs ].

	"The response for #invalidRectsFullBounds: can include nils, that should be ignored."
	initialRectsToRepair _ damageRecorder invalidRectsFullBounds: world viewBox.
	damageRecorder reset.
	currentRectsToRepair _ OrderedCollection new.
	newRectsToRepair _ OrderedCollection withAll: initialRectsToRepair.
	morphsToDraw _ OrderedCollection new.
	rectsForEachMorph _ OrderedCollection new.
	thisMorphRects _ OrderedCollection new.
	n _ submorphs size.
	i _ 1.

	"The idea here is to iterate morphs front to back, i.e. first the ones on top.
	For each morph, record the rectangles it affects. And if a morph is opaque, remove the area behind it from the list of rectangles to be repaired.
	This means, for example, that morphs completely covered might even not be redrawn.
	this is a huge performance gain when there are many morphs on screen, especially if there are more than ten open windows, and Theme uses opaque colors.
	See 'A reverse painter's algorithm' at en.wikipedia.org/wiki/Painter's_algorithm"
	[ i <= n and: [ newRectsToRepair notEmpty ]] whileTrue: [
		morph _ submorphs at: i.
		morph visible ifTrue: [
			morphBounds _ morph morphFullBoundsInWorld.
			reuse _ currentRectsToRepair.
			currentRectsToRepair _ newRectsToRepair.
			newRectsToRepair _ reuse removeAll.
			currentRectsToRepair do: [ :r |
				(morphBounds intersects: r)
					ifTrue: [
						morphClipRect _ morphBounds intersect: r.
						thisMorphRects add: morphClipRect. "We could perhaps try and join adjacent rectangles in this collection..."
						morph addPossiblyUncoveredAreasIn: r to: newRectsToRepair ]
					ifFalse: [
						newRectsToRepair add: r ]].
			thisMorphRects ifNotEmpty: [
				morphsToDraw add: morph.
				rectsForEachMorph add: thisMorphRects.
				thisMorphRects _ OrderedCollection new.
			]].
		i _ i + 1 ].

	"*make this true to flash damaged areas for testing*"
	Preferences debugShowDamage ifTrue: [ world fillRects: initialRectsToRepair color: Color gray ].

	"Draw world background on those areas that were not completely covered by opaque morphs"
	i > n  ifTrue: [
		newRectsToRepair do: [ :r |
			world drawOn: (canvas newClipRect: r) ]].

	"Now, draw the recorded areas of selected morphs, back to front."
	morphsToDraw with: rectsForEachMorph reverseDo: [ :m :xrects |
		"Here we could think about merging all xrects into just one call...
		This would mean drawing each morph just once.
		But that would mean drawing pixels we were not told to. There could be other morphs in that area that are not even being drawn!!
		See WorldState class >> #experiment1"
"		rr _ nil."
		xrects do: [ :r |
"			rr _ rr ifNil: [ r ] ifNotNil: [ r quickMerge: rr ]."
			(canvas newClipRect: r) fullDraw: m.
		].
"		(canvas newClipRect: rr) fullDraw: m"
		"*make this true to flash damaged areas for testing*"
		Preferences debugShowDamage2 ifTrue: [
			world flashRects: xrects color: Color random ].
	].

	"Answer a list of rectangles to be updated on the Display.
	This usually is not performance critical, drawing morphs is slower than just exposing the Display."
	"What should we force on Display? Whatever was asked? Each small rect that was updated? A single bigger rect?
	Right now, answer whatever was asked... Maybe this could be changed if that enhances performance...
	(think of vnc over slow networks)"
	^ initialRectsToRepair! !

!WorldState methodsFor: 'drawing' stamp: 'jmv 3/2/2017 19:39:56'!
   simpleDrawInvalidAreasSubmorphs: submorphs

	"mover todo esto al canvas, no?
	Y ver que hacer con los argumentos, etc.... Toda esta bananarama!!"

	"Redraw the damaged areas of the given canvas and clear the damage list.
	Return a collection of the areas that were redrawn.
	This simple implementation just does as requested: No optimizations are done."

	| rectsToRepair morphBounds |
	"The response for #invalidRectsFullBounds: can include nils, that should be ignored."
	rectsToRepair _ damageRecorder invalidRectsFullBounds: world viewBox.
	damageRecorder reset.

	"Draw World"
	rectsToRepair do: [ :r |
		world drawOn: (canvas newClipRect: r) ].

	"Draw morphs"
	submorphs reverseDo: [ :morph |
		morph visible ifTrue: [
			morphBounds _ morph morphFullBoundsInWorld.
			rectsToRepair do: [ :r |
				(morphBounds intersects: r) ifTrue: [
					(canvas newClipRect: r) fullDraw: morph ]]]].

	^ rectsToRepair! !

!WorldState methodsFor: 'accessing' stamp: 'jmv 3/3/2017 11:39:10'!
        runLocalStepMethods: nowTime
	"Run morph 'step' methods (LOCAL TO THIS WORLD) whose time has come. Purge any morphs that are no longer in this world."

	| stepMessage |
	[ stepList notEmpty and: [ stepList first scheduledTime <= nowTime ]] 
		whileTrue: [

			stepMessage _ stepList first.
			(stepMessage receiver shouldGetStepsFrom: world)
				ifTrue: [
					stepMessage valueAtTime: nowTime.
					"If it was not removed from the list during its own evaluation"
					stepMessage == stepList first ifTrue: [
						stepList removeFirst.
						stepMessage rescheduleAfter: nowTime.
						stepList add: stepMessage ]]

				ifFalse: [ stepList removeFirst ].
		]! !


WorldState class
	instanceVariableNames: ''!

!WorldState class methodsFor: 'sample code' stamp: 'jmv 3/2/2017 19:39:21'!
             experiment1
	"To play with and learn about morphic Display update logic.
	Remove the morphs when done!!"
	"
	WorldState experiment1
	"
	| dr morph1 morph2 s w |
	morph1 _ RectangleLikeMorph new openInWorld.
	morph2 _ RectangleLikeMorph new openInWorld.
	morph2 color: Color green.
	morph2 morphPosition: 200@800 extent: 50@40.
	morph1 morphPosition: 120@720 extent: 220@100.

	w _ self runningWorld.
	s _ w instVarNamed: 'worldState'.
	dr _ s instVarNamed: 'damageRecorder'.

	dr doFullRepaint.
	dr reset;
	"	recordInvalidRect: (100@700 corner: 400@900);"
		recordInvalidRect: (100@700 corner: 150@900);
		recordInvalidRect: (300@700 corner: 400@900).
	Display fillColor: Color gray.
	"Do not draw the area used by the small rectangle, unless it is also drawn!!"
	s drawInvalidAreasSubmorphs: {morph1. morph2 }! !


PositionableStream subclass: #WriteStream
	instanceVariableNames: 'writeLimit'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

!WriteStream methodsFor: 'accessing' stamp: 'jmv 11/17/2016 10:28:35'!
         nextPut: anObject 
	"Insert the argument at the next position in the Stream represented by the receiver."

	position >= writeLimit
		ifTrue: [^ self pastEndPut: anObject]
		ifFalse: [
			position _ position + 1.
			^collection at: position put: anObject]! !

!WriteStream methodsFor: 'accessing' stamp: 'jmv 1/3/2017 21:22:51'!
                        nextPutAll: aCollection

	| newEnd |
	(self isCompatibleWithContents: aCollection)
		ifFalse: [ ^ super nextPutAll: aCollection ].

	newEnd _ position + aCollection size.
	newEnd > writeLimit ifTrue: [
		self growTo: newEnd + 10].

	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: 1.
	position _ newEnd.! !

!WriteStream methodsFor: 'accessing' stamp: 'jmv 3/12/2017 18:55:36'!
         nextPutAllString: aString withAttributes: attributesArray

	| newEnd |
	(self isCompatibleWithContents: aString)
		ifFalse: [ ^ self nextPutAll: aString ].

	newEnd _ position + aString size.
	newEnd > writeLimit ifTrue: [
		self growTo: newEnd + 10].

	collection
		replaceFrom: position+1
		to: newEnd 
		withString: aString
		attributes: attributesArray
		startingAt: 1.
	position _ newEnd! !

!WriteStream methodsFor: 'private' stamp: 'jmv 3/12/2017 19:08:07'!
               growTo: anInteger
	"Grow the collection by creating a new bigger collection and then
	copy over the contents from the old one. We grow by doubling the size.

	anInteger is the required minimal new size of the collection "

	| oldSize grownCollection newSize |
	oldSize _ collection size.
     newSize _ anInteger + (oldSize max: 20).
	grownCollection _ collection class new: newSize.
	collection _ grownCollection replaceFrom: 1 to: oldSize with: collection startingAt: 1.
	writeLimit _ collection size! !

!WriteStream methodsFor: 'private' stamp: 'jmv 1/3/2017 21:21:34'!
  isCompatibleWithContents: aCollection

	collection class == aCollection class
		ifTrue: [ ^ true ].

	(aCollection isString and: [ collection is: #Text])
		ifTrue: [ ^ true ].

	^ false! !

!WriteStream methodsFor: 'private' stamp: 'jmv 3/12/2017 19:07:28'!
                              pastEndPut: anObject
	"Grow the collection.
	Then we put <anObject> at the current write position."

	self growTo: collection size + 1.
	collection at: (position _ position + 1) put: anObject! !

!WriteStream methodsFor: 'private' stamp: 'jmv 1/3/2017 10:57:15'!
                         withAttribute: aTextAttribute do: streamBlock
	| pos1 val |

	(collection is: #Text) ifFalse: [
		^streamBlock value ].

	pos1 _ self position.
	val _ streamBlock value.
	collection addAttribute: aTextAttribute from: pos1+1 to: self position.
	^ val! !

!WriteStream methodsFor: 'private' stamp: 'jmv 1/3/2017 10:57:19'!
                               withAttributes: attributes do: streamBlock 
	| pos1 val |

	(collection is: #Text) ifFalse: [
		^streamBlock value ].

	pos1 _ self position.
	val _ streamBlock value.
	attributes do: [:attribute |
		collection
			addAttribute: attribute
			from: pos1 + 1
			to: self position].
	^ val! !


Timespan subclass: #Year
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Chronology'!

!Year methodsFor: 'public protocol' stamp: 'jmv 5/13/2017 14:51:58'!
                     yearNumber

	^ start yearNumber! !

!Year methodsFor: 'double displatching' stamp: 'jmv 9/18/2017 17:23:04'!
                   subtractFrom: aTimespan

	^ aTimespan subtractYear: self! !

!Year methodsFor: 'double displatching' stamp: 'jmv 9/18/2017 17:24:41'!
                          subtractYear: aYear
	"Years can be subtracted even if one of them is leap and the other isn't."

	^self start subtractDateAndtime: aYear start! !


Year class
	instanceVariableNames: ''!

!Year class methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 18:00:49'!
                         includingDateAndTime: aDateAndTime
	"Answer a calendar year"

	^ self yearNumber: aDateAndTime yearNumber! !

!Year class methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 16:41:15'!
       readFrom: aStream 

	| year sign |
	sign := aStream peek = $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isDigit] whileFalse: [aStream skip: 1].
	year := (Integer readFrom: aStream) * sign.
	^ self yearNumber: year! !

!Year class methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 17:43:17'!
                           yearNumber: aYear

	| yearStart |
	yearStart _ DateAndTime year: aYear month: 1 day: 1.
	^ self basicNew
 		start: yearStart;
		duration: (Duration days: (self daysInYear: yearStart yearNumber));
		yourself! !


----QUIT----#(11 October 2017 7:03:06.001046 am) Cuis5.0-3192-test5.image priorSource: 869778!

----STARTUP----#(11 October 2017 7:03:27.424602 am) as /home/phil/Development/Smalltalk/phil-images/bug/Cuis5.0-3192-test5.image!


ReferenceFinder openExplorerOn: (((results := CNGKillVm boom) at: 60000) rows at: 1).!

----STARTUP----#(11 October 2017 2:51:24.673243 pm) as /home/phil/Development/Smalltalk/phil-images/bug/Cuis5.0-3192-test5.image!


ReferenceFinder openExplorerOn: (((results := CNGKillVm boom) at: 60000) rows at: 1).!

----QUIT/NOSAVE----#(11 October 2017 3:01:40.523755 pm) Cuis5.0-3192-test5.image priorSource: 869778!

----STARTUP----#(11 October 2017 3:20:27.951071 pm) as /home/phil/Development/Smalltalk/phil-images/bug/Cuis5.0-3192-test5.image!


ReferenceFinder openExplorerOn: (((results := CNGKillVm boom) at: 60000) rows at: 1).!

----STARTUP----#(11 October 2017 3:28:41.521049 pm) as /home/phil/Development/Smalltalk/phil-images/bug/Cuis5.0-3192-test5.image!


----SNAPSHOT----#(11 October 2017 3:28:49.136998 pm) Cuis5.0-3192-cng.image priorSource: 869778!

----QUIT/NOSAVE----#(11 October 2017 3:28:55.254318 pm) Cuis5.0-3192-cng.image priorSource: 870769!